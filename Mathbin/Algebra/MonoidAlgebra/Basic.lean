import Mathbin.Algebra.BigOperators.Finsupp
import Mathbin.LinearAlgebra.Finsupp
import Mathbin.Algebra.NonUnitalAlgHom

/-!
# Monoid algebras

When the domain of a `finsupp` has a multiplicative or additive structure, we can define
a convolution product. To mathematicians this structure is known as the "monoid algebra",
i.e. the finite formal linear combinations over a given semiring of elements of the monoid.
The "group ring" ℤ[G] or the "group algebra" k[G] are typical uses.

In fact the construction of the "monoid algebra" makes sense when `G` is not even a monoid, but
merely a magma, i.e., when `G` carries a multiplication which is not required to satisfy any
conditions at all. In this case the construction yields a not-necessarily-unital,
not-necessarily-associative algebra but it is still adjoint to the forgetful functor from such
algebras to magmas, and we prove this as `monoid_algebra.lift_magma`.

In this file we define `monoid_algebra k G := G →₀ k`, and `add_monoid_algebra k G`
in the same way, and then define the convolution product on these.

When the domain is additive, this is used to define polynomials:
```
polynomial α := add_monoid_algebra ℕ α
mv_polynomial σ α := add_monoid_algebra (σ →₀ ℕ) α
```

When the domain is multiplicative, e.g. a group, this will be used to define the group ring.

## Implementation note
Unfortunately because additive and multiplicative structures both appear in both cases,
it doesn't appear to be possible to make much use of `to_additive`, and we just settle for
saying everything twice.

Similarly, I attempted to just define
`add_monoid_algebra k G := monoid_algebra k (multiplicative G)`, but the definitional equality
`multiplicative G = G` leaks through everywhere, and seems impossible to use.
-/


noncomputable section

open_locale Classical BigOperators

open Finset Finsupp

universe u₁ u₂ u₃

variable (k : Type u₁) (G : Type u₂)

/-! ### Multiplicative monoids -/


section

variable [Semiringₓ k]

-- ././Mathport/Syntax/Translate/Basic.lean:833:9: unsupported derive handler inhabited
-- ././Mathport/Syntax/Translate/Basic.lean:833:9: unsupported derive handler add_comm_monoid
/-- 
The monoid algebra over a semiring `k` generated by the monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with the convolution product.
-/
def MonoidAlgebra : Type max u₁ u₂ :=
  G →₀ k deriving [anonymous], [anonymous]

instance : CoeFun (MonoidAlgebra k G) fun _ => G → k :=
  Finsupp.hasCoeToFun

end

namespace MonoidAlgebra

variable {k G}

section Mul

variable [Semiringₓ k] [Mul G]

/--  The product of `f g : monoid_algebra k G` is the finitely supported function
  whose value at `a` is the sum of `f x * g y` over all pairs `x, y`
  such that `x * y = a`. (Think of the group ring of a group.) -/
instance : Mul (MonoidAlgebra k G) :=
  ⟨fun f g => f.sum $ fun a₁ b₁ => g.sum $ fun a₂ b₂ => single (a₁*a₂) (b₁*b₂)⟩

theorem mul_def {f g : MonoidAlgebra k G} :
    (f*g) = (f.sum $ fun a₁ b₁ => g.sum $ fun a₂ b₂ => single (a₁*a₂) (b₁*b₂)) :=
  rfl

instance : NonUnitalNonAssocSemiring (MonoidAlgebra k G) :=
  { Finsupp.addCommMonoid with zero := 0, mul := ·*·, add := ·+·,
    left_distrib := fun f g h => by
      simp only [mul_def, sum_add_index, mul_addₓ, mul_zero, single_zero, single_add, eq_self_iff_true, forall_true_iff,
        forall_3_true_iff, sum_add],
    right_distrib := fun f g h => by
      simp only [mul_def, sum_add_index, add_mulₓ, zero_mul, single_zero, single_add, eq_self_iff_true, forall_true_iff,
        forall_3_true_iff, sum_zero, sum_add],
    zero_mul := fun f => by
      simp only [mul_def, sum_zero_index],
    mul_zero := fun f => by
      simp only [mul_def, sum_zero_index, sum_zero] }

end Mul

section Semigroupₓ

variable [Semiringₓ k] [Semigroupₓ G]

instance : NonUnitalSemiring (MonoidAlgebra k G) :=
  { MonoidAlgebra.nonUnitalNonAssocSemiring with zero := 0, mul := ·*·, add := ·+·,
    mul_assoc := fun f g h => by
      simp only [mul_def, sum_sum_index, sum_zero_index, sum_add_index, sum_single_index, single_zero, single_add,
        eq_self_iff_true, forall_true_iff, forall_3_true_iff, add_mulₓ, mul_addₓ, add_assocₓ, mul_assocₓ, zero_mul,
        mul_zero, sum_zero, sum_add] }

end Semigroupₓ

section HasOne

variable [Semiringₓ k] [HasOne G]

/--  The unit of the multiplication is `single 1 1`, i.e. the function
  that is `1` at `1` and zero elsewhere. -/
instance : HasOne (MonoidAlgebra k G) :=
  ⟨single 1 1⟩

theorem one_def : (1 : MonoidAlgebra k G) = single 1 1 :=
  rfl

end HasOne

section MulOneClass

variable [Semiringₓ k] [MulOneClass G]

instance : NonAssocSemiring (MonoidAlgebra k G) :=
  { MonoidAlgebra.nonUnitalNonAssocSemiring with one := 1, mul := ·*·, zero := 0, add := ·+·,
    one_mul := fun f => by
      simp only [mul_def, one_def, sum_single_index, zero_mul, single_zero, sum_zero, zero_addₓ, one_mulₓ, sum_single],
    mul_one := fun f => by
      simp only [mul_def, one_def, sum_single_index, mul_zero, single_zero, sum_zero, add_zeroₓ, mul_oneₓ, sum_single] }

variable {R : Type _} [Semiringₓ R]

/--  A non-commutative version of `monoid_algebra.lift`: given a additive homomorphism `f : k →+ R`
and a multiplicative monoid homomorphism `g : G →* R`, returns the additive homomorphism from
`monoid_algebra k G` such that `lift_nc f g (single a b) = f b * g a`. If `f` is a ring homomorphism
and the range of either `f` or `g` is in center of `R`, then the result is a ring homomorphism.  If
`R` is a `k`-algebra and `f = algebra_map k R`, then the result is an algebra homomorphism called
`monoid_algebra.lift`. -/
def lift_nc (f : k →+ R) (g : G →* R) : MonoidAlgebra k G →+ R :=
  lift_add_hom fun x : G => (AddMonoidHom.mulRight (g x)).comp f

@[simp]
theorem lift_nc_single (f : k →+ R) (g : G →* R) (a : G) (b : k) : lift_nc f g (single a b) = f b*g a :=
  lift_add_hom_apply_single _ _ _

@[simp]
theorem lift_nc_one (f : k →+* R) (g : G →* R) : lift_nc (f : k →+ R) g 1 = 1 := by
  simp [one_def]

theorem lift_nc_mul (f : k →+* R) (g : G →* R) (a b : MonoidAlgebra k G)
    (h_comm : ∀ {x y}, y ∈ a.support → Commute (f (b x)) (g y)) :
    lift_nc (f : k →+ R) g (a*b) = lift_nc (f : k →+ R) g a*lift_nc (f : k →+ R) g b := by
  conv_rhs => rw [← sum_single a, ← sum_single b]
  simp_rw [mul_def, (lift_nc _ g).map_finsupp_sum, lift_nc_single, Finsupp.sum_mul, Finsupp.mul_sum]
  refine' Finset.sum_congr rfl fun y hy => Finset.sum_congr rfl fun x hx => _
  simp [mul_assocₓ, (h_comm hy).left_comm]

end MulOneClass

/-! #### Semiring structure -/


section Semiringₓ

variable [Semiringₓ k] [Monoidₓ G]

instance : Semiringₓ (MonoidAlgebra k G) :=
  { MonoidAlgebra.nonUnitalSemiring, MonoidAlgebra.nonAssocSemiring with one := 1, mul := ·*·, zero := 0, add := ·+· }

variable {R : Type _} [Semiringₓ R]

/--  `lift_nc` as a `ring_hom`, for when `f x` and `g y` commute -/
def lift_nc_ring_hom (f : k →+* R) (g : G →* R) (h_comm : ∀ x y, Commute (f x) (g y)) : MonoidAlgebra k G →+* R :=
  { lift_nc (f : k →+ R) g with toFun := lift_nc (f : k →+ R) g, map_one' := lift_nc_one _ _,
    map_mul' := fun a b => lift_nc_mul _ _ _ _ $ fun _ _ _ => h_comm _ _ }

end Semiringₓ

instance [CommSemiringₓ k] [CommMonoidₓ G] : CommSemiringₓ (MonoidAlgebra k G) :=
  { MonoidAlgebra.semiring with
    mul_comm := fun f g => by
      simp only [mul_def, Finsupp.sum, mul_commₓ]
      rw [Finset.sum_comm]
      simp only [mul_commₓ] }

instance [Semiringₓ k] [Nontrivial k] [Nonempty G] : Nontrivial (MonoidAlgebra k G) :=
  Finsupp.nontrivial

/-! #### Derived instances -/


section DerivedInstances

instance [Semiringₓ k] [Subsingleton k] : Unique (MonoidAlgebra k G) :=
  Finsupp.uniqueOfRight

instance [Ringₓ k] : AddGroupₓ (MonoidAlgebra k G) :=
  Finsupp.addGroup

instance [Ringₓ k] [Monoidₓ G] : Ringₓ (MonoidAlgebra k G) :=
  { MonoidAlgebra.semiring with neg := Neg.neg, add_left_neg := add_left_negₓ }

instance [CommRingₓ k] [CommMonoidₓ G] : CommRingₓ (MonoidAlgebra k G) :=
  { MonoidAlgebra.ring with mul_comm := mul_commₓ }

variable {R S : Type _}

instance [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] : HasScalar R (MonoidAlgebra k G) :=
  Finsupp.hasScalar

instance [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] : DistribMulAction R (MonoidAlgebra k G) :=
  Finsupp.distribMulAction G k

instance [Semiringₓ R] [Semiringₓ k] [Module R k] : Module R (MonoidAlgebra k G) :=
  Finsupp.module G k

instance [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] [HasFaithfulScalar R k] [Nonempty G] :
    HasFaithfulScalar R (MonoidAlgebra k G) :=
  Finsupp.has_faithful_scalar

instance [Monoidₓ R] [Monoidₓ S] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction S k] [HasScalar R S]
    [IsScalarTower R S k] : IsScalarTower R S (MonoidAlgebra k G) :=
  Finsupp.is_scalar_tower G k

instance [Monoidₓ R] [Monoidₓ S] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction S k] [SmulCommClass R S k] :
    SmulCommClass R S (MonoidAlgebra k G) :=
  Finsupp.smul_comm_class G k

instance [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction (Rᵐᵒᵖ) k] [IsCentralScalar R k] :
    IsCentralScalar R (MonoidAlgebra k G) :=
  Finsupp.is_central_scalar G k

instance comap_distrib_mul_action_self [Groupₓ G] [Semiringₓ k] : DistribMulAction G (MonoidAlgebra k G) :=
  Finsupp.comapDistribMulActionSelf

end DerivedInstances

section MiscTheorems

variable [Semiringₓ k]

attribute [local reducible] MonoidAlgebra

theorem mul_apply [Mul G] (f g : MonoidAlgebra k G) (x : G) :
    (f*g) x = (f.sum $ fun a₁ b₁ => g.sum $ fun a₂ b₂ => if (a₁*a₂) = x then b₁*b₂ else 0) := by
  rw [mul_def]
  simp only [Finsupp.sum_apply, single_apply]

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers [] [] [] [] [] [])
 (Command.theorem
  "theorem"
  (Command.declId `mul_apply_antidiagonal [])
  (Command.declSig
   [(Term.instBinder "[" [] (Term.app `Mul [`G]) "]")
    (Term.explicitBinder "(" [`f `g] [":" (Term.app `MonoidAlgebra [`k `G])] [] ")")
    (Term.explicitBinder "(" [`x] [":" `G] [] ")")
    (Term.explicitBinder "(" [`s] [":" (Term.app `Finset [(«term_×_» `G "×" `G)])] [] ")")
    (Term.explicitBinder
     "("
     [`hs]
     [":"
      (Term.forall
       "∀"
       [(Term.implicitBinder "{" [`p] [":" («term_×_» `G "×" `G)] "}")]
       ","
       («term_↔_»
        (Init.Core.«term_∈_» `p " ∈ " `s)
        "↔"
        («term_=_»
         (Finset.Data.Finset.Fold.«term_*_» (Term.proj `p "." (fieldIdx "1")) "*" (Term.proj `p "." (fieldIdx "2")))
         "="
         `x)))]
     []
     ")")]
   (Term.typeSpec
    ":"
    («term_=_»
     (Term.app (Finset.Data.Finset.Fold.«term_*_» `f "*" `g) [`x])
     "="
     (Algebra.BigOperators.Basic.«term∑_in_,_»
      "∑"
      (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
      " in "
      `s
      ", "
      (Finset.Data.Finset.Fold.«term_*_»
       (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
       "*"
       (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))))
  (Command.declValSimple
   ":="
   (Term.let
    "let"
    (Term.letDecl
     (Term.letIdDecl
      `F
      []
      [(Term.typeSpec ":" (Term.arrow («term_×_» `G "×" `G) "→" `k))]
      ":="
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.simpleBinder [`p] [])]
        "=>"
        (termIfThenElse
         "if"
         («term_=_»
          (Finset.Data.Finset.Fold.«term_*_» (Term.proj `p "." (fieldIdx "1")) "*" (Term.proj `p "." (fieldIdx "2")))
          "="
          `x)
         "then"
         (Finset.Data.Finset.Fold.«term_*_»
          (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
          "*"
          (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))
         "else"
         (numLit "0"))))))
    []
    (calc
     "calc"
     [(calcStep
       («term_=_»
        (Term.app (Finset.Data.Finset.Fold.«term_*_» `f "*" `g) [`x])
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `a₁)] []))
         " in "
         `f.support
         ", "
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `a₂)] []))
          " in "
          `g.support
          ", "
          (Term.app `F [(Term.paren "(" [`a₁ [(Term.tupleTail "," [`a₂])]] ")")]))))
       ":="
       (Term.app `mul_apply [`f `g `x]))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
         " in "
         (Term.app `f.support.product [`g.support])
         ", "
         (Term.app `F [`p])))
       ":="
       (Term.proj `Finset.sum_product "." `symm))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
         " in "
         (Term.app
          (Term.proj (Term.app `f.support.product [`g.support]) "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`p] [(Term.typeSpec ":" («term_×_» `G "×" `G))])]
             "=>"
             («term_=_»
              (Finset.Data.Finset.Fold.«term_*_»
               (Term.proj `p "." (fieldIdx "1"))
               "*"
               (Term.proj `p "." (fieldIdx "2")))
              "="
              `x)))])
         ", "
         (Finset.Data.Finset.Fold.«term_*_»
          (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
          "*"
          (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
       ":="
       (Term.proj (Term.app `Finset.sum_filter [(Term.hole "_") (Term.hole "_")]) "." `symm))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
         " in "
         (Term.app
          `s.filter
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`p] [(Term.typeSpec ":" («term_×_» `G "×" `G))])]
             "=>"
             («term_∧_»
              (Init.Core.«term_∈_» (Term.proj `p "." (fieldIdx "1")) " ∈ " `f.support)
              "∧"
              (Init.Core.«term_∈_» (Term.proj `p "." (fieldIdx "2")) " ∈ " `g.support))))])
         ", "
         (Finset.Data.Finset.Fold.«term_*_»
          (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
          "*"
          (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
       ":="
       (Term.app
        `sum_congr
        [(Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group (Tactic.ext "ext" [] []) [])
             (group
              (Tactic.simp
               "simp"
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] `mem_filter)
                 ","
                 (Tactic.simpLemma [] [] `mem_product)
                 ","
                 (Tactic.simpLemma [] [] `hs)
                 ","
                 (Tactic.simpLemma [] [] `and_comm)]
                "]"]
               [])
              [])])))
         (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
         " in "
         `s
         ", "
         (Finset.Data.Finset.Fold.«term_*_»
          (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
          "*"
          (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
       ":="
       («term_$__»
        (Term.app `sum_subset [(Term.app `filter_subset [(Term.hole "_") (Term.hole "_")])])
        "$"
        (Term.fun
         "fun"
         (Term.basicFun
          [(Term.simpleBinder [`p `hps `hp] [])]
          "=>"
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(group
               (Tactic.simp
                "simp"
                []
                ["only"]
                ["["
                 [(Tactic.simpLemma [] [] `mem_filter)
                  ","
                  (Tactic.simpLemma [] [] `mem_support_iff)
                  ","
                  (Tactic.simpLemma [] [] `not_and)
                  ","
                  (Tactic.simpLemma [] [] `not_not)]
                 "]"]
                [(Tactic.location "at" (Tactic.locationHyp [`hp] ["⊢"]))])
               [])
              (group
               (Tactic.byCases'
                "by_cases'"
                [`h1 ":"]
                («term_=_» (Term.app `f [(Term.proj `p "." (fieldIdx "1"))]) "=" (numLit "0")))
               [])
              (group
               (Tactic.«tactic·._»
                "·"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h1) "," (Tactic.rwRule [] `zero_mul)] "]")
                     [])
                    [])])))
               [])
              (group
               (Tactic.«tactic·._»
                "·"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] (Term.app `hp [`hps `h1])) "," (Tactic.rwRule [] `mul_zero)]
                      "]")
                     [])
                    [])])))
               [])])))))))]))
   [])
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.let
   "let"
   (Term.letDecl
    (Term.letIdDecl
     `F
     []
     [(Term.typeSpec ":" (Term.arrow («term_×_» `G "×" `G) "→" `k))]
     ":="
     (Term.fun
      "fun"
      (Term.basicFun
       [(Term.simpleBinder [`p] [])]
       "=>"
       (termIfThenElse
        "if"
        («term_=_»
         (Finset.Data.Finset.Fold.«term_*_» (Term.proj `p "." (fieldIdx "1")) "*" (Term.proj `p "." (fieldIdx "2")))
         "="
         `x)
        "then"
        (Finset.Data.Finset.Fold.«term_*_»
         (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
         "*"
         (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))
        "else"
        (numLit "0"))))))
   []
   (calc
    "calc"
    [(calcStep
      («term_=_»
       (Term.app (Finset.Data.Finset.Fold.«term_*_» `f "*" `g) [`x])
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `a₁)] []))
        " in "
        `f.support
        ", "
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `a₂)] []))
         " in "
         `g.support
         ", "
         (Term.app `F [(Term.paren "(" [`a₁ [(Term.tupleTail "," [`a₂])]] ")")]))))
      ":="
      (Term.app `mul_apply [`f `g `x]))
     (calcStep
      («term_=_»
       (Term.hole "_")
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
        " in "
        (Term.app `f.support.product [`g.support])
        ", "
        (Term.app `F [`p])))
      ":="
      (Term.proj `Finset.sum_product "." `symm))
     (calcStep
      («term_=_»
       (Term.hole "_")
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
        " in "
        (Term.app
         (Term.proj (Term.app `f.support.product [`g.support]) "." `filter)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`p] [(Term.typeSpec ":" («term_×_» `G "×" `G))])]
            "=>"
            («term_=_»
             (Finset.Data.Finset.Fold.«term_*_» (Term.proj `p "." (fieldIdx "1")) "*" (Term.proj `p "." (fieldIdx "2")))
             "="
             `x)))])
        ", "
        (Finset.Data.Finset.Fold.«term_*_»
         (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
         "*"
         (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
      ":="
      (Term.proj (Term.app `Finset.sum_filter [(Term.hole "_") (Term.hole "_")]) "." `symm))
     (calcStep
      («term_=_»
       (Term.hole "_")
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
        " in "
        (Term.app
         `s.filter
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`p] [(Term.typeSpec ":" («term_×_» `G "×" `G))])]
            "=>"
            («term_∧_»
             (Init.Core.«term_∈_» (Term.proj `p "." (fieldIdx "1")) " ∈ " `f.support)
             "∧"
             (Init.Core.«term_∈_» (Term.proj `p "." (fieldIdx "2")) " ∈ " `g.support))))])
        ", "
        (Finset.Data.Finset.Fold.«term_*_»
         (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
         "*"
         (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
      ":="
      (Term.app
       `sum_congr
       [(Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(group (Tactic.ext "ext" [] []) [])
            (group
             (Tactic.simp
              "simp"
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `mem_filter)
                ","
                (Tactic.simpLemma [] [] `mem_product)
                ","
                (Tactic.simpLemma [] [] `hs)
                ","
                (Tactic.simpLemma [] [] `and_comm)]
               "]"]
              [])
             [])])))
        (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
     (calcStep
      («term_=_»
       (Term.hole "_")
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
        " in "
        `s
        ", "
        (Finset.Data.Finset.Fold.«term_*_»
         (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
         "*"
         (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
      ":="
      («term_$__»
       (Term.app `sum_subset [(Term.app `filter_subset [(Term.hole "_") (Term.hole "_")])])
       "$"
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`p `hps `hp] [])]
         "=>"
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group
              (Tactic.simp
               "simp"
               []
               ["only"]
               ["["
                [(Tactic.simpLemma [] [] `mem_filter)
                 ","
                 (Tactic.simpLemma [] [] `mem_support_iff)
                 ","
                 (Tactic.simpLemma [] [] `not_and)
                 ","
                 (Tactic.simpLemma [] [] `not_not)]
                "]"]
               [(Tactic.location "at" (Tactic.locationHyp [`hp] ["⊢"]))])
              [])
             (group
              (Tactic.byCases'
               "by_cases'"
               [`h1 ":"]
               («term_=_» (Term.app `f [(Term.proj `p "." (fieldIdx "1"))]) "=" (numLit "0")))
              [])
             (group
              (Tactic.«tactic·._»
               "·"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h1) "," (Tactic.rwRule [] `zero_mul)] "]")
                    [])
                   [])])))
              [])
             (group
              (Tactic.«tactic·._»
               "·"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.rwSeq
                    "rw"
                    []
                    (Tactic.rwRuleSeq
                     "["
                     [(Tactic.rwRule [] (Term.app `hp [`hps `h1])) "," (Tactic.rwRule [] `mul_zero)]
                     "]")
                    [])
                   [])])))
              [])])))))))]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.let', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.let', expected 'Lean.Parser.Term.let.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (calc
   "calc"
   [(calcStep
     («term_=_»
      (Term.app (Finset.Data.Finset.Fold.«term_*_» `f "*" `g) [`x])
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `a₁)] []))
       " in "
       `f.support
       ", "
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `a₂)] []))
        " in "
        `g.support
        ", "
        (Term.app `F [(Term.paren "(" [`a₁ [(Term.tupleTail "," [`a₂])]] ")")]))))
     ":="
     (Term.app `mul_apply [`f `g `x]))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
       " in "
       (Term.app `f.support.product [`g.support])
       ", "
       (Term.app `F [`p])))
     ":="
     (Term.proj `Finset.sum_product "." `symm))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
       " in "
       (Term.app
        (Term.proj (Term.app `f.support.product [`g.support]) "." `filter)
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`p] [(Term.typeSpec ":" («term_×_» `G "×" `G))])]
           "=>"
           («term_=_»
            (Finset.Data.Finset.Fold.«term_*_» (Term.proj `p "." (fieldIdx "1")) "*" (Term.proj `p "." (fieldIdx "2")))
            "="
            `x)))])
       ", "
       (Finset.Data.Finset.Fold.«term_*_»
        (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
        "*"
        (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
     ":="
     (Term.proj (Term.app `Finset.sum_filter [(Term.hole "_") (Term.hole "_")]) "." `symm))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
       " in "
       (Term.app
        `s.filter
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`p] [(Term.typeSpec ":" («term_×_» `G "×" `G))])]
           "=>"
           («term_∧_»
            (Init.Core.«term_∈_» (Term.proj `p "." (fieldIdx "1")) " ∈ " `f.support)
            "∧"
            (Init.Core.«term_∈_» (Term.proj `p "." (fieldIdx "2")) " ∈ " `g.support))))])
       ", "
       (Finset.Data.Finset.Fold.«term_*_»
        (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
        "*"
        (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
     ":="
     (Term.app
      `sum_congr
      [(Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(group (Tactic.ext "ext" [] []) [])
           (group
            (Tactic.simp
             "simp"
             []
             ["only"]
             ["["
              [(Tactic.simpLemma [] [] `mem_filter)
               ","
               (Tactic.simpLemma [] [] `mem_product)
               ","
               (Tactic.simpLemma [] [] `hs)
               ","
               (Tactic.simpLemma [] [] `and_comm)]
              "]"]
             [])
            [])])))
       (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
       " in "
       `s
       ", "
       (Finset.Data.Finset.Fold.«term_*_»
        (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
        "*"
        (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
     ":="
     («term_$__»
      (Term.app `sum_subset [(Term.app `filter_subset [(Term.hole "_") (Term.hole "_")])])
      "$"
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.simpleBinder [`p `hps `hp] [])]
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(group
             (Tactic.simp
              "simp"
              []
              ["only"]
              ["["
               [(Tactic.simpLemma [] [] `mem_filter)
                ","
                (Tactic.simpLemma [] [] `mem_support_iff)
                ","
                (Tactic.simpLemma [] [] `not_and)
                ","
                (Tactic.simpLemma [] [] `not_not)]
               "]"]
              [(Tactic.location "at" (Tactic.locationHyp [`hp] ["⊢"]))])
             [])
            (group
             (Tactic.byCases'
              "by_cases'"
              [`h1 ":"]
              («term_=_» (Term.app `f [(Term.proj `p "." (fieldIdx "1"))]) "=" (numLit "0")))
             [])
            (group
             (Tactic.«tactic·._»
              "·"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(group
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h1) "," (Tactic.rwRule [] `zero_mul)] "]")
                   [])
                  [])])))
             [])
            (group
             (Tactic.«tactic·._»
              "·"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(group
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [] (Term.app `hp [`hps `h1])) "," (Tactic.rwRule [] `mul_zero)]
                    "]")
                   [])
                  [])])))
             [])])))))))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calc', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calcStep', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_$__»
   (Term.app `sum_subset [(Term.app `filter_subset [(Term.hole "_") (Term.hole "_")])])
   "$"
   (Term.fun
    "fun"
    (Term.basicFun
     [(Term.simpleBinder [`p `hps `hp] [])]
     "=>"
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(group
          (Tactic.simp
           "simp"
           []
           ["only"]
           ["["
            [(Tactic.simpLemma [] [] `mem_filter)
             ","
             (Tactic.simpLemma [] [] `mem_support_iff)
             ","
             (Tactic.simpLemma [] [] `not_and)
             ","
             (Tactic.simpLemma [] [] `not_not)]
            "]"]
           [(Tactic.location "at" (Tactic.locationHyp [`hp] ["⊢"]))])
          [])
         (group
          (Tactic.byCases'
           "by_cases'"
           [`h1 ":"]
           («term_=_» (Term.app `f [(Term.proj `p "." (fieldIdx "1"))]) "=" (numLit "0")))
          [])
         (group
          (Tactic.«tactic·._»
           "·"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(group
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h1) "," (Tactic.rwRule [] `zero_mul)] "]")
                [])
               [])])))
          [])
         (group
          (Tactic.«tactic·._»
           "·"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(group
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] (Term.app `hp [`hps `h1])) "," (Tactic.rwRule [] `mul_zero)]
                 "]")
                [])
               [])])))
          [])]))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_$__»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`p `hps `hp] [])]
    "=>"
    (Term.byTactic
     "by"
     (Tactic.tacticSeq
      (Tactic.tacticSeq1Indented
       [(group
         (Tactic.simp
          "simp"
          []
          ["only"]
          ["["
           [(Tactic.simpLemma [] [] `mem_filter)
            ","
            (Tactic.simpLemma [] [] `mem_support_iff)
            ","
            (Tactic.simpLemma [] [] `not_and)
            ","
            (Tactic.simpLemma [] [] `not_not)]
           "]"]
          [(Tactic.location "at" (Tactic.locationHyp [`hp] ["⊢"]))])
         [])
        (group
         (Tactic.byCases'
          "by_cases'"
          [`h1 ":"]
          («term_=_» (Term.app `f [(Term.proj `p "." (fieldIdx "1"))]) "=" (numLit "0")))
         [])
        (group
         (Tactic.«tactic·._»
          "·"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group
              (Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h1) "," (Tactic.rwRule [] `zero_mul)] "]")
               [])
              [])])))
         [])
        (group
         (Tactic.«tactic·._»
          "·"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group
              (Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [] (Term.app `hp [`hps `h1])) "," (Tactic.rwRule [] `mul_zero)]
                "]")
               [])
              [])])))
         [])])))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.byTactic
   "by"
   (Tactic.tacticSeq
    (Tactic.tacticSeq1Indented
     [(group
       (Tactic.simp
        "simp"
        []
        ["only"]
        ["["
         [(Tactic.simpLemma [] [] `mem_filter)
          ","
          (Tactic.simpLemma [] [] `mem_support_iff)
          ","
          (Tactic.simpLemma [] [] `not_and)
          ","
          (Tactic.simpLemma [] [] `not_not)]
         "]"]
        [(Tactic.location "at" (Tactic.locationHyp [`hp] ["⊢"]))])
       [])
      (group
       (Tactic.byCases'
        "by_cases'"
        [`h1 ":"]
        («term_=_» (Term.app `f [(Term.proj `p "." (fieldIdx "1"))]) "=" (numLit "0")))
       [])
      (group
       (Tactic.«tactic·._»
        "·"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(group
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h1) "," (Tactic.rwRule [] `zero_mul)] "]")
             [])
            [])])))
       [])
      (group
       (Tactic.«tactic·._»
        "·"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(group
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hp [`hps `h1])) "," (Tactic.rwRule [] `mul_zero)] "]")
             [])
            [])])))
       [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.byTactic.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq', expected 'Lean.Parser.Tactic.tacticSeq.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeq1Indented.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.«tactic·._»
   "·"
   (Tactic.tacticSeq
    (Tactic.tacticSeq1Indented
     [(group
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hp [`hps `h1])) "," (Tactic.rwRule [] `mul_zero)] "]")
        [])
       [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.«tactic·._»', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq', expected 'Lean.Parser.Tactic.tacticSeq.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeq1Indented.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.rwSeq
   "rw"
   []
   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] (Term.app `hp [`hps `h1])) "," (Tactic.rwRule [] `mul_zero)] "]")
   [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwSeq', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `mul_zero
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `hp [`hps `h1])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `h1
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `hps
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `hp
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, tactic))
  (Tactic.«tactic·._»
   "·"
   (Tactic.tacticSeq
    (Tactic.tacticSeq1Indented
     [(group
       (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h1) "," (Tactic.rwRule [] `zero_mul)] "]") [])
       [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.«tactic·._»', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq', expected 'Lean.Parser.Tactic.tacticSeq.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeq1Indented.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h1) "," (Tactic.rwRule [] `zero_mul)] "]") [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwSeq', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `zero_mul
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `h1
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, tactic))
  (Tactic.byCases' "by_cases'" [`h1 ":"] («term_=_» (Term.app `f [(Term.proj `p "." (fieldIdx "1"))]) "=" (numLit "0")))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.byCases'', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_=_» (Term.app `f [(Term.proj `p "." (fieldIdx "1"))]) "=" (numLit "0"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (numLit "0")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'numLit', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'numLit', expected 'numLit.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
  (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.proj `p "." (fieldIdx "1"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `p
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `f
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1022, (some 1023, term) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«:»', expected 'optional.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, tactic))
  (Tactic.simp
   "simp"
   []
   ["only"]
   ["["
    [(Tactic.simpLemma [] [] `mem_filter)
     ","
     (Tactic.simpLemma [] [] `mem_support_iff)
     ","
     (Tactic.simpLemma [] [] `not_and)
     ","
     (Tactic.simpLemma [] [] `not_not)]
    "]"]
   [(Tactic.location "at" (Tactic.locationHyp [`hp] ["⊢"]))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simp', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.location', expected 'optional.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«⊢»', expected 'optional.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `hp
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«]»', expected 'optional.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `not_not
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `not_and
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `mem_support_iff
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpStar'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `mem_filter
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'only', expected 'optional.antiquot_scope'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.simpleBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 10 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))
  (Term.app `sum_subset [(Term.app `filter_subset [(Term.hole "_") (Term.hole "_")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `filter_subset [(Term.hole "_") (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `filter_subset
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
 "("
 [(Term.app `filter_subset [(Term.hole "_") (Term.hole "_")]) []]
 ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `sum_subset
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 10, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 10, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_=_»
   (Term.hole "_")
   "="
   (Algebra.BigOperators.Basic.«term∑_in_,_»
    "∑"
    (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
    " in "
    `s
    ", "
    (Finset.Data.Finset.Fold.«term_*_»
     (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
     "*"
     (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Algebra.BigOperators.Basic.«term∑_in_,_»
   "∑"
   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
   " in "
   `s
   ", "
   (Finset.Data.Finset.Fold.«term_*_»
    (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
    "*"
    (Term.app `g [(Term.proj `p "." (fieldIdx "2"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∑_in_,_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Finset.Data.Finset.Fold.«term_*_»
   (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
   "*"
   (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Finset.Data.Finset.Fold.«term_*_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `g [(Term.proj `p "." (fieldIdx "2"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.proj `p "." (fieldIdx "2"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `p
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `g
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.proj `p "." (fieldIdx "1"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `p
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `f
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `s
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.explicitBinders', expected 'Mathlib.ExtendedBinder.extBinders'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  mul_apply_antidiagonal
  [ Mul G ]
      ( f g : MonoidAlgebra k G )
      ( x : G )
      ( s : Finset G × G )
      ( hs : ∀ { p : G × G } , p ∈ s ↔ p . 1 * p . 2 = x )
    : f * g x = ∑ p in s , f p . 1 * g p . 2
  :=
    let
      F : G × G → k := fun p => if p . 1 * p . 2 = x then f p . 1 * g p . 2 else 0
      calc
        f * g x = ∑ a₁ in f.support , ∑ a₂ in g.support , F ( a₁ , a₂ ) := mul_apply f g x
          _ = ∑ p in f.support.product g.support , F p := Finset.sum_product . symm
          _ = ∑ p in f.support.product g.support . filter fun p : G × G => p . 1 * p . 2 = x , f p . 1 * g p . 2
            :=
            Finset.sum_filter _ _ . symm
          _ = ∑ p in s.filter fun p : G × G => p . 1 ∈ f.support ∧ p . 2 ∈ g.support , f p . 1 * g p . 2
            :=
            sum_congr by ext simp only [ mem_filter , mem_product , hs , and_comm ] fun _ _ => rfl
          _ = ∑ p in s , f p . 1 * g p . 2
            :=
            sum_subset filter_subset _ _
              $
              fun
                p hps hp
                  =>
                  by
                    simp only [ mem_filter , mem_support_iff , not_and , not_not ] at hp ⊢
                      by_cases' h1 : f p . 1 = 0
                      · rw [ h1 , zero_mul ]
                      · rw [ hp hps h1 , mul_zero ]

theorem support_mul [Mul G] (a b : MonoidAlgebra k G) :
    (a*b).Support ⊆ a.support.bUnion fun a₁ => b.support.bUnion $ fun a₂ => {a₁*a₂} :=
  subset.trans support_sum $
    bUnion_mono $ fun a₁ _ => subset.trans support_sum $ bUnion_mono $ fun a₂ _ => support_single_subset

@[simp]
theorem single_mul_single [Mul G] {a₁ a₂ : G} {b₁ b₂ : k} :
    ((single a₁ b₁ : MonoidAlgebra k G)*single a₂ b₂) = single (a₁*a₂) (b₁*b₂) :=
  (sum_single_index
        (by
          simp only [zero_mul, single_zero, sum_zero])).trans
    (sum_single_index
      (by
        rw [mul_zero, single_zero]))

@[simp]
theorem single_pow [Monoidₓ G] {a : G} {b : k} : ∀ n : ℕ, (single a b : MonoidAlgebra k G) ^ n = single (a ^ n) (b ^ n)
  | 0 => by
    simp only [pow_zeroₓ]
    rfl
  | n+1 => by
    simp only [pow_succₓ, single_pow n, single_mul_single]

section

/--  Like `finsupp.map_domain_add`, but for the convolutive multiplication we define in this file -/
theorem map_domain_mul {α : Type _} {β : Type _} {α₂ : Type _} [Semiringₓ β] [Mul α] [Mul α₂] {x y : MonoidAlgebra β α}
    (f : MulHom α α₂) :
    (map_domain f (x*y : MonoidAlgebra β α) : MonoidAlgebra β α₂) =
      (map_domain f x*map_domain f y : MonoidAlgebra β α₂) :=
  by
  simp_rw [mul_def, map_domain_sum, map_domain_single, f.map_mul]
  rw [Finsupp.sum_map_domain_index]
  ·
    congr
    ext a b
    rw [Finsupp.sum_map_domain_index]
    ·
      simp
    ·
      simp [mul_addₓ]
  ·
    simp
  ·
    simp [add_mulₓ]

variable (k G)

/--  The embedding of a magma into its magma algebra. -/
@[simps]
def of_magma [Mul G] : MulHom G (MonoidAlgebra k G) :=
  { toFun := fun a => single a 1,
    map_mul' := fun a b => by
      simp only [mul_def, mul_oneₓ, sum_single_index, single_eq_zero, mul_zero] }

/--  The embedding of a unital magma into its magma algebra. -/
@[simps]
def of [MulOneClass G] : G →* MonoidAlgebra k G :=
  { of_magma k G with toFun := fun a => single a 1, map_one' := rfl }

end

theorem of_injective [MulOneClass G] [Nontrivial k] : Function.Injective (of k G) := fun a b h => by
  simpa using (single_eq_single_iff _ _ _ _).mp h

theorem mul_single_apply_aux [Mul G] (f : MonoidAlgebra k G) {r : k} {x y z : G} (H : ∀ a, (a*x) = z ↔ a = y) :
    (f*single x r) z = f y*r :=
  have A : ∀ a₁ b₁, ((single x r).Sum fun a₂ b₂ => ite ((a₁*a₂) = z) (b₁*b₂) 0) = ite ((a₁*x) = z) (b₁*r) 0 :=
    fun a₁ b₁ =>
    sum_single_index $ by
      simp
  calc (f*single x r) z = Sum f fun a b => if a = y then b*r else 0 := by
    simp only [mul_apply, A, H]
    congr
    funext
    split_ifs <;> rfl
    _ = if y ∈ f.support then f y*r else 0 := f.support.sum_ite_eq' _ _
    _ = f y*r := by
    split_ifs with h <;> simp at h <;> simp [h]
    

theorem mul_single_one_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) : (f*single 1 r) x = f x*r :=
  f.mul_single_apply_aux $ fun a => by
    rw [mul_oneₓ]

theorem support_mul_single [RightCancelSemigroup G] (f : MonoidAlgebra k G) (r : k) (hr : ∀ y, (y*r) = 0 ↔ y = 0)
    (x : G) : (f*single x r).Support = f.support.map (mulRightEmbedding x) := by
  ext y
  simp only [mem_support_iff, mem_map, exists_prop, mul_right_embedding_apply]
  by_cases' H : ∃ a, (a*x) = y
  ·
    rcases H with ⟨a, rfl⟩
    rw [mul_single_apply_aux f fun _ => mul_left_injₓ x]
    simp [hr]
  ·
    push_neg  at H
    simp [mul_apply, H]

theorem single_mul_apply_aux [Mul G] (f : MonoidAlgebra k G) {r : k} {x y z : G} (H : ∀ a, (x*a) = y ↔ a = z) :
    (single x r*f) y = r*f z :=
  have : (f.sum fun a b => ite ((x*a) = y) (0*b) 0) = 0 := by
    simp
  calc (single x r*f) y = Sum f fun a b => ite ((x*a) = y) (r*b) 0 := (mul_apply _ _ _).trans $ sum_single_index this
    _ = f.sum fun a b => ite (a = z) (r*b) 0 := by
    simp only [H]
    congr with g s
    split_ifs <;> rfl
    _ = if z ∈ f.support then r*f z else 0 := f.support.sum_ite_eq' _ _
    _ = _ := by
    split_ifs with h <;> simp at h <;> simp [h]
    

theorem single_one_mul_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) : (single 1 r*f) x = r*f x :=
  f.single_mul_apply_aux $ fun a => by
    rw [one_mulₓ]

theorem support_single_mul [LeftCancelSemigroup G] (f : MonoidAlgebra k G) (r : k) (hr : ∀ y, (r*y) = 0 ↔ y = 0)
    (x : G) : (single x r*f).Support = f.support.map (mulLeftEmbedding x) := by
  ext y
  simp only [mem_support_iff, mem_map, exists_prop, mul_left_embedding_apply]
  by_cases' H : ∃ a, (x*a) = y
  ·
    rcases H with ⟨a, rfl⟩
    rw [single_mul_apply_aux f fun _ => mul_right_injₓ x]
    simp [hr]
  ·
    push_neg  at H
    simp [mul_apply, H]

theorem lift_nc_smul [MulOneClass G] {R : Type _} [Semiringₓ R] (f : k →+* R) (g : G →* R) (c : k)
    (φ : MonoidAlgebra k G) : lift_nc (f : k →+ R) g (c • φ) = f c*lift_nc (f : k →+ R) g φ := by
  suffices :
    (lift_nc (↑f) g).comp (smulAddHom k (MonoidAlgebra k G) c) = (AddMonoidHom.mulLeft (f c)).comp (lift_nc (↑f) g)
  exact AddMonoidHom.congr_fun this φ
  ext a b
  simp [mul_assocₓ]

end MiscTheorems

/-! #### Non-unital, non-associative algebra structure -/


section NonUnitalNonAssocAlgebra

variable {R : Type _} (k) [Semiringₓ R] [Semiringₓ k] [DistribMulAction R k] [Mul G]

instance is_scalar_tower_self [IsScalarTower R k k] : IsScalarTower R (MonoidAlgebra k G) (MonoidAlgebra k G) :=
  ⟨fun t a b => by
    ext m
    simp only [mul_apply, Finsupp.smul_sum, smul_ite, smul_mul_assoc, sum_smul_index', zero_mul, if_t_t,
      implies_true_iff, eq_self_iff_true, sum_zero, coe_smul, smul_eq_mul, Pi.smul_apply, smul_zero]⟩

/--  Note that if `k` is a `comm_semiring` then we have `smul_comm_class k k k` and so we can take
`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they
also commute with the algebra multiplication. -/
instance smul_comm_class_self [SmulCommClass R k k] : SmulCommClass R (MonoidAlgebra k G) (MonoidAlgebra k G) :=
  ⟨fun t a b => by
    ext m
    simp only [mul_apply, Finsupp.sum, Finset.smul_sum, smul_ite, mul_smul_comm, sum_smul_index', implies_true_iff,
      eq_self_iff_true, coe_smul, ite_eq_right_iff, smul_eq_mul, Pi.smul_apply, mul_zero, smul_zero]⟩

instance smul_comm_class_symm_self [SmulCommClass k R k] : SmulCommClass (MonoidAlgebra k G) R (MonoidAlgebra k G) :=
  ⟨fun t a b => by
    have := SmulCommClass.symm k R k
    rw [← smul_comm]⟩

variable {A : Type u₃} [NonUnitalNonAssocSemiring A]

/--  A non_unital `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem non_unital_alg_hom_ext [DistribMulAction k A] {φ₁ φ₂ : NonUnitalAlgHom k (MonoidAlgebra k G) A}
    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  NonUnitalAlgHom.to_distrib_mul_action_hom_injective $
    Finsupp.distrib_mul_action_hom_ext' $ fun a => DistribMulActionHom.ext_ring (h a)

/--  See note [partially-applied ext lemmas]. -/
@[ext]
theorem non_unital_alg_hom_ext' [DistribMulAction k A] {φ₁ φ₂ : NonUnitalAlgHom k (MonoidAlgebra k G) A}
    (h : φ₁.to_mul_hom.comp (of_magma k G) = φ₂.to_mul_hom.comp (of_magma k G)) : φ₁ = φ₂ :=
  non_unital_alg_hom_ext k $ MulHom.congr_fun h

/--  The functor `G ↦ monoid_algebra k G`, from the category of magmas to the category of non-unital,
non-associative algebras over `k` is adjoint to the forgetful functor in the other direction. -/
@[simps]
def lift_magma [Module k A] [IsScalarTower k A A] [SmulCommClass k A A] :
    MulHom G A ≃ NonUnitalAlgHom k (MonoidAlgebra k G) A :=
  { toFun := fun f =>
      { lift_add_hom fun x => (smulAddHom k A).flip (f x) with toFun := fun a => a.sum fun m t => t • f m,
        map_smul' := fun t' a => by
          rw [Finsupp.smul_sum, sum_smul_index']
          ·
            simp_rw [smul_assoc]
          ·
            intro m
            exact zero_smul k (f m),
        map_mul' := fun a₁ a₂ => by
          let g : G → k → A := fun m t => t • f m
          have h₁ : ∀ m, g m 0 = 0 := by
            intros
            exact zero_smul k (f m)
          have h₂ : ∀ m t₁ t₂ : k, g m (t₁+t₂) = g m t₁+g m t₂ := by
            intros
            rw [← add_smul]
          simp_rw [Finsupp.mul_sum, Finsupp.sum_mul, smul_mul_smul, ← f.map_mul, mul_def, sum_comm a₂ a₁,
            sum_sum_index h₁ h₂, sum_single_index (h₁ _)] },
    invFun := fun F => F.to_mul_hom.comp (of_magma k G),
    left_inv := fun f => by
      ext m
      simp only [NonUnitalAlgHom.coe_mk, of_magma_apply, NonUnitalAlgHom.to_mul_hom_eq_coe, sum_single_index,
        Function.comp_app, one_smul, zero_smul, MulHom.coe_comp, NonUnitalAlgHom.coe_to_mul_hom],
    right_inv := fun F => by
      ext m
      simp only [NonUnitalAlgHom.coe_mk, of_magma_apply, NonUnitalAlgHom.to_mul_hom_eq_coe, sum_single_index,
        Function.comp_app, one_smul, zero_smul, MulHom.coe_comp, NonUnitalAlgHom.coe_to_mul_hom] }

end NonUnitalNonAssocAlgebra

/-! #### Algebra structure -/


section Algebra

attribute [local reducible] MonoidAlgebra

theorem single_one_comm [CommSemiringₓ k] [MulOneClass G] (r : k) (f : MonoidAlgebra k G) :
    (single 1 r*f) = f*single 1 r := by
  ext
  rw [single_one_mul_apply, mul_single_one_apply, mul_commₓ]

/--  `finsupp.single 1` as a `ring_hom` -/
@[simps]
def single_one_ring_hom [Semiringₓ k] [Monoidₓ G] : k →+* MonoidAlgebra k G :=
  { Finsupp.singleAddHom 1 with map_one' := rfl,
    map_mul' := fun x y => by
      rw [single_add_hom, single_mul_single, one_mulₓ] }

/--  If two ring homomorphisms from `monoid_algebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal. -/
theorem ring_hom_ext {R} [Semiringₓ k] [Monoidₓ G] [Semiringₓ R] {f g : MonoidAlgebra k G →+* R}
    (h₁ : ∀ b, f (single 1 b) = g (single 1 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) : f = g :=
  RingHom.coe_add_monoid_hom_injective $
    add_hom_ext $ fun a b => by
      rw [← one_mulₓ a, ← mul_oneₓ b, ← single_mul_single, f.coe_add_monoid_hom, g.coe_add_monoid_hom, f.map_mul,
        g.map_mul, h₁, h_of]

/--  If two ring homomorphisms from `monoid_algebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem ring_hom_ext' {R} [Semiringₓ k] [Monoidₓ G] [Semiringₓ R] {f g : MonoidAlgebra k G →+* R}
    (h₁ : f.comp single_one_ring_hom = g.comp single_one_ring_hom)
    (h_of : (f : MonoidAlgebra k G →* R).comp (of k G) = (g : MonoidAlgebra k G →* R).comp (of k G)) : f = g :=
  ring_hom_ext (RingHom.congr_fun h₁) (MonoidHom.congr_fun h_of)

/-- 
The instance `algebra k (monoid_algebra A G)` whenever we have `algebra k A`.

In particular this provides the instance `algebra k (monoid_algebra k G)`.
-/
instance {A : Type _} [CommSemiringₓ k] [Semiringₓ A] [Algebra k A] [Monoidₓ G] : Algebra k (MonoidAlgebra A G) :=
  { single_one_ring_hom.comp (algebraMap k A) with
    smul_def' := fun r a => by
      ext
      simp [single_one_mul_apply, Algebra.smul_def, Pi.smul_apply],
    commutes' := fun r f => by
      ext
      simp [single_one_mul_apply, mul_single_one_apply, Algebra.commutes] }

/--  `finsupp.single 1` as a `alg_hom` -/
@[simps]
def single_one_alg_hom {A : Type _} [CommSemiringₓ k] [Semiringₓ A] [Algebra k A] [Monoidₓ G] :
    A →ₐ[k] MonoidAlgebra A G :=
  { single_one_ring_hom with
    commutes' := fun r => by
      ext
      simp
      rfl }

@[simp]
theorem coe_algebra_map {A : Type _} [CommSemiringₓ k] [Semiringₓ A] [Algebra k A] [Monoidₓ G] :
    ⇑algebraMap k (MonoidAlgebra A G) = single 1 ∘ algebraMap k A :=
  rfl

theorem single_eq_algebra_map_mul_of [CommSemiringₓ k] [Monoidₓ G] (a : G) (b : k) :
    single a b = algebraMap k (MonoidAlgebra k G) b*of k G a := by
  simp

theorem single_algebra_map_eq_algebra_map_mul_of {A : Type _} [CommSemiringₓ k] [Semiringₓ A] [Algebra k A] [Monoidₓ G]
    (a : G) (b : k) : single a (algebraMap k A b) = algebraMap k (MonoidAlgebra A G) b*of A G a := by
  simp

theorem induction_on [Semiringₓ k] [Monoidₓ G] {p : MonoidAlgebra k G → Prop} (f : MonoidAlgebra k G)
    (hM : ∀ g, p (of k G g)) (hadd : ∀ f g : MonoidAlgebra k G, p f → p g → p (f+g))
    (hsmul : ∀ r : k f, p f → p (r • f)) : p f := by
  refine' Finsupp.induction_linear f _ (fun f g hf hg => hadd f g hf hg) fun g r => _
  ·
    simpa using hsmul 0 (of k G 1) (hM 1)
  ·
    convert hsmul r (of k G g) (hM g)
    simp only [mul_oneₓ, smul_single', of_apply]

end Algebra

section lift

variable {k G} [CommSemiringₓ k] [Monoidₓ G]

variable {A : Type u₃} [Semiringₓ A] [Algebra k A] {B : Type _} [Semiringₓ B] [Algebra k B]

/--  `lift_nc_ring_hom` as a `alg_hom`, for when `f` is an `alg_hom` -/
def lift_nc_alg_hom (f : A →ₐ[k] B) (g : G →* B) (h_comm : ∀ x y, Commute (f x) (g y)) : MonoidAlgebra A G →ₐ[k] B :=
  { lift_nc_ring_hom (f : A →+* B) g h_comm with toFun := lift_nc_ring_hom (f : A →+* B) g h_comm,
    commutes' := by
      simp [lift_nc_ring_hom] }

/--  A `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem alg_hom_ext ⦃φ₁ φ₂ : MonoidAlgebra k G →ₐ[k] A⦄ (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  AlgHom.to_linear_map_injective $ Finsupp.lhom_ext' $ fun a => LinearMap.ext_ring (h a)

/--  See note [partially-applied ext lemmas]. -/
@[ext]
theorem alg_hom_ext' ⦃φ₁ φ₂ : MonoidAlgebra k G →ₐ[k] A⦄
    (h : (φ₁ : MonoidAlgebra k G →* A).comp (of k G) = (φ₂ : MonoidAlgebra k G →* A).comp (of k G)) : φ₁ = φ₂ :=
  alg_hom_ext $ MonoidHom.congr_fun h

variable (k G A)

/--  Any monoid homomorphism `G →* A` can be lifted to an algebra homomorphism
`monoid_algebra k G →ₐ[k] A`. -/
def lift : (G →* A) ≃ (MonoidAlgebra k G →ₐ[k] A) :=
  { invFun := fun f => (f : MonoidAlgebra k G →* A).comp (of k G),
    toFun := fun F => lift_nc_alg_hom (Algebra.ofId k A) F $ fun _ _ => Algebra.commutes _ _,
    left_inv := fun f => by
      ext
      simp [lift_nc_alg_hom, lift_nc_ring_hom],
    right_inv := fun F => by
      ext
      simp [lift_nc_alg_hom, lift_nc_ring_hom] }

variable {k G A}

theorem lift_apply' (F : G →* A) (f : MonoidAlgebra k G) : lift k G A F f = f.sum fun a b => algebraMap k A b*F a :=
  rfl

theorem lift_apply (F : G →* A) (f : MonoidAlgebra k G) : lift k G A F f = f.sum fun a b => b • F a := by
  simp only [lift_apply', Algebra.smul_def]

theorem lift_def (F : G →* A) : ⇑lift k G A F = lift_nc ((algebraMap k A : k →+* A) : k →+ A) F :=
  rfl

@[simp]
theorem lift_symm_apply (F : MonoidAlgebra k G →ₐ[k] A) (x : G) : (lift k G A).symm F x = F (single x 1) :=
  rfl

theorem lift_of (F : G →* A) x : lift k G A F (of k G x) = F x := by
  rw [of_apply, ← lift_symm_apply, Equivₓ.symm_apply_apply]

@[simp]
theorem lift_single (F : G →* A) a b : lift k G A F (single a b) = b • F a := by
  rw [lift_def, lift_nc_single, Algebra.smul_def, RingHom.coe_add_monoid_hom]

theorem lift_unique' (F : MonoidAlgebra k G →ₐ[k] A) : F = lift k G A ((F : MonoidAlgebra k G →* A).comp (of k G)) :=
  ((lift k G A).apply_symm_apply F).symm

-- failed to format: format: uncaught backtrack exception
/--
    Decomposition of a `k`-algebra homomorphism from `monoid_algebra k G` by
    its values on `F (single a 1)`. -/
  theorem
    lift_unique
    ( F : MonoidAlgebra k G →ₐ[ k ] A ) ( f : MonoidAlgebra k G ) : F f = f.sum fun a b => b • F ( single a 1 )
    := by conv_lhs => rw [ lift_unique' F ] simp [ lift_apply ]

end lift

section

attribute [local reducible] MonoidAlgebra

variable (k)

/--  When `V` is a `k[G]`-module, multiplication by a group element `g` is a `k`-linear map. -/
def group_smul.linear_map [Monoidₓ G] [CommSemiringₓ k] (V : Type u₃) [AddCommMonoidₓ V] [Module k V]
    [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V] (g : G) : V →ₗ[k] V :=
  { toFun := fun v => (single g (1 : k) • v : V), map_add' := fun x y => smul_add (single g (1 : k)) x y,
    map_smul' := fun c x => smul_algebra_smul_comm _ _ _ }

@[simp]
theorem group_smul.linear_map_apply [Monoidₓ G] [CommSemiringₓ k] (V : Type u₃) [AddCommMonoidₓ V] [Module k V]
    [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V] (g : G) (v : V) :
    (group_smul.linear_map k V g) v = (single g (1 : k) • v : V) :=
  rfl

section

variable {k}

variable [Monoidₓ G] [CommSemiringₓ k] {V W : Type u₃} [AddCommMonoidₓ V] [Module k V] [Module (MonoidAlgebra k G) V]
  [IsScalarTower k (MonoidAlgebra k G) V] [AddCommMonoidₓ W] [Module k W] [Module (MonoidAlgebra k G) W]
  [IsScalarTower k (MonoidAlgebra k G) W] (f : V →ₗ[k] W)
  (h : ∀ g : G v : V, f (single g (1 : k) • v : V) = (single g (1 : k) • f v : W))

include h

/--  Build a `k[G]`-linear map from a `k`-linear map and evidence that it is `G`-equivariant. -/
def equivariant_of_linear_of_comm : V →ₗ[MonoidAlgebra k G] W :=
  { toFun := f,
    map_add' := fun v v' => by
      simp ,
    map_smul' := fun c v => by
      apply Finsupp.induction c
      ·
        simp
      ·
        intro g r c' nm nz w
        dsimp  at *
        simp only [add_smul, f.map_add, w, add_left_injₓ, single_eq_algebra_map_mul_of, ← smul_smul]
        erw [algebra_map_smul (MonoidAlgebra k G) r, algebra_map_smul (MonoidAlgebra k G) r, f.map_smul, h g v,
          of_apply]
        all_goals
          infer_instance }

@[simp]
theorem equivariant_of_linear_of_comm_apply (v : V) : (equivariant_of_linear_of_comm f h) v = f v :=
  rfl

end

end

section

universe ui

variable {ι : Type ui}

attribute [local reducible] MonoidAlgebra

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers [] [] [] [] [] [])
 (Command.theorem
  "theorem"
  (Command.declId `prod_single [])
  (Command.declSig
   [(Term.instBinder "[" [] (Term.app `CommSemiringₓ [`k]) "]")
    (Term.instBinder "[" [] (Term.app `CommMonoidₓ [`G]) "]")
    (Term.implicitBinder "{" [`s] [":" (Term.app `Finset [`ι])] "}")
    (Term.implicitBinder "{" [`a] [":" (Term.arrow `ι "→" `G)] "}")
    (Term.implicitBinder "{" [`b] [":" (Term.arrow `ι "→" `k)] "}")]
   (Term.typeSpec
    ":"
    («term_=_»
     (Algebra.BigOperators.Basic.«term∏_in_,_»
      "∏"
      (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
      " in "
      `s
      ", "
      (Term.app `single [(Term.app `a [`i]) (Term.app `b [`i])]))
     "="
     (Term.app
      `single
      [(Algebra.BigOperators.Basic.«term∏_in_,_»
        "∏"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
        " in "
        `s
        ", "
        (Term.app `a [`i]))
       (Algebra.BigOperators.Basic.«term∏_in_,_»
        "∏"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
        " in "
        `s
        ", "
        (Term.app `b [`i]))]))))
  (Command.declValSimple
   ":="
   («term_$__»
    (Term.app `Finset.induction_on [`s `rfl])
    "$"
    (Term.fun
     "fun"
     (Term.basicFun
      [(Term.simpleBinder [`a `s `has `ih] [])]
      "=>"
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(group
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
              ","
              (Tactic.rwRule [] `ih)
              ","
              (Tactic.rwRule [] `single_mul_single)
              ","
              (Tactic.rwRule [] (Term.app `prod_insert [`has]))
              ","
              (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
             "]")
            [])
           [])]))))))
   [])
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_$__»
   (Term.app `Finset.induction_on [`s `rfl])
   "$"
   (Term.fun
    "fun"
    (Term.basicFun
     [(Term.simpleBinder [`a `s `has `ih] [])]
     "=>"
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(group
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
             ","
             (Tactic.rwRule [] `ih)
             ","
             (Tactic.rwRule [] `single_mul_single)
             ","
             (Tactic.rwRule [] (Term.app `prod_insert [`has]))
             ","
             (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
            "]")
           [])
          [])]))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_$__»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`a `s `has `ih] [])]
    "=>"
    (Term.byTactic
     "by"
     (Tactic.tacticSeq
      (Tactic.tacticSeq1Indented
       [(group
         (Tactic.rwSeq
          "rw"
          []
          (Tactic.rwRuleSeq
           "["
           [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
            ","
            (Tactic.rwRule [] `ih)
            ","
            (Tactic.rwRule [] `single_mul_single)
            ","
            (Tactic.rwRule [] (Term.app `prod_insert [`has]))
            ","
            (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
           "]")
          [])
         [])])))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.byTactic
   "by"
   (Tactic.tacticSeq
    (Tactic.tacticSeq1Indented
     [(group
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
          ","
          (Tactic.rwRule [] `ih)
          ","
          (Tactic.rwRule [] `single_mul_single)
          ","
          (Tactic.rwRule [] (Term.app `prod_insert [`has]))
          ","
          (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
         "]")
        [])
       [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.byTactic.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq', expected 'Lean.Parser.Tactic.tacticSeq.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeq1Indented.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.rwSeq
   "rw"
   []
   (Tactic.rwRuleSeq
    "["
    [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
     ","
     (Tactic.rwRule [] `ih)
     ","
     (Tactic.rwRule [] `single_mul_single)
     ","
     (Tactic.rwRule [] (Term.app `prod_insert [`has]))
     ","
     (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
    "]")
   [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwSeq', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `prod_insert [`has])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `has
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `prod_insert
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `prod_insert [`has])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `has
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `prod_insert
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `single_mul_single
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `ih
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `prod_insert [`has])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `has
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `prod_insert
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.simpleBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 10 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))
  (Term.app `Finset.induction_on [`s `rfl])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `rfl
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `s
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `Finset.induction_on
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 10, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 10, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declSig', expected 'Lean.Parser.Command.declSig.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeSpec', expected 'Lean.Parser.Term.typeSpec.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
  («term_=_»
   (Algebra.BigOperators.Basic.«term∏_in_,_»
    "∏"
    (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
    " in "
    `s
    ", "
    (Term.app `single [(Term.app `a [`i]) (Term.app `b [`i])]))
   "="
   (Term.app
    `single
    [(Algebra.BigOperators.Basic.«term∏_in_,_»
      "∏"
      (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
      " in "
      `s
      ", "
      (Term.app `a [`i]))
     (Algebra.BigOperators.Basic.«term∏_in_,_»
      "∏"
      (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
      " in "
      `s
      ", "
      (Term.app `b [`i]))]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app
   `single
   [(Algebra.BigOperators.Basic.«term∏_in_,_»
     "∏"
     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
     " in "
     `s
     ", "
     (Term.app `a [`i]))
    (Algebra.BigOperators.Basic.«term∏_in_,_»
     "∏"
     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
     " in "
     `s
     ", "
     (Term.app `b [`i]))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Algebra.BigOperators.Basic.«term∏_in_,_»
   "∏"
   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
   " in "
   `s
   ", "
   (Term.app `b [`i]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `b [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `i
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `b
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `s
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.explicitBinders', expected 'Mathlib.ExtendedBinder.extBinders'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  prod_single
  [ CommSemiringₓ k ] [ CommMonoidₓ G ] { s : Finset ι } { a : ι → G } { b : ι → k }
    : ∏ i in s , single a i b i = single ∏ i in s , a i ∏ i in s , b i
  :=
    Finset.induction_on s rfl
      $
      fun a s has ih => by rw [ prod_insert has , ih , single_mul_single , prod_insert has , prod_insert has ]

end

section

variable [Semiringₓ k] [Groupₓ G]

attribute [local reducible] MonoidAlgebra

@[simp]
theorem mul_single_apply (f : MonoidAlgebra k G) (r : k) (x y : G) : (f*single x r) y = f (y*x⁻¹)*r :=
  f.mul_single_apply_aux $ fun a => eq_mul_inv_iff_mul_eq.symm

@[simp]
theorem single_mul_apply (r : k) (x : G) (f : MonoidAlgebra k G) (y : G) : (single x r*f) y = r*f (x⁻¹*y) :=
  f.single_mul_apply_aux $ fun z => eq_inv_mul_iff_mul_eq.symm

theorem mul_apply_left (f g : MonoidAlgebra k G) (x : G) : (f*g) x = (f.sum $ fun a b => b*g (a⁻¹*x)) :=
  calc (f*g) x = Sum f fun a b => (single a b*g) x := by
    rw [← Finsupp.sum_apply, ← Finsupp.sum_mul, f.sum_single]
    _ = _ := by
    simp only [single_mul_apply, Finsupp.sum]
    

theorem mul_apply_right (f g : MonoidAlgebra k G) (x : G) : (f*g) x = (g.sum $ fun a b => f (x*a⁻¹)*b) :=
  calc (f*g) x = Sum g fun a b => (f*single a b) x := by
    rw [← Finsupp.sum_apply, ← Finsupp.mul_sum, g.sum_single]
    _ = _ := by
    simp only [mul_single_apply, Finsupp.sum]
    

end

section Span

variable [Semiringₓ k] [MulOneClass G]

/--  An element of `monoid_algebra R M` is in the subalgebra generated by its support. -/
theorem mem_span_support (f : MonoidAlgebra k G) : f ∈ Submodule.span k (of k G '' (f.support : Set G)) := by
  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

end Span

section Opposite

open Finsupp MulOpposite

variable [Semiringₓ k]

/--  The opposite of an `monoid_algebra R I` equivalent as a ring to
the `monoid_algebra Rᵐᵒᵖ Iᵐᵒᵖ` over the opposite ring, taking elements to their opposite. -/
@[simps (config := { simpRhs := tt })]
protected noncomputable def op_ring_equiv [Monoidₓ G] : MonoidAlgebra k Gᵐᵒᵖ ≃+* MonoidAlgebra (kᵐᵒᵖ) (Gᵐᵒᵖ) :=
  { op_add_equiv.symm.trans $
      (Finsupp.mapRange.addEquiv (op_add_equiv : k ≃+ kᵐᵒᵖ)).trans $ Finsupp.domCongr op_equiv with
    map_mul' := by
      dsimp only [AddEquiv.to_fun_eq_coe, ← AddEquiv.coe_to_add_monoid_hom]
      rw [AddMonoidHom.map_mul_iff]
      ext i₁ r₁ i₂ r₂ : 6
      simp }

@[simp]
theorem op_ring_equiv_single [Monoidₓ G] (r : k) (x : G) :
    MonoidAlgebra.opRingEquiv (op (single x r)) = single (op x) (op r) := by
  simp

@[simp]
theorem op_ring_equiv_symm_single [Monoidₓ G] (r : kᵐᵒᵖ) (x : Gᵐᵒᵖ) :
    MonoidAlgebra.opRingEquiv.symm (single x r) = op (single x.unop r.unop) := by
  simp

end Opposite

end MonoidAlgebra

/-! ### Additive monoids -/


section

variable [Semiringₓ k]

-- ././Mathport/Syntax/Translate/Basic.lean:833:9: unsupported derive handler inhabited
-- ././Mathport/Syntax/Translate/Basic.lean:833:9: unsupported derive handler add_comm_monoid
/-- 
The monoid algebra over a semiring `k` generated by the additive monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with the convolution product.
-/
def AddMonoidAlgebra :=
  G →₀ k deriving [anonymous], [anonymous]

instance : CoeFun (AddMonoidAlgebra k G) fun _ => G → k :=
  Finsupp.hasCoeToFun

end

namespace AddMonoidAlgebra

variable {k G}

section Mul

variable [Semiringₓ k] [Add G]

/--  The product of `f g : add_monoid_algebra k G` is the finitely supported function
  whose value at `a` is the sum of `f x * g y` over all pairs `x, y`
  such that `x + y = a`. (Think of the product of multivariate
  polynomials where `α` is the additive monoid of monomial exponents.) -/
instance : Mul (AddMonoidAlgebra k G) :=
  ⟨fun f g => f.sum $ fun a₁ b₁ => g.sum $ fun a₂ b₂ => single (a₁+a₂) (b₁*b₂)⟩

theorem mul_def {f g : AddMonoidAlgebra k G} :
    (f*g) = (f.sum $ fun a₁ b₁ => g.sum $ fun a₂ b₂ => single (a₁+a₂) (b₁*b₂)) :=
  rfl

instance : NonUnitalNonAssocSemiring (AddMonoidAlgebra k G) :=
  { Finsupp.addCommMonoid with zero := 0, mul := ·*·, add := ·+·,
    left_distrib := fun f g h => by
      simp only [mul_def, sum_add_index, mul_addₓ, mul_zero, single_zero, single_add, eq_self_iff_true, forall_true_iff,
        forall_3_true_iff, sum_add],
    right_distrib := fun f g h => by
      simp only [mul_def, sum_add_index, add_mulₓ, mul_zero, zero_mul, single_zero, single_add, eq_self_iff_true,
        forall_true_iff, forall_3_true_iff, sum_zero, sum_add],
    zero_mul := fun f => by
      simp only [mul_def, sum_zero_index],
    mul_zero := fun f => by
      simp only [mul_def, sum_zero_index, sum_zero],
    nsmul := fun n f => n • f,
    nsmul_zero' := by
      intros
      ext
      simp [-nsmul_eq_mul, add_smul],
    nsmul_succ' := by
      intros
      ext
      simp [-nsmul_eq_mul, Nat.succ_eq_one_add, add_smul] }

end Mul

section HasOne

variable [Semiringₓ k] [HasZero G]

/--  The unit of the multiplication is `single 1 1`, i.e. the function
  that is `1` at `0` and zero elsewhere. -/
instance : HasOne (AddMonoidAlgebra k G) :=
  ⟨single 0 1⟩

theorem one_def : (1 : AddMonoidAlgebra k G) = single 0 1 :=
  rfl

end HasOne

section Semigroupₓ

variable [Semiringₓ k] [AddSemigroupₓ G]

instance : NonUnitalSemiring (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.nonUnitalNonAssocSemiring with zero := 0, mul := ·*·, add := ·+·,
    mul_assoc := fun f g h => by
      simp only [mul_def, sum_sum_index, sum_zero_index, sum_add_index, sum_single_index, single_zero, single_add,
        eq_self_iff_true, forall_true_iff, forall_3_true_iff, add_mulₓ, mul_addₓ, add_assocₓ, mul_assocₓ, zero_mul,
        mul_zero, sum_zero, sum_add] }

end Semigroupₓ

section MulOneClass

variable [Semiringₓ k] [AddZeroClass G]

instance : NonAssocSemiring (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.nonUnitalNonAssocSemiring with one := 1, mul := ·*·, zero := 0, add := ·+·,
    one_mul := fun f => by
      simp only [mul_def, one_def, sum_single_index, zero_mul, single_zero, sum_zero, zero_addₓ, one_mulₓ, sum_single],
    mul_one := fun f => by
      simp only [mul_def, one_def, sum_single_index, mul_zero, single_zero, sum_zero, add_zeroₓ, mul_oneₓ, sum_single] }

variable {R : Type _} [Semiringₓ R]

/--  A non-commutative version of `add_monoid_algebra.lift`: given a additive homomorphism `f : k →+
R` and a multiplicative monoid homomorphism `g : multiplicative G →* R`, returns the additive
homomorphism from `add_monoid_algebra k G` such that `lift_nc f g (single a b) = f b * g a`. If `f`
is a ring homomorphism and the range of either `f` or `g` is in center of `R`, then the result is a
ring homomorphism.  If `R` is a `k`-algebra and `f = algebra_map k R`, then the result is an algebra
homomorphism called `add_monoid_algebra.lift`. -/
def lift_nc (f : k →+ R) (g : Multiplicative G →* R) : AddMonoidAlgebra k G →+ R :=
  lift_add_hom fun x : G => (AddMonoidHom.mulRight (g $ Multiplicative.ofAdd x)).comp f

@[simp]
theorem lift_nc_single (f : k →+ R) (g : Multiplicative G →* R) (a : G) (b : k) :
    lift_nc f g (single a b) = f b*g (Multiplicative.ofAdd a) :=
  lift_add_hom_apply_single _ _ _

@[simp]
theorem lift_nc_one (f : k →+* R) (g : Multiplicative G →* R) : lift_nc (f : k →+ R) g 1 = 1 :=
  @MonoidAlgebra.lift_nc_one k (Multiplicative G) _ _ _ _ f g

theorem lift_nc_mul (f : k →+* R) (g : Multiplicative G →* R) (a b : AddMonoidAlgebra k G)
    (h_comm : ∀ {x y}, y ∈ a.support → Commute (f (b x)) (g $ Multiplicative.ofAdd y)) :
    lift_nc (f : k →+ R) g (a*b) = lift_nc (f : k →+ R) g a*lift_nc (f : k →+ R) g b :=
  @MonoidAlgebra.lift_nc_mul k (Multiplicative G) _ _ _ _ f g a b @h_comm

end MulOneClass

/-! #### Semiring structure -/


section Semiringₓ

instance {R : Type _} [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] : HasScalar R (AddMonoidAlgebra k G) :=
  Finsupp.hasScalar

variable [Semiringₓ k] [AddMonoidₓ G]

instance : Semiringₓ (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.nonUnitalSemiring, AddMonoidAlgebra.nonAssocSemiring with one := 1, mul := ·*·, zero := 0,
    add := ·+· }

variable {R : Type _} [Semiringₓ R]

/--  `lift_nc` as a `ring_hom`, for when `f` and `g` commute -/
def lift_nc_ring_hom (f : k →+* R) (g : Multiplicative G →* R) (h_comm : ∀ x y, Commute (f x) (g y)) :
    AddMonoidAlgebra k G →+* R :=
  { lift_nc (f : k →+ R) g with toFun := lift_nc (f : k →+ R) g, map_one' := lift_nc_one _ _,
    map_mul' := fun a b => lift_nc_mul _ _ _ _ $ fun _ _ _ => h_comm _ _ }

end Semiringₓ

instance [CommSemiringₓ k] [AddCommMonoidₓ G] : CommSemiringₓ (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.semiring with mul_comm := @mul_commₓ (MonoidAlgebra k $ Multiplicative G) _ }

instance [Semiringₓ k] [Nontrivial k] [Nonempty G] : Nontrivial (AddMonoidAlgebra k G) :=
  Finsupp.nontrivial

/-! #### Derived instances -/


section DerivedInstances

instance [Semiringₓ k] [Subsingleton k] : Unique (AddMonoidAlgebra k G) :=
  Finsupp.uniqueOfRight

instance [Ringₓ k] : AddGroupₓ (AddMonoidAlgebra k G) :=
  Finsupp.addGroup

instance [Ringₓ k] [AddMonoidₓ G] : Ringₓ (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.semiring with neg := Neg.neg, add_left_neg := add_left_negₓ, sub := Sub.sub,
    sub_eq_add_neg := Finsupp.addGroup.sub_eq_add_neg }

instance [CommRingₓ k] [AddCommMonoidₓ G] : CommRingₓ (AddMonoidAlgebra k G) :=
  { AddMonoidAlgebra.ring with mul_comm := mul_commₓ }

variable {R S : Type _}

instance [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] : DistribMulAction R (AddMonoidAlgebra k G) :=
  Finsupp.distribMulAction G k

instance [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] [HasFaithfulScalar R k] [Nonempty G] :
    HasFaithfulScalar R (AddMonoidAlgebra k G) :=
  Finsupp.has_faithful_scalar

instance [Semiringₓ R] [Semiringₓ k] [Module R k] : Module R (AddMonoidAlgebra k G) :=
  Finsupp.module G k

instance [Monoidₓ R] [Monoidₓ S] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction S k] [HasScalar R S]
    [IsScalarTower R S k] : IsScalarTower R S (AddMonoidAlgebra k G) :=
  Finsupp.is_scalar_tower G k

instance [Monoidₓ R] [Monoidₓ S] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction S k] [SmulCommClass R S k] :
    SmulCommClass R S (AddMonoidAlgebra k G) :=
  Finsupp.smul_comm_class G k

instance [Monoidₓ R] [Semiringₓ k] [DistribMulAction R k] [DistribMulAction (Rᵐᵒᵖ) k] [IsCentralScalar R k] :
    IsCentralScalar R (AddMonoidAlgebra k G) :=
  Finsupp.is_central_scalar G k

/-! It is hard to state the equivalent of `distrib_mul_action G (add_monoid_algebra k G)`
because we've never discussed actions of additive groups. -/


end DerivedInstances

section MiscTheorems

variable [Semiringₓ k]

theorem mul_apply [Add G] (f g : AddMonoidAlgebra k G) (x : G) :
    (f*g) x = (f.sum $ fun a₁ b₁ => g.sum $ fun a₂ b₂ => if (a₁+a₂) = x then b₁*b₂ else 0) :=
  @MonoidAlgebra.mul_apply k (Multiplicative G) _ _ _ _ _

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers [] [] [] [] [] [])
 (Command.theorem
  "theorem"
  (Command.declId `mul_apply_antidiagonal [])
  (Command.declSig
   [(Term.instBinder "[" [] (Term.app `Add [`G]) "]")
    (Term.explicitBinder "(" [`f `g] [":" (Term.app `AddMonoidAlgebra [`k `G])] [] ")")
    (Term.explicitBinder "(" [`x] [":" `G] [] ")")
    (Term.explicitBinder "(" [`s] [":" (Term.app `Finset [(«term_×_» `G "×" `G)])] [] ")")
    (Term.explicitBinder
     "("
     [`hs]
     [":"
      (Term.forall
       "∀"
       [(Term.implicitBinder "{" [`p] [":" («term_×_» `G "×" `G)] "}")]
       ","
       («term_↔_»
        (Init.Core.«term_∈_» `p " ∈ " `s)
        "↔"
        («term_=_»
         (Init.Logic.«term_+_» (Term.proj `p "." (fieldIdx "1")) "+" (Term.proj `p "." (fieldIdx "2")))
         "="
         `x)))]
     []
     ")")]
   (Term.typeSpec
    ":"
    («term_=_»
     (Term.app (Finset.Data.Finset.Fold.«term_*_» `f "*" `g) [`x])
     "="
     (Algebra.BigOperators.Basic.«term∑_in_,_»
      "∑"
      (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
      " in "
      `s
      ", "
      (Finset.Data.Finset.Fold.«term_*_»
       (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
       "*"
       (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))))
  (Command.declValSimple
   ":="
   (Term.app
    (Term.explicit "@" `MonoidAlgebra.mul_apply_antidiagonal)
    [`k
     (Term.app `Multiplicative [`G])
     (Term.hole "_")
     (Term.hole "_")
     (Term.hole "_")
     (Term.hole "_")
     (Term.hole "_")
     `s
     (Term.explicit "@" `hs)])
   [])
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app
   (Term.explicit "@" `MonoidAlgebra.mul_apply_antidiagonal)
   [`k
    (Term.app `Multiplicative [`G])
    (Term.hole "_")
    (Term.hole "_")
    (Term.hole "_")
    (Term.hole "_")
    (Term.hole "_")
    `s
    (Term.explicit "@" `hs)])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.explicit "@" `hs)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'Lean.Parser.Term.explicit.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `hs
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 1024, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  `s
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  (Term.app `Multiplicative [`G])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `G
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `Multiplicative
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" [(Term.app `Multiplicative [`G]) []] ")")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `k
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Term.explicit "@" `MonoidAlgebra.mul_apply_antidiagonal)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.explicit', expected 'Lean.Parser.Term.explicit.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `MonoidAlgebra.mul_apply_antidiagonal
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (some 1024, term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declSig', expected 'Lean.Parser.Command.declSig.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeSpec', expected 'Lean.Parser.Term.typeSpec.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
  («term_=_»
   (Term.app (Finset.Data.Finset.Fold.«term_*_» `f "*" `g) [`x])
   "="
   (Algebra.BigOperators.Basic.«term∑_in_,_»
    "∑"
    (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
    " in "
    `s
    ", "
    (Finset.Data.Finset.Fold.«term_*_»
     (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
     "*"
     (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Algebra.BigOperators.Basic.«term∑_in_,_»
   "∑"
   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] []))
   " in "
   `s
   ", "
   (Finset.Data.Finset.Fold.«term_*_»
    (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
    "*"
    (Term.app `g [(Term.proj `p "." (fieldIdx "2"))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∑_in_,_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Finset.Data.Finset.Fold.«term_*_»
   (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
   "*"
   (Term.app `g [(Term.proj `p "." (fieldIdx "2"))]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Finset.Data.Finset.Fold.«term_*_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `g [(Term.proj `p "." (fieldIdx "2"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.proj `p "." (fieldIdx "2"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `p
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `g
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Term.app `f [(Term.proj `p "." (fieldIdx "1"))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.proj `p "." (fieldIdx "1"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `p
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `f
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `s
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.explicitBinders', expected 'Mathlib.ExtendedBinder.extBinders'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  mul_apply_antidiagonal
  [ Add G ]
      ( f g : AddMonoidAlgebra k G )
      ( x : G )
      ( s : Finset G × G )
      ( hs : ∀ { p : G × G } , p ∈ s ↔ p . 1 + p . 2 = x )
    : f * g x = ∑ p in s , f p . 1 * g p . 2
  := @ MonoidAlgebra.mul_apply_antidiagonal k Multiplicative G _ _ _ _ _ s @ hs

theorem support_mul [Add G] (a b : AddMonoidAlgebra k G) :
    (a*b).Support ⊆ a.support.bUnion fun a₁ => b.support.bUnion $ fun a₂ => {a₁+a₂} :=
  @MonoidAlgebra.support_mul k (Multiplicative G) _ _ _ _

theorem single_mul_single [Add G] {a₁ a₂ : G} {b₁ b₂ : k} :
    (single a₁ b₁*single a₂ b₂ : AddMonoidAlgebra k G) = single (a₁+a₂) (b₁*b₂) :=
  @MonoidAlgebra.single_mul_single k (Multiplicative G) _ _ _ _ _ _

theorem single_pow [AddMonoidₓ G] {a : G} {b : k} :
    ∀ n : ℕ, (single a b ^ n : AddMonoidAlgebra k G) = single (n • a) (b ^ n)
  | 0 => by
    simp only [pow_zeroₓ, zero_nsmul]
    rfl
  | n+1 => by
    rw [pow_succₓ, pow_succₓ, single_pow n, single_mul_single, add_commₓ, add_nsmul, one_nsmul]

/--  Like `finsupp.map_domain_add`, but for the convolutive multiplication we define in this file -/
theorem map_domain_mul {α : Type _} {β : Type _} {α₂ : Type _} [Semiringₓ β] [Add α] [Add α₂]
    {x y : AddMonoidAlgebra β α} (f : AddHom α α₂) :
    (map_domain f (x*y : AddMonoidAlgebra β α) : AddMonoidAlgebra β α₂) =
      (map_domain f x*map_domain f y : AddMonoidAlgebra β α₂) :=
  by
  simp_rw [mul_def, map_domain_sum, map_domain_single, f.map_add]
  rw [Finsupp.sum_map_domain_index]
  ·
    congr
    ext a b
    rw [Finsupp.sum_map_domain_index]
    ·
      simp
    ·
      simp [mul_addₓ]
  ·
    simp
  ·
    simp [add_mulₓ]

section

variable (k G)

/--  The embedding of an additive magma into its additive magma algebra. -/
@[simps]
def of_magma [Add G] : MulHom (Multiplicative G) (AddMonoidAlgebra k G) :=
  { toFun := fun a => single a 1,
    map_mul' := fun a b => by
      simpa only [mul_def, mul_oneₓ, sum_single_index, single_eq_zero, mul_zero] }

/--  Embedding of a magma with zero into its magma algebra. -/
def of [AddZeroClass G] : Multiplicative G →* AddMonoidAlgebra k G :=
  { of_magma k G with toFun := fun a => single a 1, map_one' := rfl }

/--  Embedding of a magma with zero `G`, into its magma algebra, having `G` as source. -/
def of' : G → AddMonoidAlgebra k G := fun a => single a 1

end

@[simp]
theorem of_apply [AddZeroClass G] (a : Multiplicative G) : of k G a = single a.to_add 1 :=
  rfl

@[simp]
theorem of'_apply (a : G) : of' k G a = single a 1 :=
  rfl

theorem of'_eq_of [AddZeroClass G] (a : G) : of' k G a = of k G a :=
  rfl

theorem of_injective [Nontrivial k] [AddZeroClass G] : Function.Injective (of k G) := fun a b h => by
  simpa using (single_eq_single_iff _ _ _ _).mp h

theorem mul_single_apply_aux [Add G] (f : AddMonoidAlgebra k G) (r : k) (x y z : G) (H : ∀ a, (a+x) = z ↔ a = y) :
    (f*single x r) z = f y*r :=
  @MonoidAlgebra.mul_single_apply_aux k (Multiplicative G) _ _ _ _ _ _ _ H

theorem mul_single_zero_apply [AddZeroClass G] (f : AddMonoidAlgebra k G) (r : k) (x : G) : (f*single 0 r) x = f x*r :=
  f.mul_single_apply_aux r _ _ _ $ fun a => by
    rw [add_zeroₓ]

theorem single_mul_apply_aux [Add G] (f : AddMonoidAlgebra k G) (r : k) (x y z : G) (H : ∀ a, (x+a) = y ↔ a = z) :
    (single x r*f : AddMonoidAlgebra k G) y = r*f z :=
  @MonoidAlgebra.single_mul_apply_aux k (Multiplicative G) _ _ _ _ _ _ _ H

theorem single_zero_mul_apply [AddZeroClass G] (f : AddMonoidAlgebra k G) (r : k) (x : G) :
    (single 0 r*f : AddMonoidAlgebra k G) x = r*f x :=
  f.single_mul_apply_aux r _ _ _ $ fun a => by
    rw [zero_addₓ]

theorem mul_single_apply [AddGroupₓ G] (f : AddMonoidAlgebra k G) (r : k) (x y : G) : (f*single x r) y = f (y - x)*r :=
  (sub_eq_add_neg y x).symm ▸ @MonoidAlgebra.mul_single_apply k (Multiplicative G) _ _ _ _ _ _

theorem single_mul_apply [AddGroupₓ G] (r : k) (x : G) (f : AddMonoidAlgebra k G) (y : G) :
    (single x r*f : AddMonoidAlgebra k G) y = r*f ((-x)+y) :=
  @MonoidAlgebra.single_mul_apply k (Multiplicative G) _ _ _ _ _ _

theorem support_mul_single [AddRightCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, (y*r) = 0 ↔ y = 0)
    (x : G) : (f*single x r : AddMonoidAlgebra k G).Support = f.support.map (addRightEmbedding x) :=
  @MonoidAlgebra.support_mul_single k (Multiplicative G) _ _ _ _ hr _

theorem support_single_mul [AddLeftCancelSemigroup G] (f : AddMonoidAlgebra k G) (r : k) (hr : ∀ y, (r*y) = 0 ↔ y = 0)
    (x : G) : (single x r*f : AddMonoidAlgebra k G).Support = f.support.map (addLeftEmbedding x) :=
  @MonoidAlgebra.support_single_mul k (Multiplicative G) _ _ _ _ hr _

theorem lift_nc_smul {R : Type _} [AddZeroClass G] [Semiringₓ R] (f : k →+* R) (g : Multiplicative G →* R) (c : k)
    (φ : MonoidAlgebra k G) : lift_nc (f : k →+ R) g (c • φ) = f c*lift_nc (f : k →+ R) g φ :=
  @MonoidAlgebra.lift_nc_smul k (Multiplicative G) _ _ _ _ f g c φ

variable {k G}

theorem induction_on [AddMonoidₓ G] {p : AddMonoidAlgebra k G → Prop} (f : AddMonoidAlgebra k G)
    (hM : ∀ g, p (of k G (Multiplicative.ofAdd g))) (hadd : ∀ f g : AddMonoidAlgebra k G, p f → p g → p (f+g))
    (hsmul : ∀ r : k f, p f → p (r • f)) : p f := by
  refine' Finsupp.induction_linear f _ (fun f g hf hg => hadd f g hf hg) fun g r => _
  ·
    simpa using hsmul 0 (of k G (Multiplicative.ofAdd 0)) (hM 0)
  ·
    convert hsmul r (of k G (Multiplicative.ofAdd g)) (hM g)
    simp only [mul_oneₓ, to_add_of_add, smul_single', of_apply]

end MiscTheorems

section Span

variable [Semiringₓ k]

/--  An element of `add_monoid_algebra R M` is in the submodule generated by its support. -/
theorem mem_span_support [AddZeroClass G] (f : AddMonoidAlgebra k G) :
    f ∈ Submodule.span k (of k G '' (f.support : Set G)) := by
  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

/--  An element of `add_monoid_algebra R M` is in the subalgebra generated by its support, using
unbundled inclusion. -/
theorem mem_span_support' (f : AddMonoidAlgebra k G) : f ∈ Submodule.span k (of' k G '' (f.support : Set G)) := by
  rw [of', ← Finsupp.supported_eq_span_single, Finsupp.mem_supported]

end Span

end AddMonoidAlgebra

/-!
#### Conversions between `add_monoid_algebra` and `monoid_algebra`

We have not defined `add_monoid_algebra k G = monoid_algebra k (multiplicative G)`
because historically this caused problems;
since the changes that have made `nsmul` definitional, this would be possible,
but for now we just contruct the ring isomorphisms using `ring_equiv.refl _`.
-/


/--  The equivalence between `add_monoid_algebra` and `monoid_algebra` in terms of
`multiplicative` -/
protected def AddMonoidAlgebra.toMultiplicative [Semiringₓ k] [Add G] :
    AddMonoidAlgebra k G ≃+* MonoidAlgebra k (Multiplicative G) :=
  { Finsupp.domCongr Multiplicative.ofAdd with toFun := equiv_map_domain Multiplicative.ofAdd,
    map_mul' := fun x y => by
      repeat'
        rw [equiv_map_domain_eq_map_domain]
      dsimp [Multiplicative.ofAdd]
      convert MonoidAlgebra.map_domain_mul (MulHom.id (Multiplicative G)) }

/--  The equivalence between `monoid_algebra` and `add_monoid_algebra` in terms of `additive` -/
protected def MonoidAlgebra.toAdditive [Semiringₓ k] [Mul G] : MonoidAlgebra k G ≃+* AddMonoidAlgebra k (Additive G) :=
  { Finsupp.domCongr Additive.ofMul with toFun := equiv_map_domain Additive.ofMul,
    map_mul' := fun x y => by
      repeat'
        rw [equiv_map_domain_eq_map_domain]
      dsimp [Additive.ofMul]
      convert MonoidAlgebra.map_domain_mul (MulHom.id G) }

namespace AddMonoidAlgebra

variable {k G}

/-! #### Non-unital, non-associative algebra structure -/


section NonUnitalNonAssocAlgebra

variable {R : Type _} (k) [Semiringₓ R] [Semiringₓ k] [DistribMulAction R k] [Add G]

instance is_scalar_tower_self [IsScalarTower R k k] : IsScalarTower R (AddMonoidAlgebra k G) (AddMonoidAlgebra k G) :=
  @MonoidAlgebra.is_scalar_tower_self k (Multiplicative G) R _ _ _ _ _

/--  Note that if `k` is a `comm_semiring` then we have `smul_comm_class k k k` and so we can take
`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they
also commute with the algebra multiplication. -/
instance smul_comm_class_self [SmulCommClass R k k] : SmulCommClass R (AddMonoidAlgebra k G) (AddMonoidAlgebra k G) :=
  @MonoidAlgebra.smul_comm_class_self k (Multiplicative G) R _ _ _ _ _

instance smul_comm_class_symm_self [SmulCommClass k R k] :
    SmulCommClass (AddMonoidAlgebra k G) R (AddMonoidAlgebra k G) :=
  @MonoidAlgebra.smul_comm_class_symm_self k (Multiplicative G) R _ _ _ _ _

variable {A : Type u₃} [NonUnitalNonAssocSemiring A]

/--  A non_unital `k`-algebra homomorphism from `add_monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem non_unital_alg_hom_ext [DistribMulAction k A] {φ₁ φ₂ : NonUnitalAlgHom k (AddMonoidAlgebra k G) A}
    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  @MonoidAlgebra.non_unital_alg_hom_ext k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h

/--  See note [partially-applied ext lemmas]. -/
@[ext]
theorem non_unital_alg_hom_ext' [DistribMulAction k A] {φ₁ φ₂ : NonUnitalAlgHom k (AddMonoidAlgebra k G) A}
    (h : φ₁.to_mul_hom.comp (of_magma k G) = φ₂.to_mul_hom.comp (of_magma k G)) : φ₁ = φ₂ :=
  @MonoidAlgebra.non_unital_alg_hom_ext' k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h

/--  The functor `G ↦ add_monoid_algebra k G`, from the category of magmas to the category of
non-unital, non-associative algebras over `k` is adjoint to the forgetful functor in the other
direction. -/
@[simps]
def lift_magma [Module k A] [IsScalarTower k A A] [SmulCommClass k A A] :
    MulHom (Multiplicative G) A ≃ NonUnitalAlgHom k (AddMonoidAlgebra k G) A :=
  { (MonoidAlgebra.liftMagma k : MulHom (Multiplicative G) A ≃ NonUnitalAlgHom k _ A) with
    toFun := fun f =>
      { (MonoidAlgebra.liftMagma k f : _) with toFun := fun a => Sum a fun m t => t • f (Multiplicative.ofAdd m) },
    invFun := fun F => F.to_mul_hom.comp (of_magma k G) }

end NonUnitalNonAssocAlgebra

/-! #### Algebra structure -/


section Algebra

variable {R : Type _}

attribute [local reducible] AddMonoidAlgebra

/--  `finsupp.single 0` as a `ring_hom` -/
@[simps]
def single_zero_ring_hom [Semiringₓ k] [AddMonoidₓ G] : k →+* AddMonoidAlgebra k G :=
  { Finsupp.singleAddHom 0 with map_one' := rfl,
    map_mul' := fun x y => by
      rw [single_add_hom, single_mul_single, zero_addₓ] }

/--  If two ring homomorphisms from `add_monoid_algebra k G` are equal on all `single a 1`
and `single 0 b`, then they are equal. -/
theorem ring_hom_ext {R} [Semiringₓ k] [AddMonoidₓ G] [Semiringₓ R] {f g : AddMonoidAlgebra k G →+* R}
    (h₀ : ∀ b, f (single 0 b) = g (single 0 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) : f = g :=
  @MonoidAlgebra.ring_hom_ext k (Multiplicative G) R _ _ _ _ _ h₀ h_of

/--  If two ring homomorphisms from `add_monoid_algebra k G` are equal on all `single a 1`
and `single 0 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem ring_hom_ext' {R} [Semiringₓ k] [AddMonoidₓ G] [Semiringₓ R] {f g : AddMonoidAlgebra k G →+* R}
    (h₁ : f.comp single_zero_ring_hom = g.comp single_zero_ring_hom)
    (h_of : (f : AddMonoidAlgebra k G →* R).comp (of k G) = (g : AddMonoidAlgebra k G →* R).comp (of k G)) : f = g :=
  ring_hom_ext (RingHom.congr_fun h₁) (MonoidHom.congr_fun h_of)

section Opposite

open Finsupp MulOpposite

variable [Semiringₓ k]

/--  The opposite of an `add_monoid_algebra R I` is ring equivalent to
the `add_monoid_algebra Rᵐᵒᵖ I` over the opposite ring, taking elements to their opposite. -/
@[simps (config := { simpRhs := tt })]
protected noncomputable def op_ring_equiv [AddCommMonoidₓ G] : AddMonoidAlgebra k Gᵐᵒᵖ ≃+* AddMonoidAlgebra (kᵐᵒᵖ) G :=
  { MulOpposite.opAddEquiv.symm.trans (Finsupp.mapRange.addEquiv (MulOpposite.opAddEquiv : k ≃+ kᵐᵒᵖ)) with
    map_mul' := by
      dsimp only [AddEquiv.to_fun_eq_coe, ← AddEquiv.coe_to_add_monoid_hom]
      rw [AddMonoidHom.map_mul_iff]
      ext i r i' r' : 6
      dsimp
      simp only [map_range_single, single_mul_single, ← op_mul, add_commₓ] }

@[simp]
theorem op_ring_equiv_single [AddCommMonoidₓ G] (r : k) (x : G) :
    AddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r) := by
  simp

@[simp]
theorem op_ring_equiv_symm_single [AddCommMonoidₓ G] (r : kᵐᵒᵖ) (x : Gᵐᵒᵖ) :
    AddMonoidAlgebra.opRingEquiv.symm (single x r) = op (single x r.unop) := by
  simp

end Opposite

/-- 
The instance `algebra R (add_monoid_algebra k G)` whenever we have `algebra R k`.

In particular this provides the instance `algebra k (add_monoid_algebra k G)`.
-/
instance [CommSemiringₓ R] [Semiringₓ k] [Algebra R k] [AddMonoidₓ G] : Algebra R (AddMonoidAlgebra k G) :=
  { single_zero_ring_hom.comp (algebraMap R k) with
    smul_def' := fun r a => by
      ext
      simp [single_zero_mul_apply, Algebra.smul_def, Pi.smul_apply],
    commutes' := fun r f => by
      ext
      simp [single_zero_mul_apply, mul_single_zero_apply, Algebra.commutes] }

/--  `finsupp.single 0` as a `alg_hom` -/
@[simps]
def single_zero_alg_hom [CommSemiringₓ R] [Semiringₓ k] [Algebra R k] [AddMonoidₓ G] : k →ₐ[R] AddMonoidAlgebra k G :=
  { single_zero_ring_hom with
    commutes' := fun r => by
      ext
      simp
      rfl }

@[simp]
theorem coe_algebra_map [CommSemiringₓ R] [Semiringₓ k] [Algebra R k] [AddMonoidₓ G] :
    (algebraMap R (AddMonoidAlgebra k G) : R → AddMonoidAlgebra k G) = single 0 ∘ algebraMap R k :=
  rfl

end Algebra

section lift

variable {k G} [CommSemiringₓ k] [AddMonoidₓ G]

variable {A : Type u₃} [Semiringₓ A] [Algebra k A] {B : Type _} [Semiringₓ B] [Algebra k B]

/--  `lift_nc_ring_hom` as a `alg_hom`, for when `f` is an `alg_hom` -/
def lift_nc_alg_hom (f : A →ₐ[k] B) (g : Multiplicative G →* B) (h_comm : ∀ x y, Commute (f x) (g y)) :
    AddMonoidAlgebra A G →ₐ[k] B :=
  { lift_nc_ring_hom (f : A →+* B) g h_comm with toFun := lift_nc_ring_hom (f : A →+* B) g h_comm,
    commutes' := by
      simp [lift_nc_ring_hom] }

/--  A `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem alg_hom_ext ⦃φ₁ φ₂ : AddMonoidAlgebra k G →ₐ[k] A⦄ (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  @MonoidAlgebra.alg_hom_ext k (Multiplicative G) _ _ _ _ _ _ _ h

/--  See note [partially-applied ext lemmas]. -/
@[ext]
theorem alg_hom_ext' ⦃φ₁ φ₂ : AddMonoidAlgebra k G →ₐ[k] A⦄
    (h : (φ₁ : AddMonoidAlgebra k G →* A).comp (of k G) = (φ₂ : AddMonoidAlgebra k G →* A).comp (of k G)) : φ₁ = φ₂ :=
  alg_hom_ext $ MonoidHom.congr_fun h

variable (k G A)

/--  Any monoid homomorphism `G →* A` can be lifted to an algebra homomorphism
`monoid_algebra k G →ₐ[k] A`. -/
def lift : (Multiplicative G →* A) ≃ (AddMonoidAlgebra k G →ₐ[k] A) :=
  { @MonoidAlgebra.lift k (Multiplicative G) _ _ A _ _ with
    invFun := fun f => (f : AddMonoidAlgebra k G →* A).comp (of k G),
    toFun := fun F =>
      { @MonoidAlgebra.lift k (Multiplicative G) _ _ A _ _ F with
        toFun := lift_nc_alg_hom (Algebra.ofId k A) F $ fun _ _ => Algebra.commutes _ _ } }

variable {k G A}

theorem lift_apply' (F : Multiplicative G →* A) (f : MonoidAlgebra k G) :
    lift k G A F f = f.sum fun a b => algebraMap k A b*F (Multiplicative.ofAdd a) :=
  rfl

theorem lift_apply (F : Multiplicative G →* A) (f : MonoidAlgebra k G) :
    lift k G A F f = f.sum fun a b => b • F (Multiplicative.ofAdd a) := by
  simp only [lift_apply', Algebra.smul_def]

theorem lift_def (F : Multiplicative G →* A) : ⇑lift k G A F = lift_nc ((algebraMap k A : k →+* A) : k →+ A) F :=
  rfl

@[simp]
theorem lift_symm_apply (F : AddMonoidAlgebra k G →ₐ[k] A) (x : Multiplicative G) :
    (lift k G A).symm F x = F (single x.to_add 1) :=
  rfl

theorem lift_of (F : Multiplicative G →* A) (x : Multiplicative G) : lift k G A F (of k G x) = F x := by
  rw [of_apply, ← lift_symm_apply, Equivₓ.symm_apply_apply]

@[simp]
theorem lift_single (F : Multiplicative G →* A) a b : lift k G A F (single a b) = b • F (Multiplicative.ofAdd a) := by
  rw [lift_def, lift_nc_single, Algebra.smul_def, RingHom.coe_add_monoid_hom]

theorem lift_unique' (F : AddMonoidAlgebra k G →ₐ[k] A) :
    F = lift k G A ((F : AddMonoidAlgebra k G →* A).comp (of k G)) :=
  ((lift k G A).apply_symm_apply F).symm

-- failed to format: format: uncaught backtrack exception
/--
    Decomposition of a `k`-algebra homomorphism from `monoid_algebra k G` by
    its values on `F (single a 1)`. -/
  theorem
    lift_unique
    ( F : AddMonoidAlgebra k G →ₐ[ k ] A ) ( f : MonoidAlgebra k G ) : F f = f.sum fun a b => b • F ( single a 1 )
    := by conv_lhs => rw [ lift_unique' F ] simp [ lift_apply ]

theorem alg_hom_ext_iff {φ₁ φ₂ : AddMonoidAlgebra k G →ₐ[k] A} :
    (∀ x, φ₁ (Finsupp.single x 1) = φ₂ (Finsupp.single x 1)) ↔ φ₁ = φ₂ :=
  ⟨fun h => alg_hom_ext h, by
    rintro rfl _ <;> rfl⟩

end lift

section

attribute [local reducible] AddMonoidAlgebra

universe ui

variable {ι : Type ui}

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers [] [] [] [] [] [])
 (Command.theorem
  "theorem"
  (Command.declId `prod_single [])
  (Command.declSig
   [(Term.instBinder "[" [] (Term.app `CommSemiringₓ [`k]) "]")
    (Term.instBinder "[" [] (Term.app `AddCommMonoidₓ [`G]) "]")
    (Term.implicitBinder "{" [`s] [":" (Term.app `Finset [`ι])] "}")
    (Term.implicitBinder "{" [`a] [":" (Term.arrow `ι "→" `G)] "}")
    (Term.implicitBinder "{" [`b] [":" (Term.arrow `ι "→" `k)] "}")]
   (Term.typeSpec
    ":"
    («term_=_»
     (Algebra.BigOperators.Basic.«term∏_in_,_»
      "∏"
      (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
      " in "
      `s
      ", "
      (Term.app `single [(Term.app `a [`i]) (Term.app `b [`i])]))
     "="
     (Term.app
      `single
      [(Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
        " in "
        `s
        ", "
        (Term.app `a [`i]))
       (Algebra.BigOperators.Basic.«term∏_in_,_»
        "∏"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
        " in "
        `s
        ", "
        (Term.app `b [`i]))]))))
  (Command.declValSimple
   ":="
   («term_$__»
    (Term.app `Finset.induction_on [`s `rfl])
    "$"
    (Term.fun
     "fun"
     (Term.basicFun
      [(Term.simpleBinder [`a `s `has `ih] [])]
      "=>"
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(group
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
              ","
              (Tactic.rwRule [] `ih)
              ","
              (Tactic.rwRule [] `single_mul_single)
              ","
              (Tactic.rwRule [] (Term.app `sum_insert [`has]))
              ","
              (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
             "]")
            [])
           [])]))))))
   [])
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_$__»
   (Term.app `Finset.induction_on [`s `rfl])
   "$"
   (Term.fun
    "fun"
    (Term.basicFun
     [(Term.simpleBinder [`a `s `has `ih] [])]
     "=>"
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(group
          (Tactic.rwSeq
           "rw"
           []
           (Tactic.rwRuleSeq
            "["
            [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
             ","
             (Tactic.rwRule [] `ih)
             ","
             (Tactic.rwRule [] `single_mul_single)
             ","
             (Tactic.rwRule [] (Term.app `sum_insert [`has]))
             ","
             (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
            "]")
           [])
          [])]))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_$__»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`a `s `has `ih] [])]
    "=>"
    (Term.byTactic
     "by"
     (Tactic.tacticSeq
      (Tactic.tacticSeq1Indented
       [(group
         (Tactic.rwSeq
          "rw"
          []
          (Tactic.rwRuleSeq
           "["
           [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
            ","
            (Tactic.rwRule [] `ih)
            ","
            (Tactic.rwRule [] `single_mul_single)
            ","
            (Tactic.rwRule [] (Term.app `sum_insert [`has]))
            ","
            (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
           "]")
          [])
         [])])))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.byTactic
   "by"
   (Tactic.tacticSeq
    (Tactic.tacticSeq1Indented
     [(group
       (Tactic.rwSeq
        "rw"
        []
        (Tactic.rwRuleSeq
         "["
         [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
          ","
          (Tactic.rwRule [] `ih)
          ","
          (Tactic.rwRule [] `single_mul_single)
          ","
          (Tactic.rwRule [] (Term.app `sum_insert [`has]))
          ","
          (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
         "]")
        [])
       [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.byTactic.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq', expected 'Lean.Parser.Tactic.tacticSeq.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeq1Indented.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.rwSeq
   "rw"
   []
   (Tactic.rwRuleSeq
    "["
    [(Tactic.rwRule [] (Term.app `prod_insert [`has]))
     ","
     (Tactic.rwRule [] `ih)
     ","
     (Tactic.rwRule [] `single_mul_single)
     ","
     (Tactic.rwRule [] (Term.app `sum_insert [`has]))
     ","
     (Tactic.rwRule [] (Term.app `prod_insert [`has]))]
    "]")
   [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwSeq', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `prod_insert [`has])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `has
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `prod_insert
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `sum_insert [`has])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `has
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `sum_insert
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `single_mul_single
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `ih
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `prod_insert [`has])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `has
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `prod_insert
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.simpleBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 10 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 10, term))
  (Term.app `Finset.induction_on [`s `rfl])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `rfl
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `s
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `Finset.induction_on
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 10, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 10, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declSig', expected 'Lean.Parser.Command.declSig.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.typeSpec', expected 'Lean.Parser.Term.typeSpec.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, [anonymous]))
  («term_=_»
   (Algebra.BigOperators.Basic.«term∏_in_,_»
    "∏"
    (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
    " in "
    `s
    ", "
    (Term.app `single [(Term.app `a [`i]) (Term.app `b [`i])]))
   "="
   (Term.app
    `single
    [(Algebra.BigOperators.Basic.«term∑_in_,_»
      "∑"
      (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
      " in "
      `s
      ", "
      (Term.app `a [`i]))
     (Algebra.BigOperators.Basic.«term∏_in_,_»
      "∏"
      (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
      " in "
      `s
      ", "
      (Term.app `b [`i]))]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app
   `single
   [(Algebra.BigOperators.Basic.«term∑_in_,_»
     "∑"
     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
     " in "
     `s
     ", "
     (Term.app `a [`i]))
    (Algebra.BigOperators.Basic.«term∏_in_,_»
     "∏"
     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
     " in "
     `s
     ", "
     (Term.app `b [`i]))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Algebra.BigOperators.Basic.«term∏_in_,_»
   "∏"
   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `i)] []))
   " in "
   `s
   ", "
   (Term.app `b [`i]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∏_in_,_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `b [`i])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `i
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `b
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `s
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.explicitBinders', expected 'Mathlib.ExtendedBinder.extBinders'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  prod_single
  [ CommSemiringₓ k ] [ AddCommMonoidₓ G ] { s : Finset ι } { a : ι → G } { b : ι → k }
    : ∏ i in s , single a i b i = single ∑ i in s , a i ∏ i in s , b i
  :=
    Finset.induction_on s rfl
      $
      fun a s has ih => by rw [ prod_insert has , ih , single_mul_single , sum_insert has , prod_insert has ]

end

end AddMonoidAlgebra

variable {R : Type _} [CommSemiringₓ R] (k G)

/--  The algebra equivalence between `add_monoid_algebra` and `monoid_algebra` in terms of
`multiplicative`. -/
def AddMonoidAlgebra.toMultiplicativeAlgEquiv [Semiringₓ k] [Algebra R k] [AddMonoidₓ G] :
    AddMonoidAlgebra k G ≃ₐ[R] MonoidAlgebra k (Multiplicative G) :=
  { AddMonoidAlgebra.toMultiplicative k G with
    commutes' := fun r => by
      simp [AddMonoidAlgebra.toMultiplicative] }

/--  The algebra equivalence between `monoid_algebra` and `add_monoid_algebra` in terms of
`additive`. -/
def MonoidAlgebra.toAdditiveAlgEquiv [Semiringₓ k] [Algebra R k] [Monoidₓ G] :
    MonoidAlgebra k G ≃ₐ[R] AddMonoidAlgebra k (Additive G) :=
  { MonoidAlgebra.toAdditive k G with
    commutes' := fun r => by
      simp [MonoidAlgebra.toAdditive] }

