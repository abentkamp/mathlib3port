/-
Copyright (c) 2020 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel
-/
import Mathbin.Analysis.Calculus.IteratedDeriv
import Mathbin.Analysis.InnerProductSpace.EuclideanDist

/-!
# Infinitely smooth bump function

In this file we construct several infinitely smooth functions with properties that an analytic
function cannot have:

* `exp_neg_inv_glue` is equal to zero for `x ‚â§ 0` and is strictly positive otherwise; it is given by
  `x ‚Ü¶ exp (-1/x)` for `x > 0`;

* `real.smooth_transition` is equal to zero for `x ‚â§ 0` and is equal to one for `x ‚â• 1`; it is given
  by `exp_neg_inv_glue x / (exp_neg_inv_glue x + exp_neg_inv_glue (1 - x))`;

* `f : times_cont_diff_bump_of_inner c`, where `c` is a point in an inner product space, is
  a bundled smooth function such that

  - `f` is equal to `1` in `metric.closed_ball c f.r`;
  - `support f = metric.ball c f.R`;
  - `0 ‚â§ f x ‚â§ 1` for all `x`.

  The structure `times_cont_diff_bump_of_inner` contains the data required to construct the
  function: real numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available
  through `coe_fn`.

* `f : times_cont_diff_bump c`, where `c` is a point in a finite dimensional real vector space, is a
  bundled smooth function such that

  - `f` is equal to `1` in `euclidean.closed_ball c f.r`;
  - `support f = euclidean.ball c f.R`;
  - `0 ‚â§ f x ‚â§ 1` for all `x`.

  The structure `times_cont_diff_bump` contains the data required to construct the function: real
  numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available through `coe_fn`.
-/


noncomputable section

open_locale Classical TopologicalSpace

open Polynomial Real Filter Set Function

/-- `exp_neg_inv_glue` is the real function given by `x ‚Ü¶ exp (-1/x)` for `x > 0` and `0`
for `x ‚â§ 0`. It is a basic building block to construct smooth partitions of unity. Its main property
is that it vanishes for `x ‚â§ 0`, it is positive for `x > 0`, and the junction between the two
behaviors is flat enough to retain smoothness. The fact that this function is `C^‚àû` is proved in
`exp_neg_inv_glue.smooth`. -/
def expNegInvGlue (x : ‚Ñù) : ‚Ñù :=
  if x ‚â§ 0 then 0 else exp (-x‚Åª¬π)

namespace expNegInvGlue

/-- Our goal is to prove that `exp_neg_inv_glue` is `C^‚àû`. For this, we compute its successive
derivatives for `x > 0`. The `n`-th derivative is of the form `P_aux n (x) exp(-1/x) / x^(2 n)`,
where `P_aux n` is computed inductively. -/
noncomputable def pAux : ‚Ñï ‚Üí Polynomial ‚Ñù
  | 0 => 1
  | n + 1 => X ^ 2 * (P_aux n).derivative + (1 - c ‚Üë(2 * n) * X) * P_aux n

/-- Formula for the `n`-th derivative of `exp_neg_inv_glue`, as an auxiliary function `f_aux`. -/
def fAux (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù :=
  if x ‚â§ 0 then 0 else (pAux n).eval x * exp (-x‚Åª¬π) / x ^ (2 * n)

/-- The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition. -/
theorem f_aux_zero_eq : fAux 0 = expNegInvGlue := by
  ext x
  by_cases' h : x ‚â§ 0
  ¬∑ simp [expNegInvGlue, f_aux, h]
    
  ¬∑ simp [h, expNegInvGlue, f_aux, ne_of_gt‚Çì (not_le‚Çì.1 h), P_aux]
    

/-- For positive values, the derivative of the `n`-th auxiliary function `f_aux n`
(given in this statement in unfolded form) is the `n+1`-th auxiliary function, since
the polynomial `P_aux (n+1)` was chosen precisely to ensure this. -/
theorem f_aux_deriv (n : ‚Ñï) (x : ‚Ñù) (hx : x ‚â† 0) :
    HasDerivAt (fun x => (pAux n).eval x * exp (-x‚Åª¬π) / x ^ (2 * n))
      ((pAux (n + 1)).eval x * exp (-x‚Åª¬π) / x ^ (2 * (n + 1))) x :=
  by
  have A : ‚àÄ k : ‚Ñï, 2 * (k + 1) - 1 = 2 * k + 1 := by
    intro k
    rw [tsub_eq_iff_eq_add_of_le]
    ¬∑ ring
      
    ¬∑ simp [mul_add‚Çì]
      
  convert
    (((P_aux n).HasDerivAt x).mul ((has_deriv_at_exp _).comp x (has_deriv_at_inv hx).neg)).div
      (has_deriv_at_pow (2 * n) x) (pow_ne_zero _ hx) using
    1
  field_simp [hx, P_aux]
  -- `ring_exp` can't solve `p ‚à® q` goal generated by `mul_eq_mul_right_iff`
    cases n <;>
    simp [Nat.succ_eq_add_one, A, -mul_eq_mul_right_iff] <;> ring_exp

/-- For positive values, the derivative of the `n`-th auxiliary function `f_aux n`
is the `n+1`-th auxiliary function. -/
theorem f_aux_deriv_pos (n : ‚Ñï) (x : ‚Ñù) (hx : 0 < x) :
    HasDerivAt (fAux n) ((pAux (n + 1)).eval x * exp (-x‚Åª¬π) / x ^ (2 * (n + 1))) x := by
  apply (f_aux_deriv n x (ne_of_gt‚Çì hx)).congr_of_eventually_eq
  filter_upwards [lt_mem_nhds hx] with _ hy
  simp [f_aux, hy.not_le]

/-- To get differentiability at `0` of the auxiliary functions, we need to know that their limit
is `0`, to be able to apply general differentiability extension theorems. This limit is checked in
this lemma. -/
theorem f_aux_limit (n : ‚Ñï) : Tendsto (fun x => (pAux n).eval x * exp (-x‚Åª¬π) / x ^ (2 * n)) (ùìù[>] 0) (ùìù 0) := by
  have A : tendsto (fun x => (P_aux n).eval x) (ùìù[>] 0) (ùìù ((P_aux n).eval 0)) := (P_aux n).ContinuousWithinAt
  have B : tendsto (fun x => exp (-x‚Åª¬π) / x ^ (2 * n)) (ùìù[>] 0) (ùìù 0) := by
    convert (tendsto_pow_mul_exp_neg_at_top_nhds_0 (2 * n)).comp tendsto_inv_zero_at_top
    ext x
    field_simp
  convert A.mul B <;> simp [mul_div_assoc]

/-- Deduce from the limiting behavior at `0` of its derivative and general differentiability
extension theorems that the auxiliary function `f_aux n` is differentiable at `0`,
with derivative `0`. -/
theorem f_aux_deriv_zero (n : ‚Ñï) : HasDerivAt (fAux n) 0 0 := by
  -- we check separately differentiability on the left and on the right
  have A : HasDerivWithinAt (f_aux n) (0 : ‚Ñù) (Iic 0) 0 := by
    apply (has_deriv_at_const (0 : ‚Ñù) (0 : ‚Ñù)).HasDerivWithinAt.congr
    ¬∑ intro y hy
      simp at hy
      simp [f_aux, hy]
      
    ¬∑ simp [f_aux, le_refl‚Çì]
      
  have B : HasDerivWithinAt (f_aux n) (0 : ‚Ñù) (Ici 0) 0 := by
    have diff : DifferentiableOn ‚Ñù (f_aux n) (Ioi 0) := fun x hx =>
      (f_aux_deriv_pos n x hx).DifferentiableAt.DifferentiableWithinAt
    -- next line is the nontrivial bit of this proof, appealing to differentiability
    -- extension results.
    apply has_deriv_at_interval_left_endpoint_of_tendsto_deriv diff _ self_mem_nhds_within
    ¬∑ refine' (f_aux_limit (n + 1)).congr' _
      apply mem_of_superset self_mem_nhds_within fun x hx => _
      simp [(f_aux_deriv_pos n x hx).deriv]
      
    ¬∑ have : f_aux n 0 = 0 := by
        simp [f_aux, le_refl‚Çì]
      simp only [ContinuousWithinAt, this]
      refine' (f_aux_limit n).congr' _
      apply mem_of_superset self_mem_nhds_within fun x hx => _
      have : ¬¨x ‚â§ 0 := by
        simpa using hx
      simp [f_aux, this]
      
  simpa using A.union B

/-- At every point, the auxiliary function `f_aux n` has a derivative which is
equal to `f_aux (n+1)`. -/
theorem f_aux_has_deriv_at (n : ‚Ñï) (x : ‚Ñù) : HasDerivAt (fAux n) (fAux (n + 1) x) x := by
  -- check separately the result for `x < 0`, where it is trivial, for `x > 0`, where it is done
  -- in `f_aux_deriv_pos`, and for `x = 0`, done in
  -- `f_aux_deriv_zero`.
  rcases lt_trichotomy‚Çì x 0 with (hx | hx | hx)
  ¬∑ have : f_aux (n + 1) x = 0 := by
      simp [f_aux, le_of_lt‚Çì hx]
    rw [this]
    apply (has_deriv_at_const x (0 : ‚Ñù)).congr_of_eventually_eq
    filter_upwards [gt_mem_nhds hx] with _ hy
    simp [f_aux, hy.le]
    
  ¬∑ have : f_aux (n + 1) 0 = 0 := by
      simp [f_aux, le_refl‚Çì]
    rw [hx, this]
    exact f_aux_deriv_zero n
    
  ¬∑ have : f_aux (n + 1) x = (P_aux (n + 1)).eval x * exp (-x‚Åª¬π) / x ^ (2 * (n + 1)) := by
      simp [f_aux, not_le_of_gt‚Çì hx]
    rw [this]
    exact f_aux_deriv_pos n x hx
    

/-- The successive derivatives of the auxiliary function `f_aux 0` are the
functions `f_aux n`, by induction. -/
theorem f_aux_iterated_deriv (n : ‚Ñï) : iteratedDeriv n (fAux 0) = fAux n := by
  induction' n with n IH
  ¬∑ simp
    
  ¬∑ simp [iterated_deriv_succ, IH]
    ext x
    exact (f_aux_has_deriv_at n x).deriv
    

/-- The function `exp_neg_inv_glue` is smooth. -/
protected theorem times_cont_diff {n} : TimesContDiff ‚Ñù n expNegInvGlue := by
  rw [‚Üê f_aux_zero_eq]
  apply times_cont_diff_of_differentiable_iterated_deriv fun m hm => _
  rw [f_aux_iterated_deriv m]
  exact fun x => (f_aux_has_deriv_at m x).DifferentiableAt

/-- The function `exp_neg_inv_glue` vanishes on `(-‚àû, 0]`. -/
theorem zero_of_nonpos {x : ‚Ñù} (hx : x ‚â§ 0) : expNegInvGlue x = 0 := by
  simp [expNegInvGlue, hx]

/-- The function `exp_neg_inv_glue` is positive on `(0, +‚àû)`. -/
theorem pos_of_pos {x : ‚Ñù} (hx : 0 < x) : 0 < expNegInvGlue x := by
  simp [expNegInvGlue, not_le‚Çì.2 hx, exp_pos]

/-- The function exp_neg_inv_glue` is nonnegative. -/
theorem nonneg (x : ‚Ñù) : 0 ‚â§ expNegInvGlue x := by
  cases le_or_gt‚Çì x 0
  ¬∑ exact ge_of_eq (zero_of_nonpos h)
    
  ¬∑ exact le_of_lt‚Çì (pos_of_pos h)
    

end expNegInvGlue

/-- An infinitely smooth function `f : ‚Ñù ‚Üí ‚Ñù` such that `f x = 0` for `x ‚â§ 0`,
`f x = 1` for `1 ‚â§ x`, and `0 < f x < 1` for `0 < x < 1`. -/
def Real.smoothTransition (x : ‚Ñù) : ‚Ñù :=
  expNegInvGlue x / (expNegInvGlue x + expNegInvGlue (1 - x))

namespace Real

namespace SmoothTransition

variable {x : ‚Ñù}

open expNegInvGlue

theorem pos_denom x : 0 < expNegInvGlue x + expNegInvGlue (1 - x) :=
  ((@zero_lt_one ‚Ñù _ _).lt_or_lt x).elim (fun hx => add_pos_of_pos_of_nonneg (pos_of_pos hx) (nonneg _)) fun hx =>
    add_pos_of_nonneg_of_pos (nonneg _) (pos_of_pos <| sub_pos.2 hx)

theorem one_of_one_le (h : 1 ‚â§ x) : smoothTransition x = 1 :=
  (div_eq_one_iff_eq <| (pos_denom x).ne').2 <| by
    rw [zero_of_nonpos (sub_nonpos.2 h), add_zero‚Çì]

theorem zero_of_nonpos (h : x ‚â§ 0) : smoothTransition x = 0 := by
  rw [smooth_transition, zero_of_nonpos h, zero_div]

theorem le_one (x : ‚Ñù) : smoothTransition x ‚â§ 1 :=
  (div_le_one (pos_denom x)).2 <| le_add_of_nonneg_right (nonneg _)

theorem nonneg (x : ‚Ñù) : 0 ‚â§ smoothTransition x :=
  div_nonneg (expNegInvGlue.nonneg _) (pos_denom x).le

theorem lt_one_of_lt_one (h : x < 1) : smoothTransition x < 1 :=
  (div_lt_one <| pos_denom x).2 <| lt_add_of_pos_right _ <| pos_of_pos <| sub_pos.2 h

theorem pos_of_pos (h : 0 < x) : 0 < smoothTransition x :=
  div_pos (expNegInvGlue.pos_of_pos h) (pos_denom x)

protected theorem times_cont_diff {n} : TimesContDiff ‚Ñù n smoothTransition :=
  (expNegInvGlue.times_cont_diff.div
      (expNegInvGlue.times_cont_diff.add <|
        expNegInvGlue.times_cont_diff.comp <| times_cont_diff_const.sub times_cont_diff_id))
    fun x => (pos_denom x).ne'

protected theorem times_cont_diff_at {x n} : TimesContDiffAt ‚Ñù n smoothTransition x :=
  smoothTransition.times_cont_diff.TimesContDiffAt

end SmoothTransition

end Real

variable {E : Type _}

/-- `f : times_cont_diff_bump_of_inner c`, where `c` is a point in an inner product space, is a
bundled smooth function such that

- `f` is equal to `1` in `metric.closed_ball c f.r`;
- `support f = metric.ball c f.R`;
- `0 ‚â§ f x ‚â§ 1` for all `x`.

The structure `times_cont_diff_bump_of_inner` contains the data required to construct the function:
real numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available through
`coe_fn`. -/
structure TimesContDiffBumpOfInner (c : E) where
  (R r : ‚Ñù)
  r_pos : 0 < r
  r_lt_R : r < R

namespace TimesContDiffBumpOfInner

theorem R_pos {c : E} (f : TimesContDiffBumpOfInner c) : 0 < f.r :=
  f.r_pos.trans f.r_lt_R

instance (c : E) : Inhabited (TimesContDiffBumpOfInner c) :=
  ‚ü®‚ü®1, 2, zero_lt_one, one_lt_two‚ü©‚ü©

variable [InnerProductSpace ‚Ñù E] {c : E} (f : TimesContDiffBumpOfInner c) {x : E}

/-- The function defined by `f : times_cont_diff_bump_of_inner c`. Use automatic coercion to
function instead. -/
def toFun (f : TimesContDiffBumpOfInner c) : E ‚Üí ‚Ñù := fun x => Real.smoothTransition ((f.r - dist x c) / (f.r - f.R))

instance : CoeFun (TimesContDiffBumpOfInner c) fun _ => E ‚Üí ‚Ñù :=
  ‚ü®toFun‚ü©

open real (smoothTransition)

open Real.smoothTransition Metric

theorem one_of_mem_closed_ball (hx : x ‚àà ClosedBall c f.R) : f x = 1 :=
  one_of_one_le <| (one_le_div (sub_pos.2 f.r_lt_R)).2 <| sub_le_sub_left hx _

theorem nonneg : 0 ‚â§ f x :=
  nonneg _

theorem le_one : f x ‚â§ 1 :=
  le_one _

theorem pos_of_mem_ball (hx : x ‚àà Ball c f.r) : 0 < f x :=
  pos_of_pos <| div_pos (sub_pos.2 hx) (sub_pos.2 f.r_lt_R)

theorem lt_one_of_lt_dist (h : f.R < dist x c) : f x < 1 :=
  lt_one_of_lt_one <| (div_lt_one (sub_pos.2 f.r_lt_R)).2 <| sub_lt_sub_left h _

theorem zero_of_le_dist (hx : f.r ‚â§ dist x c) : f x = 0 :=
  zero_of_nonpos <| div_nonpos_of_nonpos_of_nonneg (sub_nonpos.2 hx) (sub_nonneg.2 f.r_lt_R.le)

theorem support_eq : Support (f : E ‚Üí ‚Ñù) = Metric.Ball c f.r := by
  ext x
  suffices f x ‚â† 0 ‚Üî dist x c < f.R by
    simpa [mem_support]
  cases' lt_or_le‚Çì (dist x c) f.R with hx hx
  ¬∑ simp [hx, (f.pos_of_mem_ball hx).ne']
    
  ¬∑ simp [hx.not_lt, f.zero_of_le_dist hx]
    

theorem eventually_eq_one_of_mem_ball (h : x ‚àà Ball c f.R) : f =·∂†[ùìù x] 1 :=
  ((is_open_lt (continuous_id.dist continuous_const) continuous_const).eventually_mem h).mono fun z hz =>
    f.one_of_mem_closed_ball (le_of_lt‚Çì hz)

theorem eventually_eq_one : f =·∂†[ùìù c] 1 :=
  f.eventually_eq_one_of_mem_ball (mem_ball_self f.r_pos)

protected theorem times_cont_diff_at {n} : TimesContDiffAt ‚Ñù n f x := by
  rcases em (x = c) with (rfl | hx)
  ¬∑ refine' TimesContDiffAt.congr_of_eventually_eq _ f.eventually_eq_one
    rw [Pi.one_def]
    exact times_cont_diff_at_const
    
  ¬∑ exact
      real.smooth_transition.times_cont_diff_at.comp x
        (TimesContDiffAt.div_const <|
          times_cont_diff_at_const.sub <| times_cont_diff_at_id.dist times_cont_diff_at_const hx)
    

protected theorem times_cont_diff {n} : TimesContDiff ‚Ñù n f :=
  times_cont_diff_iff_times_cont_diff_at.2 fun y => f.TimesContDiffAt

protected theorem times_cont_diff_within_at {s n} : TimesContDiffWithinAt ‚Ñù n f s x :=
  f.TimesContDiffAt.TimesContDiffWithinAt

end TimesContDiffBumpOfInner

/-- `f : times_cont_diff_bump c`, where `c` is a point in a finite dimensional real vector space, is
a bundled smooth function such that

  - `f` is equal to `1` in `euclidean.closed_ball c f.r`;
  - `support f = euclidean.ball c f.R`;
  - `0 ‚â§ f x ‚â§ 1` for all `x`.

The structure `times_cont_diff_bump` contains the data required to construct the function: real
numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available through `coe_fn`.-/
structure TimesContDiffBump [NormedGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] (c : E) extends
  TimesContDiffBumpOfInner (toEuclidean c)

namespace TimesContDiffBump

variable [NormedGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] {c x : E} (f : TimesContDiffBump c)

/-- The function defined by `f : times_cont_diff_bump c`. Use automatic coercion to function
instead. -/
def toFun (f : TimesContDiffBump c) : E ‚Üí ‚Ñù :=
  f.toTimesContDiffBumpOfInner ‚àò toEuclidean

instance : CoeFun (TimesContDiffBump c) fun _ => E ‚Üí ‚Ñù :=
  ‚ü®toFun‚ü©

instance (c : E) : Inhabited (TimesContDiffBump c) :=
  ‚ü®‚ü®default‚ü©‚ü©

theorem R_pos : 0 < f.r :=
  f.toTimesContDiffBumpOfInner.R_pos

theorem coe_eq_comp : ‚áëf = f.toTimesContDiffBumpOfInner ‚àò toEuclidean :=
  rfl

theorem one_of_mem_closed_ball (hx : x ‚àà Euclidean.ClosedBall c f.R) : f x = 1 :=
  f.toTimesContDiffBumpOfInner.one_of_mem_closed_ball hx

theorem nonneg : 0 ‚â§ f x :=
  f.toTimesContDiffBumpOfInner.Nonneg

theorem le_one : f x ‚â§ 1 :=
  f.toTimesContDiffBumpOfInner.le_one

theorem pos_of_mem_ball (hx : x ‚àà Euclidean.Ball c f.r) : 0 < f x :=
  f.toTimesContDiffBumpOfInner.pos_of_mem_ball hx

theorem lt_one_of_lt_dist (h : f.R < Euclidean.dist x c) : f x < 1 :=
  f.toTimesContDiffBumpOfInner.lt_one_of_lt_dist h

theorem zero_of_le_dist (hx : f.r ‚â§ Euclidean.dist x c) : f x = 0 :=
  f.toTimesContDiffBumpOfInner.zero_of_le_dist hx

theorem support_eq : Support (f : E ‚Üí ‚Ñù) = Euclidean.Ball c f.r := by
  rw [Euclidean.ball_eq_preimage, ‚Üê f.to_times_cont_diff_bump_of_inner.support_eq, ‚Üê support_comp_eq_preimage,
    coe_eq_comp]

theorem closure_support_eq : Closure (Support f) = Euclidean.ClosedBall c f.r := by
  rw [f.support_eq, Euclidean.closure_ball _ f.R_pos]

theorem compact_closure_support : IsCompact (Closure (Support f)) := by
  rw [f.closure_support_eq]
  exact Euclidean.is_compact_closed_ball

theorem eventually_eq_one_of_mem_ball (h : x ‚àà Euclidean.Ball c f.R) : f =·∂†[ùìù x] 1 :=
  toEuclidean.ContinuousAt (f.toTimesContDiffBumpOfInner.eventually_eq_one_of_mem_ball h)

theorem eventually_eq_one : f =·∂†[ùìù c] 1 :=
  f.eventually_eq_one_of_mem_ball <| Euclidean.mem_ball_self f.r_pos

protected theorem times_cont_diff {n} : TimesContDiff ‚Ñù n f :=
  f.toTimesContDiffBumpOfInner.TimesContDiff.comp (toEuclidean : E ‚âÉL[‚Ñù] _).TimesContDiff

protected theorem times_cont_diff_at {n} : TimesContDiffAt ‚Ñù n f x :=
  f.TimesContDiff.TimesContDiffAt

protected theorem times_cont_diff_within_at {s n} : TimesContDiffWithinAt ‚Ñù n f s x :=
  f.TimesContDiffAt.TimesContDiffWithinAt

theorem exists_closure_support_subset {s : Set E} (hs : s ‚àà ùìù c) : ‚àÉ f : TimesContDiffBump c, Closure (Support f) ‚äÜ s :=
  let ‚ü®R, h0, hR‚ü© := Euclidean.nhds_basis_closed_ball.mem_iff.1 hs
  ‚ü®‚ü®‚ü®R / 2, R, half_pos h0, half_lt_self h0‚ü©‚ü©, by
    rwa [closure_support_eq]‚ü©

theorem exists_closure_subset {R : ‚Ñù} (hR : 0 < R) {s : Set E} (hs : IsClosed s) (hsR : s ‚äÜ Euclidean.Ball c R) :
    ‚àÉ f : TimesContDiffBump c, f.r = R ‚àß s ‚äÜ Euclidean.Ball c f.R := by
  rcases Euclidean.exists_pos_lt_subset_ball hR hs hsR with ‚ü®r, hr, hsr‚ü©
  exact ‚ü®‚ü®‚ü®r, R, hr.1, hr.2‚ü©‚ü©, rfl, hsr‚ü©

end TimesContDiffBump

open FiniteDimensional Metric

/-- If `E` is a finite dimensional normed space over `‚Ñù`, then for any point `x : E` and its
neighborhood `s` there exists an infinitely smooth function with the following properties:

* `f y = 1` in a neighborhood of `x`;
* `f y = 0` outside of `s`;
*  moreover, `closure (support f) ‚äÜ s` and `closure (support f)` is a compact set;
* `f y ‚àà [0, 1]` for all `y`.

This lemma is a simple wrapper around lemmas about bundled smooth bump functions, see
`times_cont_diff_bump`. -/
theorem exists_times_cont_diff_bump_function_of_mem_nhds [NormedGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E]
    {x : E} {s : Set E} (hs : s ‚àà ùìù x) :
    ‚àÉ f : E ‚Üí ‚Ñù,
      f =·∂†[ùìù x] 1 ‚àß
        (‚àÄ y, f y ‚àà Icc (0 : ‚Ñù) 1) ‚àß TimesContDiff ‚Ñù ‚ä§ f ‚àß IsCompact (Closure <| Support f) ‚àß Closure (Support f) ‚äÜ s :=
  let ‚ü®f, hf‚ü© := TimesContDiffBump.exists_closure_support_subset hs
  ‚ü®f, f.eventually_eq_one, fun y => ‚ü®f.Nonneg, f.le_one‚ü©, f.TimesContDiff, f.compact_closure_support, hf‚ü©

