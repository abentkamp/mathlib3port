import Mathbin.CategoryTheory.Monoidal.Functor
import Mathbin.CategoryTheory.Monoidal.Braided
import Mathbin.CategoryTheory.Monoidal.Transport
import Mathbin.CategoryTheory.Skeletal

/-!
# The monoid on the skeleton of a monoidal category

The skeleton of a monoidal category is a monoid.
-/


namespace CategoryTheory

open MonoidalCategory

universe v u

variable {C : Type u} [category.{v} C] [monoidal_category C]

/--  If `C` is monoidal and skeletal, it is a monoid.
See note [reducible non-instances]. -/
@[reducible]
def monoid_of_skeletal_monoidal (hC : skeletal C) : Monoid‚Çì C :=
  { mul := fun X Y => (X ‚äó Y : C), one := (ùüô_ C : C), one_mul := fun X => hC ‚ü®Œª_ X‚ü©, mul_one := fun X => hC ‚ü®œÅ_ X‚ü©,
    mul_assoc := fun X Y Z => hC ‚ü®Œ±_ X Y Z‚ü© }

/--  If `C` is braided and skeletal, it is a commutative monoid. -/
def comm_monoid_of_skeletal_braided [braided_category C] (hC : skeletal C) : CommMonoid‚Çì C :=
  { monoid_of_skeletal_monoidal hC with mul_comm := fun X Y => hC ‚ü®Œ≤_ X Y‚ü© }

/-- 
The skeleton of a monoidal category has a monoidal structure itself, induced by the equivalence.
-/
noncomputable instance : monoidal_category (skeleton C) :=
  monoidal.transport (skeleton_equivalence C).symm

/-- 
The skeleton of a monoidal category can be viewed as a monoid, where the multiplication is given by
the tensor product, and satisfies the monoid axioms since it is a skeleton.
-/
noncomputable instance : Monoid‚Çì (skeleton C) :=
  monoid_of_skeletal_monoidal (skeleton_is_skeleton _).skel

end CategoryTheory

