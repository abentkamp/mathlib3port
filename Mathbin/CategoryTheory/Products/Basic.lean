import Mathbin.CategoryTheory.EqToHom

/-!
# Cartesian products of categories

We define the category instance on `C × D` when `C` and `D` are categories.

We define:
* `sectl C Z` : the functor `C ⥤ C × D` given by `X ↦ ⟨X, Z⟩`
* `sectr Z D` : the functor `D ⥤ C × D` given by `Y ↦ ⟨Z, Y⟩`
* `fst`       : the functor `⟨X, Y⟩ ↦ X`
* `snd`       : the functor `⟨X, Y⟩ ↦ Y`
* `swap`      : the functor `C × D ⥤ D × C` given by `⟨X, Y⟩ ↦ ⟨Y, X⟩`
    (and the fact this is an equivalence)

We further define `evaluation : C ⥤ (C ⥤ D) ⥤ D` and `evaluation_uncurried : C × (C ⥤ D) ⥤ D`,
and products of functors and natural transformations, written `F.prod G` and `α.prod β`.
-/


namespace CategoryTheory

universe v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄

section 

variable (C : Type u₁) [category.{v₁} C] (D : Type u₂) [category.{v₂} D]

/--
`prod C D` gives the cartesian product of two categories.

See https://stacks.math.columbia.edu/tag/001K.
-/
@[simps (config := { notRecursive := [] })]
instance Prod : category.{max v₁ v₂} (C × D) :=
  { Hom := fun X Y => (X.1 ⟶ Y.1) × (X.2 ⟶ Y.2), id := fun X => ⟨𝟙 X.1, 𝟙 X.2⟩,
    comp := fun _ _ _ f g => (f.1 ≫ g.1, f.2 ≫ g.2) }

/-- Two rfl lemmas that cannot be generated by `@[simps]`. -/
@[simp]
theorem prod_id (X : C) (Y : D) : 𝟙 (X, Y) = (𝟙 X, 𝟙 Y) :=
  rfl

@[simp]
theorem prod_comp {P Q R : C} {S T U : D} (f : (P, S) ⟶ (Q, T)) (g : (Q, T) ⟶ (R, U)) :
  f ≫ g = (f.1 ≫ g.1, f.2 ≫ g.2) :=
  rfl

end 

section 

variable (C : Type u₁) [category.{v₁} C] (D : Type u₁) [category.{v₁} D]

/--
`prod.category.uniform C D` is an additional instance specialised so both factors have the same
universe levels. This helps typeclass resolution.
-/
instance uniform_prod : category (C × D) :=
  CategoryTheory.prod C D

end 

namespace Prod

/-- `sectl C Z` is the functor `C ⥤ C × D` given by `X ↦ (X, Z)`. -/
@[simps]
def sectl (C : Type u₁) [category.{v₁} C] {D : Type u₂} [category.{v₂} D] (Z : D) : C ⥤ C × D :=
  { obj := fun X => (X, Z), map := fun X Y f => (f, 𝟙 Z) }

/-- `sectr Z D` is the functor `D ⥤ C × D` given by `Y ↦ (Z, Y)` . -/
@[simps]
def sectr {C : Type u₁} [category.{v₁} C] (Z : C) (D : Type u₂) [category.{v₂} D] : D ⥤ C × D :=
  { obj := fun X => (Z, X), map := fun X Y f => (𝟙 Z, f) }

variable (C : Type u₁) [category.{v₁} C] (D : Type u₂) [category.{v₂} D]

/-- `fst` is the functor `(X, Y) ↦ X`. -/
@[simps]
def fst : C × D ⥤ C :=
  { obj := fun X => X.1, map := fun X Y f => f.1 }

/-- `snd` is the functor `(X, Y) ↦ Y`. -/
@[simps]
def snd : C × D ⥤ D :=
  { obj := fun X => X.2, map := fun X Y f => f.2 }

/-- The functor swapping the factors of a cartesian product of categories, `C × D ⥤ D × C`. -/
@[simps]
def swap : C × D ⥤ D × C :=
  { obj := fun X => (X.2, X.1), map := fun _ _ f => (f.2, f.1) }

/--
Swapping the factors of a cartesion product of categories twice is naturally isomorphic
to the identity functor.
-/
@[simps]
def symmetry : swap C D ⋙ swap D C ≅ 𝟭 (C × D) :=
  { Hom := { app := fun X => 𝟙 X }, inv := { app := fun X => 𝟙 X } }

/--
The equivalence, given by swapping factors, between `C × D` and `D × C`.
-/
@[simps]
def braiding : C × D ≌ D × C :=
  equivalence.mk (swap C D) (swap D C)
    (nat_iso.of_components
      (fun X =>
        eq_to_iso
          (by 
            simp ))
      (by 
        tidy))
    (nat_iso.of_components
      (fun X =>
        eq_to_iso
          (by 
            simp ))
      (by 
        tidy))

instance swap_is_equivalence : is_equivalence (swap C D) :=
  (by 
    infer_instance :
  is_equivalence (braiding C D).Functor)

end Prod

section 

variable (C : Type u₁) [category.{v₁} C] (D : Type u₂) [category.{v₂} D]

/--
The "evaluation at `X`" functor, such that
`(evaluation.obj X).obj F = F.obj X`,
which is functorial in both `X` and `F`.
-/
@[simps]
def evaluation : C ⥤ (C ⥤ D) ⥤ D :=
  { obj := fun X => { obj := fun F => F.obj X, map := fun F G α => α.app X },
    map := fun X Y f => { app := fun F => F.map f, naturality' := fun F G α => Eq.symm (α.naturality f) } }

/--
The "evaluation of `F` at `X`" functor,
as a functor `C × (C ⥤ D) ⥤ D`.
-/
@[simps]
def evaluation_uncurried : C × (C ⥤ D) ⥤ D :=
  { obj := fun p => p.2.obj p.1, map := fun x y f => x.2.map f.1 ≫ f.2.app y.1,
    map_comp' :=
      fun X Y Z f g =>
        by 
          cases g 
          cases f 
          cases Z 
          cases Y 
          cases X 
          simp only [prod_comp, nat_trans.comp_app, functor.map_comp, category.assoc]
          rw [←nat_trans.comp_app, nat_trans.naturality, nat_trans.comp_app, category.assoc, nat_trans.naturality] }

end 

variable {A : Type u₁} [category.{v₁} A] {B : Type u₂} [category.{v₂} B] {C : Type u₃} [category.{v₃} C] {D : Type u₄}
  [category.{v₄} D]

namespace Functor

/-- The cartesian product of two functors. -/
@[simps]
def Prod (F : A ⥤ B) (G : C ⥤ D) : A × C ⥤ B × D :=
  { obj := fun X => (F.obj X.1, G.obj X.2), map := fun _ _ f => (F.map f.1, G.map f.2) }

end Functor

namespace NatTrans

/-- The cartesian product of two natural transformations. -/
@[simps]
def Prod {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) : F.prod H ⟶ G.prod I :=
  { app := fun X => (α.app X.1, β.app X.2),
    naturality' :=
      fun X Y f =>
        by 
          cases X 
          cases Y 
          simp only [functor.prod_map, Prod.mk.inj_iffₓ, prod_comp]
          constructor <;> rw [naturality] }

end NatTrans

end CategoryTheory

