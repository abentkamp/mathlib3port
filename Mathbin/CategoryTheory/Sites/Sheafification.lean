import Mathbin.CategoryTheory.Sites.Plus
import Mathbin.CategoryTheory.Limits.ConcreteCategory

/-!

# Sheafification

We construct the sheafification of a presheaf over a site `C` with values in `D` whenever
`D` is a concrete category for which the forgetful functor preserves the appropriate (co)limits
and reflects isomorphisms.

We generally follow the approach of https://stacks.math.columbia.edu/tag/00W1

-/


namespace CategoryTheory

open CategoryTheory.Limits Opposite

universe w v u

variable {C : Type u} [category.{v} C] {J : grothendieck_topology C}

variable {D : Type w} [category.{max v u} D]

section

variable [concrete_category.{max v u} D]

attribute [local instance] concrete_category.has_coe_to_sort concrete_category.has_coe_to_fun

/-- A concrete version of the multiequalizer, to be used below. -/
@[nolint has_inhabited_instance]
def meq {X : C} (P : Cแตแต โฅค D) (S : J.cover X) :=
  { x : โ I : S.arrow, P.obj (op I.Y) // โ I : S.relation, P.map I.gโ.op (x I.fst) = P.map I.gโ.op (x I.snd) }

end

namespace Meq

variable [concrete_category.{max v u} D]

attribute [local instance] concrete_category.has_coe_to_sort concrete_category.has_coe_to_fun

instance {X} (P : Cแตแต โฅค D) (S : J.cover X) : CoeFun (meq P S) fun x => โ I : S.arrow, P.obj (op I.Y) :=
  โจfun x => x.1โฉ

@[ext]
theorem ext {X} {P : Cแตแต โฅค D} {S : J.cover X} (x y : meq P S) (h : โ I : S.arrow, x I = y I) : x = y :=
  Subtype.ext <| funext <| h

theorem condition {X} {P : Cแตแต โฅค D} {S : J.cover X} (x : meq P S) (I : S.relation) :
    P.map I.gโ.op (x ((S.index P).fstTo I)) = P.map I.gโ.op (x ((S.index P).sndTo I)) :=
  x.2 _

/-- Refine a term of `meq P T` with respect to a refinement `S โถ T` of covers. -/
def refine {X : C} {P : Cแตแต โฅค D} {S T : J.cover X} (x : meq P T) (e : S โถ T) : meq P S :=
  โจfun I => x โจI.Y, I.f, (le_of_hom e) _ I.hfโฉ, fun I =>
    x.condition โจI.Yโ, I.Yโ, I.Z, I.gโ, I.gโ, I.fโ, I.fโ, (le_of_hom e) _ I.hโ, (le_of_hom e) _ I.hโ, I.wโฉโฉ

@[simp]
theorem refine_apply {X : C} {P : Cแตแต โฅค D} {S T : J.cover X} (x : meq P T) (e : S โถ T) (I : S.arrow) :
    x.refine e I = x โจI.Y, I.f, (le_of_hom e) _ I.hfโฉ :=
  rfl

/-- Pull back a term of `meq P S` with respect to a morphism `f : Y โถ X` in `C`. -/
def pullback {Y X : C} {P : Cแตแต โฅค D} {S : J.cover X} (x : meq P S) (f : Y โถ X) : meq P ((J.pullback f).obj S) :=
  โจfun I => x โจ_, I.f โซ f, I.hfโฉ, fun I =>
    x.condition
      โจI.Yโ, I.Yโ, I.Z, I.gโ, I.gโ, I.fโ โซ f, I.fโ โซ f, I.hโ, I.hโ, by
        simp [reassoc_of I.w]โฉโฉ

@[simp]
theorem pullback_apply {Y X : C} {P : Cแตแต โฅค D} {S : J.cover X} (x : meq P S) (f : Y โถ X)
    (I : ((J.pullback f).obj S).arrow) : x.pullback f I = x โจ_, I.f โซ f, I.hfโฉ :=
  rfl

@[simp]
theorem pullback_refine {Y X : C} {P : Cแตแต โฅค D} {S T : J.cover X} (h : S โถ T) (f : Y โถ X) (x : meq P T) :
    (x.pullback f).refine ((J.pullback f).map h) = (refine x h).pullback _ :=
  rfl

/-- Make a term of `meq P S`. -/
def mk {X : C} {P : Cแตแต โฅค D} (S : J.cover X) (x : P.obj (op X)) : meq P S :=
  โจfun I => P.map I.f.op x, fun I => by
    dsimp
    simp only [โ comp_apply, โ P.map_comp, โ op_comp, I.w]โฉ

theorem mk_apply {X : C} {P : Cแตแต โฅค D} (S : J.cover X) (x : P.obj (op X)) (I : S.arrow) : mk S x I = P.map I.f.op x :=
  rfl

variable [preserves_limits (forget D)]

/-- The equivalence between the type associated to `multiequalizer (S.index P)` and `meq P S`. -/
noncomputable def Equivโ {X : C} (P : Cแตแต โฅค D) (S : J.cover X) [has_multiequalizer (S.index P)] :
    (multiequalizer (S.index P) : D) โ meq P S :=
  limits.concrete.multiequalizer_equiv _

@[simp]
theorem equiv_apply {X : C} {P : Cแตแต โฅค D} {S : J.cover X} [has_multiequalizer (S.index P)]
    (x : multiequalizer (S.index P)) (I : S.arrow) : Equivโ P S x I = multiequalizer.ฮน (S.index P) I x :=
  rfl

@[simp]
theorem equiv_symm_eq_apply {X : C} {P : Cแตแต โฅค D} {S : J.cover X} [has_multiequalizer (S.index P)] (x : meq P S)
    (I : S.arrow) : multiequalizer.ฮน (S.index P) I ((meq.equiv P S).symm x) = x I := by
  let z := (meq.equiv P S).symm x
  rw [โ equiv_apply]
  simp

end Meq

namespace GrothendieckTopology

namespace Plus

variable [concrete_category.{max v u} D]

attribute [local instance] concrete_category.has_coe_to_sort concrete_category.has_coe_to_fun

variable [preserves_limits (forget D)]

variable [โ X : C, has_colimits_of_shape (J.cover Xแตแต) D]

variable [โ P : Cแตแต โฅค D X : C S : J.cover X, has_multiequalizer (S.index P)]

noncomputable section

/-- Make a term of `(J.plus_obj P).obj (op X)` from `x : meq P S`. -/
def mk {X : C} {P : Cแตแต โฅค D} {S : J.cover X} (x : meq P S) : (J.plus_obj P).obj (op X) :=
  colimit.ฮน (J.diagram P X) (op S) ((meq.equiv P S).symm x)

theorem res_mk_eq_mk_pullback {Y X : C} {P : Cแตแต โฅค D} {S : J.cover X} (x : meq P S) (f : Y โถ X) :
    (J.plus_obj P).map f.op (mk x) = mk (x.pullback f) := by
  dsimp [mk, plus_obj]
  simp only [โ comp_apply, colimit.ฮน_pre, ฮน_colim_map_assoc]
  simp_rw [comp_apply]
  congr 1
  apply_fun meq.equiv P _
  erw [Equivโ.apply_symm_apply]
  ext i
  simp only [diagram_pullback_app, meq.pullback_apply, meq.equiv_apply, โ comp_apply]
  erw [multiequalizer.lift_ฮน, meq.equiv_symm_eq_apply]
  cases i
  rfl

theorem to_plus_mk {X : C} {P : Cแตแต โฅค D} (S : J.cover X) (x : P.obj (op X)) : (J.to_plus P).app _ x = mk (meq.mk S x) :=
  by
  dsimp [mk, to_plus]
  let e : S โถ โค := hom_of_le (OrderTop.le_top _)
  rw [โ colimit.w _ e.op]
  delta' cover.to_multiequalizer
  simp only [comp_apply]
  congr 1
  dsimp [diagram]
  apply concrete.multiequalizer_ext
  intro i
  simpa only [โ comp_apply, category.assoc, multiequalizer.lift_ฮน, category.comp_id, meq.equiv_symm_eq_apply]

theorem to_plus_apply {X : C} {P : Cแตแต โฅค D} (S : J.cover X) (x : meq P S) (I : S.arrow) :
    (J.to_plus P).app _ (x I) = (J.plus_obj P).map I.f.op (mk x) := by
  dsimp only [to_plus, plus_obj]
  delta' cover.to_multiequalizer
  dsimp [mk]
  simp only [โ comp_apply, colimit.ฮน_pre, ฮน_colim_map_assoc]
  simp only [comp_apply]
  dsimp only [functor.op]
  let e : (J.pullback I.f).obj (unop (op S)) โถ โค := hom_of_le (OrderTop.le_top _)
  rw [โ colimit.w _ e.op]
  simp only [comp_apply]
  congr 1
  apply concrete.multiequalizer_ext
  intro i
  dsimp [diagram]
  simp only [โ comp_apply, category.assoc, multiequalizer.lift_ฮน, category.comp_id, meq.equiv_symm_eq_apply]
  let RR : S.relation :=
    โจ_, _, _, i.f, ๐ _, I.f, i.f โซ I.f, I.hf, sieve.downward_closed _ I.hf _, by
      simp โฉ
  cases I
  erw [x.condition RR]
  simpa [RR]

theorem to_plus_eq_mk {X : C} {P : Cแตแต โฅค D} (x : P.obj (op X)) : (J.to_plus P).app _ x = mk (meq.mk โค x) := by
  dsimp [mk, to_plus]
  delta' cover.to_multiequalizer
  simp only [comp_apply]
  congr 1
  apply_fun meq.equiv P โค
  ext i
  simpa

variable [โ X : C, preserves_colimits_of_shape (J.cover Xแตแต) (forget D)]

theorem exists_rep {X : C} {P : Cแตแต โฅค D} (x : (J.plus_obj P).obj (op X)) : โ (S : J.cover X)(y : meq P S), x = mk y :=
  by
  obtain โจS, y, hโฉ := concrete.colimit_exists_rep (J.diagram P X) x
  use S.unop, meq.equiv _ _ y
  rw [โ h]
  dsimp [mk]
  simp

theorem eq_mk_iff_exists {X : C} {P : Cแตแต โฅค D} {S T : J.cover X} (x : meq P S) (y : meq P T) :
    mk x = mk y โ โ (W : J.cover X)(h1 : W โถ S)(h2 : W โถ T), x.refine h1 = y.refine h2 := by
  constructor
  ยท intro h
    obtain โจW, h1, h2, hhโฉ := concrete.colimit_exists_of_rep_eq _ _ _ h
    use W.unop, h1.unop, h2.unop
    ext I
    apply_fun multiequalizer.ฮน (W.unop.index P) I  at hh
    convert hh
    all_goals
      dsimp [diagram]
      simp only [โ comp_apply, multiequalizer.lift_ฮน, category.comp_id, meq.equiv_symm_eq_apply]
      cases I
      rfl
    
  ยท rintro โจS, h1, h2, eโฉ
    apply concrete.colimit_rep_eq_of_exists
    use op S, h1.op, h2.op
    apply concrete.multiequalizer_ext
    intro i
    apply_fun fun ee => ee i  at e
    convert e
    all_goals
      dsimp [diagram]
      simp only [โ comp_apply, multiequalizer.lift_ฮน, meq.equiv_symm_eq_apply]
      cases i
      rfl
    

/-- `Pโบ` is always separated. -/
theorem sep {X : C} (P : Cแตแต โฅค D) (S : J.cover X) (x y : (J.plus_obj P).obj (op X))
    (h : โ I : S.arrow, (J.plus_obj P).map I.f.op x = (J.plus_obj P).map I.f.op y) : x = y := by
  obtain โจSx, x, rflโฉ := exists_rep x
  obtain โจSy, y, rflโฉ := exists_rep y
  simp only [res_mk_eq_mk_pullback] at h
  choose W h1 h2 hh using fun I : S.arrow => (eq_mk_iff_exists _ _).mp (h I)
  rw [eq_mk_iff_exists]
  let B : J.cover X := S.bind W
  use B
  let ex : B โถ Sx :=
    hom_of_le
      (by
        rintro Y f โจZ, e1, e2, he2, he1, heeโฉ
        rw [โ hee]
        apply le_of_hom (h1 โจ_, _, he2โฉ)
        exact he1)
  let ey : B โถ Sy :=
    hom_of_le
      (by
        rintro Y f โจZ, e1, e2, he2, he1, heeโฉ
        rw [โ hee]
        apply le_of_hom (h2 โจ_, _, he2โฉ)
        exact he1)
  use ex, ey
  ext1 I
  let IS : S.arrow := I.from_middle
  specialize hh IS
  let IW : (W IS).arrow := I.to_middle
  apply_fun fun e => e IW  at hh
  convert hh
  ยท let Rx : Sx.relation :=
      โจI.Y, I.Y, I.Y, ๐ _, ๐ _, I.f, I.to_middle_hom โซ I.from_middle_hom, _, _, by
        simp [I.middle_spec]โฉ
    have := x.condition Rx
    simpa using this
    
  ยท let Ry : Sy.relation :=
      โจI.Y, I.Y, I.Y, ๐ _, ๐ _, I.f, I.to_middle_hom โซ I.from_middle_hom, _, _, by
        simp [I.middle_spec]โฉ
    have := y.condition Ry
    simpa using this
    

theorem inj_of_sep (P : Cแตแต โฅค D)
    (hsep : โ X : C S : J.cover X x y : P.obj (op X), (โ I : S.arrow, P.map I.f.op x = P.map I.f.op y) โ x = y)
    (X : C) : Function.Injective ((J.to_plus P).app (op X)) := by
  intro x y h
  simp only [to_plus_eq_mk] at h
  rw [eq_mk_iff_exists] at h
  obtain โจW, h1, h2, hhโฉ := h
  apply hsep X W
  intro I
  apply_fun fun e => e I  at hh
  exact hh

/-- An auxiliary definition to be used in the proof of `exists_of_sep` below.
  Given a compatible family of local sections for `Pโบ`, and representatives of said sections,
  construct a compatible family of local sections of `P` over the combination of the covers
  associated to the representatives.
  The separatedness condition is used to prove compatibility among these local sections of `P`. -/
def meq_of_sep (P : Cแตแต โฅค D)
    (hsep : โ X : C S : J.cover X x y : P.obj (op X), (โ I : S.arrow, P.map I.f.op x = P.map I.f.op y) โ x = y) (X : C)
    (S : J.cover X) (s : meq (J.plus_obj P) S) (T : โ I : S.arrow, J.cover I.Y) (t : โ I : S.arrow, meq P (T I))
    (ht : โ I : S.arrow, s I = mk (t I)) : meq P (S.bind T) where
  val := fun I => t I.from_middle I.to_middle
  property := by
    intro II
    apply inj_of_sep P hsep
    rw [โ comp_apply, โ comp_apply, (J.to_plus P).naturality, (J.to_plus P).naturality, comp_apply, comp_apply]
    erw [to_plus_apply (T II.fst.from_middle) (t II.fst.from_middle) II.fst.to_middle,
      to_plus_apply (T II.snd.from_middle) (t II.snd.from_middle) II.snd.to_middle, โ ht, โ ht, โ comp_apply, โ
      comp_apply, โ (J.plus_obj P).map_comp, โ (J.plus_obj P).map_comp]
    rw [โ op_comp, โ op_comp]
    let IR : S.relation :=
      โจ_, _, _, II.gโ โซ II.fst.to_middle_hom, II.gโ โซ II.snd.to_middle_hom, II.fst.from_middle_hom,
        II.snd.from_middle_hom, II.fst.from_middle_condition, II.snd.from_middle_condition, _โฉ
    swap
    ยท simp only [category.assoc, II.fst.middle_spec, II.snd.middle_spec]
      apply II.w
      
    exact s.condition IR

theorem exists_of_sep (P : Cแตแต โฅค D)
    (hsep : โ X : C S : J.cover X x y : P.obj (op X), (โ I : S.arrow, P.map I.f.op x = P.map I.f.op y) โ x = y) (X : C)
    (S : J.cover X) (s : meq (J.plus_obj P) S) : โ t : (J.plus_obj P).obj (op X), meq.mk S t = s := by
  have inj : โ X : C, Function.Injective ((J.to_plus P).app (op X)) := inj_of_sep _ hsep
  choose T t ht using fun I => exists_rep (s I)
  let B : J.cover X := S.bind T
  choose Z e1 e2 he2 he1 hee using fun I : B.arrow => I.hf
  let w : meq P B := meq_of_sep P hsep X S s T t ht
  use mk w
  ext I
  erw [ht, res_mk_eq_mk_pullback]
  apply sep P (T I)
  intro II
  simp only [res_mk_eq_mk_pullback, eq_mk_iff_exists]
  use (J.pullback II.f).obj (T I)
  let e0 : (J.pullback II.f).obj (T I) โถ (J.pullback II.f).obj ((J.pullback I.f).obj B) :=
    hom_of_le
      (by
        intro Y f hf
        apply sieve.le_pullback_bind _ _ _ I.hf
        ยท cases I
          exact hf
          )
  use e0, ๐ _
  ext IV
  dsimp only [meq.refine_apply, meq.pullback_apply, w]
  let IA : B.arrow := โจ_, (IV.f โซ II.f) โซ I.f, _โฉ
  swap
  ยท refine' โจI.Y, _, _, I.hf, _, rflโฉ
    apply sieve.downward_closed
    convert II.hf
    cases I
    rfl
    
  let IB : S.arrow := IA.from_middle
  let IC : (T IB).arrow := IA.to_middle
  let ID : (T I).arrow := โจIV.Y, IV.f โซ II.f, sieve.downward_closed (T I) II.hf IV.fโฉ
  change t IB IC = t I ID
  apply inj IV.Y
  erw [to_plus_apply (T I) (t I) ID, to_plus_apply (T IB) (t IB) IC, โ ht, โ ht]
  let IR : S.relation := โจ_, _, IV.Y, IC.f, ID.f, IB.f, I.f, _, I.hf, IA.middle_specโฉ
  convert s.condition IR
  cases I
  rfl

variable [reflects_isomorphisms (forget D)]

/-- If `P` is separated, then `Pโบ` is a sheaf. -/
theorem is_sheaf_of_sep (P : Cแตแต โฅค D)
    (hsep : โ X : C S : J.cover X x y : P.obj (op X), (โ I : S.arrow, P.map I.f.op x = P.map I.f.op y) โ x = y) :
    presheaf.is_sheaf J (J.plus_obj P) := by
  rw [presheaf.is_sheaf_iff_multiequalizer]
  intro X S
  apply is_iso_of_reflects_iso _ (forget D)
  rw [is_iso_iff_bijective]
  constructor
  ยท intro x y h
    apply sep P S _ _
    intro I
    apply_fun meq.equiv _ _  at h
    apply_fun fun e => e I  at h
    convert h
    ยท erw [meq.equiv_apply, โ comp_apply, multiequalizer.lift_ฮน]
      
    ยท erw [meq.equiv_apply, โ comp_apply, multiequalizer.lift_ฮน]
      
    
  ยท rintro (x : (multiequalizer (S.index _) : D))
    obtain โจt, htโฉ := exists_of_sep P hsep X S (meq.equiv _ _ x)
    use t
    apply_fun meq.equiv _ _
    swap
    ยท infer_instance
      
    rw [โ ht]
    ext i
    dsimp
    rw [โ comp_apply, multiequalizer.lift_ฮน]
    rfl
    

variable (J)

/-- `Pโบโบ` is always a sheaf. -/
theorem is_sheaf_plus_plus (P : Cแตแต โฅค D) : presheaf.is_sheaf J (J.plus_obj (J.plus_obj P)) := by
  apply is_sheaf_of_sep
  intro X S x y
  apply sep

end Plus

variable (J)

variable [โ P : Cแตแต โฅค D X : C S : J.cover X, has_multiequalizer (S.index P)]
  [โ X : C, has_colimits_of_shape (J.cover Xแตแต) D]

/-- The sheafification of a presheaf `P`.
*NOTE:* Additional hypotheses are needed to obtain a proof that this is a sheaf! -/
def sheafify (P : Cแตแต โฅค D) : Cแตแต โฅค D :=
  J.plus_obj (J.plus_obj P)

/-- The canonical map from `P` to its sheafification. -/
def to_sheafify (P : Cแตแต โฅค D) : P โถ J.sheafify P :=
  J.to_plus P โซ J.plus_map (J.to_plus P)

/-- The canonical map on sheafifications induced by a morphism. -/
def sheafify_map {P Q : Cแตแต โฅค D} (ฮท : P โถ Q) : J.sheafify P โถ J.sheafify Q :=
  J.plus_map <| J.plus_map ฮท

@[simp]
theorem sheafify_map_id (P : Cแตแต โฅค D) : J.sheafify_map (๐ P) = ๐ (J.sheafify P) := by
  dsimp [sheafify_map, sheafify]
  simp

@[simp]
theorem sheafify_map_comp {P Q R : Cแตแต โฅค D} (ฮท : P โถ Q) (ฮณ : Q โถ R) :
    J.sheafify_map (ฮท โซ ฮณ) = J.sheafify_map ฮท โซ J.sheafify_map ฮณ := by
  dsimp [sheafify_map, sheafify]
  simp

@[simp, reassoc]
theorem to_sheafify_naturality {P Q : Cแตแต โฅค D} (ฮท : P โถ Q) : ฮท โซ J.to_sheafify _ = J.to_sheafify _ โซ J.sheafify_map ฮท :=
  by
  dsimp [sheafify_map, sheafify, to_sheafify]
  simp

variable (D)

/-- The sheafification of a presheaf `P`, as a functor.
*NOTE:* Additional hypotheses are needed to obtain a proof that this is a sheaf! -/
def sheafification : (Cแตแต โฅค D) โฅค Cแตแต โฅค D :=
  J.plus_functor D โ J.plus_functor D

@[simp]
theorem sheafification_obj (P : Cแตแต โฅค D) : (J.sheafification D).obj P = J.sheafify P :=
  rfl

@[simp]
theorem sheafification_map {P Q : Cแตแต โฅค D} (ฮท : P โถ Q) : (J.sheafification D).map ฮท = J.sheafify_map ฮท :=
  rfl

/-- The canonical map from `P` to its sheafification, as a natural transformation.
*Note:* We only show this is a sheaf under additional hypotheses on `D`. -/
def to_sheafification : ๐ญ _ โถ sheafification J D :=
  J.to_plus_nat_trans D โซ whisker_right (J.to_plus_nat_trans D) (J.plus_functor D)

@[simp]
theorem to_sheafification_app (P : Cแตแต โฅค D) : (J.to_sheafification D).app P = J.to_sheafify P :=
  rfl

variable {D}

theorem is_iso_to_sheafify {P : Cแตแต โฅค D} (hP : presheaf.is_sheaf J P) : is_iso (J.to_sheafify P) := by
  dsimp [to_sheafify]
  have : is_iso (J.to_plus P) := by
    apply is_iso_to_plus_of_is_sheaf J P hP
  have : is_iso ((J.plus_functor D).map (J.to_plus P)) := by
    apply functor.map_is_iso
  exact @is_iso.comp_is_iso _ _ _ _ _ (J.to_plus P) ((J.plus_functor D).map (J.to_plus P)) _ _

/-- If `P` is a sheaf, then `P` is isomorphic to `J.sheafify P`. -/
def iso_sheafify {P : Cแตแต โฅค D} (hP : presheaf.is_sheaf J P) : P โ J.sheafify P := by
  let this' := is_iso_to_sheafify J hP <;> exact as_iso (J.to_sheafify P)

@[simp]
theorem iso_sheafify_hom {P : Cแตแต โฅค D} (hP : presheaf.is_sheaf J P) : (J.iso_sheafify hP).Hom = J.to_sheafify P :=
  rfl

/-- Given a sheaf `Q` and a morphism `P โถ Q`, construct a morphism from
`J.sheafifcation P` to `Q`. -/
def sheafify_lift {P Q : Cแตแต โฅค D} (ฮท : P โถ Q) (hQ : presheaf.is_sheaf J Q) : J.sheafify P โถ Q :=
  J.plus_lift (J.plus_lift ฮท hQ) hQ

@[simp, reassoc]
theorem to_sheafify_sheafify_lift {P Q : Cแตแต โฅค D} (ฮท : P โถ Q) (hQ : presheaf.is_sheaf J Q) :
    J.to_sheafify P โซ sheafify_lift J ฮท hQ = ฮท := by
  dsimp only [sheafify_lift, to_sheafify]
  simp

theorem sheafify_lift_unique {P Q : Cแตแต โฅค D} (ฮท : P โถ Q) (hQ : presheaf.is_sheaf J Q) (ฮณ : J.sheafify P โถ Q) :
    J.to_sheafify P โซ ฮณ = ฮท โ ฮณ = sheafify_lift J ฮท hQ := by
  intro h
  apply plus_lift_unique
  apply plus_lift_unique
  rw [โ category.assoc, โ plus_map_to_plus]
  exact h

@[simp]
theorem iso_sheafify_inv {P : Cแตแต โฅค D} (hP : presheaf.is_sheaf J P) :
    (J.iso_sheafify hP).inv = J.sheafify_lift (๐ _) hP := by
  apply J.sheafify_lift_unique
  simp [iso.comp_inv_eq]

theorem sheafify_hom_ext {P Q : Cแตแต โฅค D} (ฮท ฮณ : J.sheafify P โถ Q) (hQ : presheaf.is_sheaf J Q)
    (h : J.to_sheafify P โซ ฮท = J.to_sheafify P โซ ฮณ) : ฮท = ฮณ := by
  apply J.plus_hom_ext _ _ hQ
  apply J.plus_hom_ext _ _ hQ
  rw [โ category.assoc, โ category.assoc, โ plus_map_to_plus]
  exact h

@[simp, reassoc]
theorem sheafify_map_sheafify_lift {P Q R : Cแตแต โฅค D} (ฮท : P โถ Q) (ฮณ : Q โถ R) (hR : presheaf.is_sheaf J R) :
    J.sheafify_map ฮท โซ J.sheafify_lift ฮณ hR = J.sheafify_lift (ฮท โซ ฮณ) hR := by
  apply J.sheafify_lift_unique
  rw [โ category.assoc, โ J.to_sheafify_naturality, category.assoc, to_sheafify_sheafify_lift]

end GrothendieckTopology

variable (J)

variable [concrete_category.{max v u} D] [preserves_limits (forget D)]
  [โ P : Cแตแต โฅค D X : C S : J.cover X, has_multiequalizer (S.index P)] [โ X : C, has_colimits_of_shape (J.cover Xแตแต) D]
  [โ X : C, preserves_colimits_of_shape (J.cover Xแตแต) (forget D)] [reflects_isomorphisms (forget D)]

theorem grothendieck_topology.sheafify_is_sheaf (P : Cแตแต โฅค D) : presheaf.is_sheaf J (J.sheafify P) :=
  grothendieck_topology.plus.is_sheaf_plus_plus _ _

variable (D)

/-- The sheafification functor, as a functor taking values in `Sheaf`. -/
@[simps]
def presheaf_to_Sheaf : (Cแตแต โฅค D) โฅค Sheaf J D where
  obj := fun P => โจJ.sheafify P, J.sheafify_is_sheaf Pโฉ
  map := fun P Q ฮท => โจJ.sheafify_map ฮทโฉ
  map_id' := fun P => Sheaf.hom.ext _ _ <| J.sheafify_map_id _
  map_comp' := fun P Q R f g => Sheaf.hom.ext _ _ <| J.sheafify_map_comp _ _

/-- The sheafification functor is left adjoint to the forgetful functor. -/
@[simps unit_app counit_app_val]
def sheafification_adjunction : presheaf_to_Sheaf J D โฃ Sheaf_to_presheaf J D :=
  adjunction.mk_of_hom_equiv
    { homEquiv := fun P Q =>
        { toFun := fun e => J.to_sheafify P โซ e.val, invFun := fun e => โจJ.sheafify_lift e Q.2โฉ,
          left_inv := fun e => Sheaf.hom.ext _ _ <| (J.sheafify_lift_unique _ _ _ rfl).symm,
          right_inv := fun e => J.to_sheafify_sheafify_lift _ _ },
      hom_equiv_naturality_left_symm' := by
        intro P Q R ฮท ฮณ
        ext1
        dsimp
        symm
        apply J.sheafify_map_sheafify_lift,
      hom_equiv_naturality_right' := fun P Q R ฮท ฮณ => by
        dsimp
        rw [category.assoc] }

variable {J D}

/-- A sheaf `P` is isomorphic to its own sheafification. -/
@[simps]
def sheafification_iso (P : Sheaf J D) : P โ (presheaf_to_Sheaf J D).obj P.val where
  Hom := โจ(J.iso_sheafify P.2).Homโฉ
  inv := โจ(J.iso_sheafify P.2).invโฉ
  hom_inv_id' := by
    ext1
    apply (J.iso_sheafify P.2).hom_inv_id
  inv_hom_id' := by
    ext1
    apply (J.iso_sheafify P.2).inv_hom_id

instance is_iso_sheafification_adjunction_counit (P : Sheaf J D) :
    is_iso ((sheafification_adjunction J D).counit.app P) :=
  is_iso_of_fully_faithful (Sheaf_to_presheaf J D) _

instance sheafification_reflective : is_iso (sheafification_adjunction J D).counit :=
  nat_iso.is_iso_of_is_iso_app _

end CategoryTheory

