import Mathbin.Algebra.Order.Archimedean 
import Mathbin.GroupTheory.Subgroup.Basic

/-!
# Archimedean groups

This file proves a few facts about ordered groups which satisfy the `archimedean` property, that is:
`class archimedean (α) [ordered_add_comm_monoid α] : Prop :=`
`(arch : ∀ (x : α) {y}, 0 < y → ∃ n : ℕ, x ≤ n • y)`

They are placed here in a separate file (rather than incorporated as a continuation of
`algebra.order.archimedean`) because they rely on some imports from `group_theory` -- bundled
subgroups in particular.

The main result is `add_subgroup.cyclic_of_min`:  a subgroup of a decidable archimedean abelian
group is cyclic, if its set of positive elements has a minimal element.

This result is used in this file to deduce `int.subgroup_cyclic`, proving that every subgroup of `ℤ`
is cyclic.  (There are several other methods one could use to prove this fact, including more purely
algebraic methods, but none seem to exist in mathlib as of writing.  The closest is
`subgroup.is_cyclic`, but that has not been transferred to `add_subgroup`.)

The result is also used in `topology.instances.real` as an ingredient in the classification of
subgroups of `ℝ`.
-/


variable{G : Type _}[LinearOrderedAddCommGroup G][Archimedean G]

open LinearOrderedAddCommGroup

-- error in GroupTheory.Archimedean: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there
exists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/
theorem add_subgroup.cyclic_of_min
{H : add_subgroup G}
{a : G}
(ha : is_least {g : G | «expr ∧ »(«expr ∈ »(g, H), «expr < »(0, g))} a) : «expr = »(H, add_subgroup.closure {a}) :=
begin
  obtain ["⟨", "⟨", ident a_in, ",", ident a_pos, "⟩", ",", ident a_min, "⟩", ":=", expr ha],
  refine [expr le_antisymm _ «expr $ »(H.closure_le.mpr, by simp [] [] [] ["[", expr a_in, "]"] [] [])],
  intros [ident g, ident g_in],
  obtain ["⟨", ident k, ",", "⟨", ident nonneg, ",", ident lt, "⟩", ",", "_", "⟩", ":", expr «expr∃! , »((k), «expr ∧ »(«expr ≤ »(0, «expr - »(g, «expr • »(k, a))), «expr < »(«expr - »(g, «expr • »(k, a)), a))), ":=", expr exists_unique_zsmul_near_of_pos' a_pos g],
  have [ident h_zero] [":", expr «expr = »(«expr - »(g, «expr • »(k, a)), 0)] [],
  { by_contra [ident h],
    have [ident h] [":", expr «expr ≤ »(a, «expr - »(g, «expr • »(k, a)))] [],
    { refine [expr a_min ⟨_, _⟩],
      { exact [expr add_subgroup.sub_mem H g_in (add_subgroup.zsmul_mem H a_in k)] },
      { exact [expr lt_of_le_of_ne nonneg (ne.symm h)] } },
    have [ident h'] [":", expr «expr¬ »(«expr ≤ »(a, «expr - »(g, «expr • »(k, a))))] [":=", expr not_le.mpr lt],
    contradiction },
  simp [] [] [] ["[", expr sub_eq_zero.mp h_zero, ",", expr add_subgroup.mem_closure_singleton, "]"] [] []
end

-- error in GroupTheory.Archimedean: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Every subgroup of `ℤ` is cyclic. -/
theorem int.subgroup_cyclic (H : add_subgroup exprℤ()) : «expr∃ , »((a), «expr = »(H, add_subgroup.closure {a})) :=
begin
  cases [expr add_subgroup.bot_or_exists_ne_zero H] ["with", ident h, ident h],
  { use [expr 0],
    rw [expr h] [],
    exact [expr add_subgroup.closure_singleton_zero.symm] },
  let [ident s] [] [":=", expr {g : exprℤ() | «expr ∧ »(«expr ∈ »(g, H), «expr < »(0, g))}],
  have [ident h_bdd] [":", expr ∀ g «expr ∈ » s, «expr ≤ »((0 : exprℤ()), g)] [":=", expr λ _ h, le_of_lt h.2],
  obtain ["⟨", ident g₀, ",", ident g₀_in, ",", ident g₀_ne, "⟩", ":=", expr h],
  obtain ["⟨", ident g₁, ",", ident g₁_in, ",", ident g₁_pos, "⟩", ":", expr «expr∃ , »((g₁ : exprℤ()), «expr ∧ »(«expr ∈ »(g₁, H), «expr < »(0, g₁)))],
  { cases [expr lt_or_gt_of_ne g₀_ne] ["with", ident Hg₀, ident Hg₀],
    { exact [expr ⟨«expr- »(g₀), H.neg_mem g₀_in, neg_pos.mpr Hg₀⟩] },
    { exact [expr ⟨g₀, g₀_in, Hg₀⟩] } },
  obtain ["⟨", ident a, ",", ident ha, ",", ident ha', "⟩", ":=", expr int.exists_least_of_bdd ⟨(0 : exprℤ()), h_bdd⟩ ⟨g₁, g₁_in, g₁_pos⟩],
  exact [expr ⟨a, add_subgroup.cyclic_of_min ⟨ha, ha'⟩⟩]
end

