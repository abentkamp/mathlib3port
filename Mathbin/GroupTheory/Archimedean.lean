import Mathbin.Algebra.Order.Archimedean 
import Mathbin.GroupTheory.Subgroup.Basic

/-!
# Archimedean groups

This file proves a few facts about ordered groups which satisfy the `archimedean` property, that is:
`class archimedean (α) [ordered_add_comm_monoid α] : Prop :=`
`(arch : ∀ (x : α) {y}, 0 < y → ∃ n : ℕ, x ≤ n • y)`

They are placed here in a separate file (rather than incorporated as a continuation of
`algebra.order.archimedean`) because they rely on some imports from `group_theory` -- bundled
subgroups in particular.

The main result is `add_subgroup.cyclic_of_min`:  a subgroup of a decidable archimedean abelian
group is cyclic, if its set of positive elements has a minimal element.

This result is used in this file to deduce `int.subgroup_cyclic`, proving that every subgroup of `ℤ`
is cyclic.  (There are several other methods one could use to prove this fact, including more purely
algebraic methods, but none seem to exist in mathlib as of writing.  The closest is
`subgroup.is_cyclic`, but that has not been transferred to `add_subgroup`.)

The result is also used in `topology.instances.real` as an ingredient in the classification of
subgroups of `ℝ`.
-/


variable{G : Type _}[LinearOrderedAddCommGroup G][Archimedean G]

open LinearOrderedAddCommGroup

-- error in GroupTheory.Archimedean: ././Mathport/Syntax/Translate/Basic.lean:340:40: in by_contra: ././Mathport/Syntax/Translate/Tactic/Basic.lean:41:45: missing argument
/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there
exists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/
theorem add_subgroup.cyclic_of_min
{H : add_subgroup G}
{a : G}
(ha : is_least {g : G | «expr ∧ »(«expr ∈ »(g, H), «expr < »(0, g))} a) : «expr = »(H, add_subgroup.closure {a}) :=
begin
  obtain ["⟨", "⟨", ident a_in, ",", ident a_pos, "⟩", ",", ident a_min, "⟩", ":=", expr ha],
  refine [expr le_antisymm _ «expr $ »(H.closure_le.mpr, by simp [] [] [] ["[", expr a_in, "]"] [] [])],
  intros [ident g, ident g_in],
  obtain ["⟨", ident k, ",", "⟨", ident nonneg, ",", ident lt, "⟩", ",", "_", "⟩", ":", expr «expr∃! , »((k), «expr ∧ »(«expr ≤ »(0, «expr - »(g, «expr • »(k, a))), «expr < »(«expr - »(g, «expr • »(k, a)), a))), ":=", expr exists_unique_zsmul_near_of_pos' a_pos g],
  have [ident h_zero] [":", expr «expr = »(«expr - »(g, «expr • »(k, a)), 0)] [],
  { by_contra [ident h],
    have [ident h] [":", expr «expr ≤ »(a, «expr - »(g, «expr • »(k, a)))] [],
    { refine [expr a_min ⟨_, _⟩],
      { exact [expr add_subgroup.sub_mem H g_in (add_subgroup.zsmul_mem H a_in k)] },
      { exact [expr lt_of_le_of_ne nonneg (ne.symm h)] } },
    have [ident h'] [":", expr «expr¬ »(«expr ≤ »(a, «expr - »(g, «expr • »(k, a))))] [":=", expr not_le.mpr lt],
    contradiction },
  simp [] [] [] ["[", expr sub_eq_zero.mp h_zero, ",", expr add_subgroup.mem_closure_singleton, "]"] [] []
end

/-- Every subgroup of `ℤ` is cyclic. -/
theorem Int.subgroup_cyclic (H : AddSubgroup ℤ) : ∃ a, H = AddSubgroup.closure {a} :=
  by 
    cases' AddSubgroup.bot_or_exists_ne_zero H with h h
    ·
      use 0
      rw [h]
      exact add_subgroup.closure_singleton_zero.symm 
    let s := { g : ℤ | g ∈ H ∧ 0 < g }
    have h_bdd : ∀ g _ : g ∈ s, (0 : ℤ) ≤ g := fun _ h => le_of_ltₓ h.2
    obtain ⟨g₀, g₀_in, g₀_ne⟩ := h 
    obtain ⟨g₁, g₁_in, g₁_pos⟩ : ∃ g₁ : ℤ, g₁ ∈ H ∧ 0 < g₁
    ·
      cases' lt_or_gt_of_neₓ g₀_ne with Hg₀ Hg₀
      ·
        exact ⟨-g₀, H.neg_mem g₀_in, neg_pos.mpr Hg₀⟩
      ·
        exact ⟨g₀, g₀_in, Hg₀⟩
    obtain ⟨a, ha, ha'⟩ := Int.exists_least_of_bdd ⟨(0 : ℤ), h_bdd⟩ ⟨g₁, g₁_in, g₁_pos⟩
    exact ⟨a, AddSubgroup.cyclic_of_min ⟨ha, ha'⟩⟩

