import Mathbin.Algebra.BigOperators.Order
import Mathbin.Data.Nat.Totient
import Mathbin.GroupTheory.OrderOfElement
import Mathbin.Tactic.Group

/-!
# Cyclic groups

A group `G` is called cyclic if there exists an element `g : G` such that every element of `G` is of
the form `g ^ n` for some `n : ℕ`. This file only deals with the predicate on a group to be cyclic.
For the concrete cyclic group of order `n`, see `data.zmod.basic`.

## Main definitions

* `is_cyclic` is a predicate on a group stating that the group is cyclic.

## Main statements

* `is_cyclic_of_prime_card` proves that a finite group of prime order is cyclic.
* `is_simple_group_of_prime_card`, `is_simple_group.is_cyclic`,
  and `is_simple_group.prime_card` classify finite simple abelian groups.

## Tags

cyclic group
-/


universe u

variable {α : Type u} {a : α}

section Cyclic

open_locale BigOperators

attribute [local instance] setFintype

open Subgroup

/--  A group is called *cyclic* if it is generated by a single element. -/
class IsAddCyclic (α : Type u) [AddGroupₓ α] : Prop where
  exists_generator {} : ∃ g : α, ∀ x, x ∈ AddSubgroup.zmultiples g

/--  A group is called *cyclic* if it is generated by a single element. -/
@[to_additive IsAddCyclic]
class IsCyclic (α : Type u) [Groupₓ α] : Prop where
  exists_generator {} : ∃ g : α, ∀ x, x ∈ zpowers g

@[to_additive is_add_cyclic_of_subsingleton]
instance (priority := 100) is_cyclic_of_subsingleton [Groupₓ α] [Subsingleton α] : IsCyclic α :=
  ⟨⟨1, fun x => by
      rw [Subsingleton.elimₓ x 1]
      exact mem_zpowers 1⟩⟩

/--  A cyclic group is always commutative. This is not an `instance` because often we have a better
proof of `comm_group`. -/
@[to_additive
      "A cyclic group is always commutative. This is not an `instance` because often we have\n  a better proof of `add_comm_group`."]
def IsCyclic.commGroup [hg : Groupₓ α] [IsCyclic α] : CommGroupₓ α :=
  { hg with
    mul_comm := fun x y =>
      show (x*y) = y*x from
        let ⟨g, hg⟩ := IsCyclic.exists_generator α
        let ⟨n, hn⟩ := hg x
        let ⟨m, hm⟩ := hg y
        hm ▸ hn ▸ zpow_mul_comm _ _ _ }

variable [Groupₓ α]

@[to_additive MonoidAddHom.map_add_cyclic]
theorem MonoidHom.map_cyclic {G : Type _} [Groupₓ G] [h : IsCyclic G] (σ : G →* G) : ∃ m : ℤ, ∀ g : G, σ g = g ^ m := by
  obtain ⟨h, hG⟩ := IsCyclic.exists_generator G
  obtain ⟨m, hm⟩ := hG (σ h)
  use m
  intro g
  obtain ⟨n, rfl⟩ := hG g
  rw [MonoidHom.map_zpow, ← hm, ← zpow_mul, ← zpow_mul']

@[to_additive is_add_cyclic_of_order_of_eq_card]
theorem is_cyclic_of_order_of_eq_card [Fintype α] (x : α) (hx : orderOf x = Fintype.card α) : IsCyclic α := by
  classical
  use x
  simp_rw [← SetLike.mem_coe]
  rw [← Set.eq_univ_iff_forall]
  apply Set.eq_of_subset_of_card_le (Set.subset_univ _)
  rw [Fintype.card_congr (Equivₓ.Set.univ α), ← hx, order_eq_card_zpowers]

/--  A finite group of prime order is cyclic. -/
@[to_additive is_add_cyclic_of_prime_card]
theorem is_cyclic_of_prime_card {α : Type u} [Groupₓ α] [Fintype α] {p : ℕ} [hp : Fact p.prime]
    (h : Fintype.card α = p) : IsCyclic α :=
  ⟨by
    obtain ⟨g, hg⟩ : ∃ g : α, g ≠ 1
    exact
      Fintype.exists_ne_of_one_lt_card
        (by
          rw [h]
          exact hp.1.one_lt)
        1
    classical
    have : Fintype.card (Subgroup.zpowers g) ∣ p := by
      rw [← h]
      apply card_subgroup_dvd_card
    rw [Nat.dvd_prime hp.1] at this
    cases this
    ·
      rw [Fintype.card_eq_one_iff] at this
      cases' this with t ht
      suffices g = 1by
        contradiction
      have hgt :=
        ht
          ⟨g, by
            change g ∈ Subgroup.zpowers g
            exact Subgroup.mem_zpowers g⟩
      rw [← ht 1] at hgt
      change (⟨_, _⟩ : Subgroup.zpowers g) = ⟨_, _⟩ at hgt
      simpa using hgt
    ·
      use g
      intro x
      rw [← h] at this
      rw [Subgroup.eq_top_of_card_eq _ this]
      exact Subgroup.mem_top _⟩

@[to_additive add_order_of_eq_card_of_forall_mem_zmultiples]
theorem order_of_eq_card_of_forall_mem_zpowers [Fintype α] {g : α} (hx : ∀ x, x ∈ zpowers g) :
    orderOf g = Fintype.card α := by
  classical
  rw [← Fintype.card_congr (Equivₓ.Set.univ α), order_eq_card_zpowers]
  simp [hx]
  apply Fintype.card_of_finset'
  simp
  intro x
  exact hx x

@[to_additive Bot.is_add_cyclic]
instance Bot.is_cyclic {α : Type u} [Groupₓ α] : IsCyclic (⊥ : Subgroup α) :=
  ⟨⟨1, fun x => ⟨0, Subtype.eq $ Eq.symm (Subgroup.mem_bot.1 x.2)⟩⟩⟩

@[to_additive AddSubgroup.is_add_cyclic]
instance Subgroup.is_cyclic {α : Type u} [Groupₓ α] [IsCyclic α] (H : Subgroup α) : IsCyclic H := by
  have := Classical.propDecidable <;>
    exact
      let ⟨g, hg⟩ := IsCyclic.exists_generator α
      if hx : ∃ x : α, x ∈ H ∧ x ≠ (1 : α) then
        let ⟨x, hx₁, hx₂⟩ := hx
        let ⟨k, hk⟩ := hg x
        have hex : ∃ n : ℕ, 0 < n ∧ g ^ n ∈ H :=
          ⟨k.nat_abs,
            Nat.pos_of_ne_zeroₓ fun h =>
              hx₂ $ by
                rw [← hk, Int.eq_zero_of_nat_abs_eq_zero h, zpow_zero],
            match k, hk with
            | (k : ℕ), hk => by
              rw [Int.nat_abs_of_nat, ← zpow_coe_nat, hk] <;> exact hx₁
            | -[1+ k], hk => by
              rw [Int.nat_abs_of_neg_succ_of_nat, ← Subgroup.inv_mem_iff H] <;> simp_all ⟩
        ⟨⟨⟨g ^ Nat.findₓ hex, (Nat.find_specₓ hex).2⟩, fun ⟨x, hx⟩ =>
            let ⟨k, hk⟩ := hg x
            have hk₁ : (g ^ (Nat.findₓ hex : ℤ)*k / Nat.findₓ hex) ∈ zpowers (g ^ Nat.findₓ hex) :=
              ⟨k / Nat.findₓ hex, by
                rw [← zpow_coe_nat, zpow_mul]⟩
            have hk₂ : (g ^ (Nat.findₓ hex : ℤ)*k / Nat.findₓ hex) ∈ H := by
              rw [zpow_mul]
              apply H.zpow_mem
              exact_mod_cast (Nat.find_specₓ hex).2
            have hk₃ : g ^ (k % Nat.findₓ hex) ∈ H :=
              (Subgroup.mul_mem_cancel_right H hk₂).1 $ by
                rw [← zpow_add, Int.mod_add_div, hk] <;> exact hx
            have hk₄ : k % Nat.findₓ hex = (k % Nat.findₓ hex).natAbs := by
              rw [Int.nat_abs_of_nonneg (Int.mod_nonneg _ (Int.coe_nat_ne_zero_iff_pos.2 (Nat.find_specₓ hex).1))]
            have hk₅ : g ^ (k % Nat.findₓ hex).natAbs ∈ H := by
              rwa [← zpow_coe_nat, ← hk₄]
            have hk₆ : (k % (Nat.findₓ hex : ℤ)).natAbs = 0 :=
              by_contradiction fun h =>
                Nat.find_minₓ hex
                  (Int.coe_nat_lt.1 $ by
                    rw [← hk₄] <;> exact Int.mod_lt_of_pos _ (Int.coe_nat_pos.2 (Nat.find_specₓ hex).1))
                  ⟨Nat.pos_of_ne_zeroₓ h, hk₅⟩
            ⟨k / (Nat.findₓ hex : ℤ),
              Subtype.ext_iff_val.2
                (by
                  suffices (g ^ (Nat.findₓ hex : ℤ)*k / Nat.findₓ hex) = x by
                    simpa [zpow_mul]
                  rw [Int.mul_div_cancel' (Int.dvd_of_mod_eq_zero (Int.eq_zero_of_nat_abs_eq_zero hk₆)), hk])⟩⟩⟩
      else
        have : H = (⊥ : Subgroup α) :=
          Subgroup.ext $ fun x =>
            ⟨fun h => by
              simp at * <;> tauto, fun h => by
              rw [Subgroup.mem_bot.1 h] <;> exact H.one_mem⟩
        by
        clear _let_match <;> subst this <;> infer_instance

open Finset Nat

section Classical

open_locale Classical

-- ././Mathport/Syntax/Translate/Tactic/Lean3.lean:98:4: warning: unsupported: rw with cfg: { occs := occurrences.pos «expr[ , ]»([2, 3]) }
@[to_additive IsAddCyclic.card_pow_eq_one_le]
theorem IsCyclic.card_pow_eq_one_le [DecidableEq α] [Fintype α] [IsCyclic α] {n : ℕ} (hn0 : 0 < n) :
    (univ.filter fun a : α => a ^ n = 1).card ≤ n :=
  let ⟨g, hg⟩ := IsCyclic.exists_generator α
  calc
    (univ.filter fun a : α => a ^ n = 1).card ≤
      (zpowers (g ^ (Fintype.card α / gcd n (Fintype.card α))) : Set α).toFinset.card :=
    card_le_of_subset fun x hx =>
      let ⟨m, hm⟩ := show x ∈ Submonoid.powers g from mem_powers_iff_mem_zpowers.2 $ hg x
      Set.mem_to_finset.2
        ⟨(m / (Fintype.card α / gcd n (Fintype.card α)) : ℕ),
          have hgmn : (g ^ m*gcd n (Fintype.card α)) = 1 := by
            rw [pow_mulₓ, hm, ← pow_gcd_card_eq_one_iff] <;> exact (mem_filter.1 hx).2
          by
          rw [zpow_coe_nat, ← pow_mulₓ, Nat.mul_div_cancel_left', hm]
          refine' dvd_of_mul_dvd_mul_right (gcd_pos_of_pos_left (Fintype.card α) hn0) _
          conv => lhs rw [Nat.div_mul_cancelₓ (gcd_dvd_right _ _), ← order_of_eq_card_of_forall_mem_zpowers hg]
          exact order_of_dvd_of_pow_eq_one hgmn⟩
    _ ≤ n :=
    let ⟨m, hm⟩ := gcd_dvd_right n (Fintype.card α)
    have hm0 : 0 < m :=
      Nat.pos_of_ne_zeroₓ $ fun hm0 => by
        rw [hm0, mul_zero, Fintype.card_eq_zero_iff] at hm
        exact hm.elim' 1
    by
    rw [← Fintype.card_of_finset' _ fun _ => Set.mem_to_finset, ← order_eq_card_zpowers, order_of_pow g,
      order_of_eq_card_of_forall_mem_zpowers hg]
    rw [hm]
    rw [Nat.mul_div_cancel_leftₓ _ (gcd_pos_of_pos_left _ hn0), gcd_mul_left_left, hm, Nat.mul_div_cancelₓ _ hm0]
    exact le_of_dvd hn0 (gcd_dvd_left _ _)
    

end Classical

@[to_additive]
theorem IsCyclic.exists_monoid_generator [Fintype α] [IsCyclic α] : ∃ x : α, ∀ y : α, y ∈ Submonoid.powers x := by
  simp_rw [mem_powers_iff_mem_zpowers]
  exact IsCyclic.exists_generator α

section

variable [DecidableEq α] [Fintype α]

@[to_additive]
theorem IsCyclic.image_range_order_of (ha : ∀ x : α, x ∈ zpowers a) :
    Finset.image (fun i => a ^ i) (range (orderOf a)) = univ := by
  simp_rw [← SetLike.mem_coe]  at ha
  simp only [image_range_order_of, set.eq_univ_iff_forall.mpr ha]
  convert Set.to_finset_univ

@[to_additive]
theorem IsCyclic.image_range_card (ha : ∀ x : α, x ∈ zpowers a) :
    Finset.image (fun i => a ^ i) (range (Fintype.card α)) = univ := by
  rw [← order_of_eq_card_of_forall_mem_zpowers ha, IsCyclic.image_range_order_of ha]

end

section Totient

variable [DecidableEq α] [Fintype α] (hn : ∀ n : ℕ, 0 < n → (univ.filter fun a : α => a ^ n = 1).card ≤ n)

include hn

private theorem card_pow_eq_one_eq_order_of_aux (a : α) :
    (Finset.univ.filter fun b : α => b ^ orderOf a = 1).card = orderOf a :=
  le_antisymmₓ (hn _ (order_of_pos a))
    (calc orderOf a = @Fintype.card (zpowers a) (id _) := order_eq_card_zpowers
      _ ≤ @Fintype.card (↑univ.filter fun b : α => b ^ orderOf a = 1 : Set α) (Fintype.ofFinset _ fun _ => Iff.rfl) :=
      @Fintype.card_le_of_injective (zpowers a) (↑univ.filter fun b : α => b ^ orderOf a = 1 : Set α) (id _) (id _)
        (fun b =>
          ⟨b.1,
            mem_filter.2
              ⟨mem_univ _,
                let ⟨i, hi⟩ := b.2
                by
                rw [← hi, ← zpow_coe_nat, ← zpow_mul, mul_commₓ, zpow_mul, zpow_coe_nat, pow_order_of_eq_one,
                  one_zpow]⟩⟩)
        fun _ _ h => Subtype.eq (Subtype.mk.injₓ h)
      _ = (univ.filter fun b : α => b ^ orderOf a = 1).card := Fintype.card_of_finset _ _
      )

open_locale Nat

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers [] [] [(Command.private "private")] [] [] [])
 (Command.theorem
  "theorem"
  (Command.declId `card_order_of_eq_totient_aux₁ [])
  (Command.declSig
   []
   (Term.typeSpec
    ":"
    (Term.forall
     "∀"
     [(Term.implicitBinder "{" [`d] [":" (termℕ "ℕ")] "}")]
     ","
     (Term.arrow
      (Init.Core.«term_∣_» `d " ∣ " (Term.app `Fintype.card [`α]))
      "→"
      (Term.arrow
       («term_<_»
        (numLit "0")
        "<"
        (Term.proj
         (Term.app
          (Term.proj `univ "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
             "=>"
             («term_=_» (Term.app `orderOf [`a]) "=" `d)))])
         "."
         `card))
       "→"
       («term_=_»
        (Term.proj
         (Term.app
          (Term.proj `univ "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
             "=>"
             («term_=_» (Term.app `orderOf [`a]) "=" `d)))])
         "."
         `card)
        "="
        (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])))))))
  (Command.declValEqns
   (Term.matchAltsWhereDecls
    (Term.matchAlts
     [(Term.matchAlt
       "|"
       [(numLit "0")]
       "=>"
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`hd `hd0] [])]
         "=>"
         (Term.let
          "let"
          (Term.letDecl
           (Term.letPatDecl
            (Term.anonymousCtor "⟨" [`a "," `ha] "⟩")
            []
            []
            ":="
            (Term.app (Term.proj `card_pos "." (fieldIdx "1")) [`hd0])))
          []
          («term_$__»
           (Term.app
            `absurd
            [(Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`ha]) "." (fieldIdx "2"))])
           "$"
           («term_$__» `ne_of_gtₓ "$" (Term.app `order_of_pos [`a])))))))
      (Term.matchAlt
       "|"
       [(Init.Logic.«term_+_» `d "+" (numLit "1"))]
       "=>"
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`hd `hd0] [])]
         "=>"
         (Term.let
          "let"
          (Term.letDecl
           (Term.letPatDecl
            (Term.anonymousCtor "⟨" [`a "," `ha] "⟩")
            []
            []
            ":="
            (Term.app (Term.proj `card_pos "." (fieldIdx "1")) [`hd0])))
          []
          (Term.have
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`ha []]
             [(Term.typeSpec ":" («term_=_» (Term.app `orderOf [`a]) "=" `d.succ))]
             ":="
             (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`ha]) "." (fieldIdx "2"))))
           []
           (Term.have
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`h []]
              [(Term.typeSpec
                ":"
                («term_=_»
                 (Algebra.BigOperators.Basic.«term∑_in_,_»
                  "∑"
                  (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                  " in "
                  (Term.app
                   (Term.proj (Term.app `range [`d.succ]) "." `filter)
                   [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
                  ", "
                  (Term.proj
                   (Term.app
                    (Term.proj `univ "." `filter)
                    [(Term.fun
                      "fun"
                      (Term.basicFun
                       [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                       "=>"
                       («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
                   "."
                   `card))
                 "="
                 (Algebra.BigOperators.Basic.«term∑_in_,_»
                  "∑"
                  (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                  " in "
                  (Term.app
                   (Term.proj (Term.app `range [`d.succ]) "." `filter)
                   [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
                  ", "
                  (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))]
              ":="
              (Term.app
               `Finset.sum_congr
               [`rfl
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`m `hm] [])]
                  "=>"
                  (Term.have
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     [`hmd []]
                     [(Term.typeSpec ":" («term_<_» `m "<" `d.succ))]
                     ":="
                     (Term.app
                      (Term.proj `mem_range "." (fieldIdx "1"))
                      [(Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "1"))])))
                   []
                   (Term.have
                    "have"
                    (Term.haveDecl
                     (Term.haveIdDecl
                      [`hm []]
                      [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `d.succ))]
                      ":="
                      (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "2"))))
                    []
                    (Term.app
                     `card_order_of_eq_totient_aux₁
                     [(Term.app `hm.trans [`hd])
                      (Term.app
                       (Term.proj `Finset.card_pos "." (fieldIdx "2"))
                       [(Term.anonymousCtor
                         "⟨"
                         [(«term_^_» `a "^" («term_/_» `d.succ "/" `m))
                          ","
                          (Term.app
                           (Term.proj `mem_filter "." (fieldIdx "2"))
                           [(Term.anonymousCtor
                             "⟨"
                             [(Term.app `mem_univ [(Term.hole "_")])
                              ","
                              (Term.byTactic
                               "by"
                               (Tactic.tacticSeq
                                (Tactic.tacticSeq1Indented
                                 [(group
                                   (Tactic.rwSeq
                                    "rw"
                                    []
                                    (Tactic.rwRuleSeq
                                     "["
                                     [(Tactic.rwRule [] (Term.app `order_of_pow [`a]))
                                      ","
                                      (Tactic.rwRule [] `ha)
                                      ","
                                      (Tactic.rwRule [] (Term.app `gcd_eq_right [(Term.app `div_dvd_of_dvd [`hm])]))
                                      ","
                                      (Tactic.rwRule
                                       []
                                       (Term.app `Nat.div_div_self [`hm (Term.app `succ_pos [(Term.hole "_")])]))]
                                     "]")
                                    [])
                                   [])])))]
                             "⟩")])]
                         "⟩")])])))))])))
            []
            (Term.have
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hinsert []]
               [(Term.typeSpec
                 ":"
                 («term_=_»
                  (Term.app
                   `insert
                   [`d.succ
                    (Term.app
                     (Term.proj (Term.app `range [`d.succ]) "." `filter)
                     [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])])
                  "="
                  (Term.app
                   (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
                   [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
               ":="
               («term_$__»
                `Finset.ext
                "$"
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`x] [])]
                  "=>"
                  (Term.anonymousCtor
                   "⟨"
                   [(Term.fun
                     "fun"
                     (Term.basicFun
                      [(Term.simpleBinder [`h] [])]
                      "=>"
                      (Term.app
                       (Term.proj (Term.app (Term.proj `mem_insert "." (fieldIdx "1")) [`h]) "." `elim)
                       [(Term.fun
                         "fun"
                         (Term.basicFun
                          [(Term.simpleBinder [`h] [])]
                          "=>"
                          (Term.byTactic
                           "by"
                           (Tactic.tacticSeq
                            (Tactic.tacticSeq1Indented
                             [(group
                               (Tactic.simp
                                "simp"
                                []
                                []
                                ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `range_succ)] "]"]
                                [])
                               [])])))))
                        (Term.byTactic
                         "by"
                         (Tactic.tacticSeq
                          (Tactic.tacticSeq1Indented
                           [(group
                             (Tactic.«tactic_<;>_»
                              (Tactic.clear "clear" [`_let_match])
                              "<;>"
                              (Tactic.«tactic_<;>_»
                               (Tactic.simp "simp" [] [] ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"] [])
                               "<;>"
                               (Tactic.tauto "tauto" [])))
                             [])])))])))
                    ","
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(group
                         (Tactic.«tactic_<;>_»
                          (Tactic.clear "clear" [`_let_match])
                          "<;>"
                          (Tactic.«tactic_<;>_»
                           (Tactic.simp
                            "simp"
                            ["("
                             "config"
                             ":="
                             (Term.structInst
                              "{"
                              []
                              [(group
                                (Term.structInstField
                                 (Term.structInstLVal `contextual [])
                                 ":="
                                 `Bool.true._@._internal._hyg.0)
                                [])]
                              (Term.optEllipsis [])
                              []
                              "}")
                             ")"]
                            []
                            ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"]
                            [])
                           "<;>"
                           (Tactic.tauto "tauto" [])))
                         [])])))]
                   "⟩"))))))
             []
             (Term.have
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hinsert₁ []]
                [(Term.typeSpec
                  ":"
                  (Init.Core.«term_∉_»
                   `d.succ
                   " ∉ "
                   (Term.app
                    (Term.proj (Term.app `range [`d.succ]) "." `filter)
                    [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.simp
                      "simp"
                      []
                      []
                      ["["
                       [(Tactic.simpLemma [] [] `mem_range)
                        ","
                        (Tactic.simpLemma [] [] `zero_le_one)
                        ","
                        (Tactic.simpLemma [] [] `le_succ)]
                       "]"]
                      [])
                     [])])))))
              []
              (Term.app
               (Term.proj
                (Term.app
                 `add_left_injₓ
                 [(Algebra.BigOperators.Basic.«term∑_in_,_»
                   "∑"
                   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                   " in "
                   (Term.app
                    (Term.proj (Term.app `range [`d.succ]) "." `filter)
                    [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
                   ", "
                   (Term.proj
                    (Term.app
                     (Term.proj `univ "." `filter)
                     [(Term.fun
                       "fun"
                       (Term.basicFun
                        [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                        "=>"
                        («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
                    "."
                    `card))])
                "."
                (fieldIdx "1"))
               [(calc
                 "calc"
                 [(calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    (Algebra.BigOperators.Basic.«term∑_in_,_»
                     "∑"
                     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                     " in "
                     (Term.app
                      `insert
                      [`d.succ
                       (Term.app
                        `filter
                        [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
                     ", "
                     (Term.proj
                      (Term.app
                       (Term.proj `univ "." `filter)
                       [(Term.fun
                         "fun"
                         (Term.basicFun
                          [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                          "=>"
                          («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
                      "."
                      `card)))
                   ":="
                   (Term.app
                    `Eq.symm
                    [(Term.app
                      `Finset.sum_insert
                      [(Term.byTactic
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(group
                            (Tactic.simp
                             "simp"
                             []
                             []
                             ["["
                              [(Tactic.simpLemma [] [] `mem_range)
                               ","
                               (Tactic.simpLemma [] [] `zero_le_one)
                               ","
                               (Tactic.simpLemma [] [] `le_succ)]
                              "]"]
                             [])
                            [])])))])]))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    (Algebra.BigOperators.Basic.«term∑_in_,_»
                     "∑"
                     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                     " in "
                     (Term.app
                      (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
                      [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
                     ", "
                     (Term.proj
                      (Term.app
                       (Term.proj `univ "." `filter)
                       [(Term.fun
                         "fun"
                         (Term.basicFun
                          [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                          "=>"
                          («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
                      "."
                      `card)))
                   ":="
                   (Term.app
                    `sum_congr
                    [`hinsert
                     (Term.fun
                      "fun"
                      (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    (Term.proj
                     (Term.app
                      (Term.proj `univ "." `filter)
                      [(Term.fun
                        "fun"
                        (Term.basicFun
                         [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                         "=>"
                         («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
                     "."
                     `card))
                   ":="
                   (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
                  (calcStep
                   («term_=_»
                    (Term.hole "_")
                    "="
                    (Algebra.BigOperators.Basic.«term∑_in_,_»
                     "∑"
                     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                     " in "
                     (Term.app
                      (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
                      [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
                     ", "
                     (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
                   ":="
                   (Term.subst
                    `ha
                    "▸"
                    [(Term.subst
                      (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
                      "▸"
                      [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
                  (calcStep
                   («term_=_» (Term.hole "_") "=" (Term.hole "_"))
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(group
                        (Tactic.«tactic_<;>_»
                         (Tactic.rwSeq
                          "rw"
                          []
                          (Tactic.rwRuleSeq
                           "["
                           [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
                           "]")
                          [])
                         "<;>"
                         (Tactic.exact
                          "exact"
                          (Term.app
                           `Finset.sum_congr
                           [`hinsert.symm
                            (Term.fun
                             "fun"
                             (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
                        [])]))))])])))))))))])
    []))
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValEqns', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValEqns', expected 'Lean.Parser.Command.declValSimple'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValEqns', expected 'Lean.Parser.Command.declValEqns.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.matchAltsWhereDecls', expected 'Lean.Parser.Term.matchAltsWhereDecls.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.matchAlts', expected 'Lean.Parser.Term.matchAlts.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.matchAlt', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.matchAlt', expected 'Lean.Parser.Term.matchAlt.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`hd `hd0] [])]
    "=>"
    (Term.let
     "let"
     (Term.letDecl
      (Term.letPatDecl
       (Term.anonymousCtor "⟨" [`a "," `ha] "⟩")
       []
       []
       ":="
       (Term.app (Term.proj `card_pos "." (fieldIdx "1")) [`hd0])))
     []
     (Term.have
      "have"
      (Term.haveDecl
       (Term.haveIdDecl
        [`ha []]
        [(Term.typeSpec ":" («term_=_» (Term.app `orderOf [`a]) "=" `d.succ))]
        ":="
        (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`ha]) "." (fieldIdx "2"))))
      []
      (Term.have
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h []]
         [(Term.typeSpec
           ":"
           («term_=_»
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              (Term.proj (Term.app `range [`d.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
             ", "
             (Term.proj
              (Term.app
               (Term.proj `univ "." `filter)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                  "=>"
                  («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
              "."
              `card))
            "="
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              (Term.proj (Term.app `range [`d.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
             ", "
             (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))]
         ":="
         (Term.app
          `Finset.sum_congr
          [`rfl
           (Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`m `hm] [])]
             "=>"
             (Term.have
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hmd []]
                [(Term.typeSpec ":" («term_<_» `m "<" `d.succ))]
                ":="
                (Term.app
                 (Term.proj `mem_range "." (fieldIdx "1"))
                 [(Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "1"))])))
              []
              (Term.have
               "have"
               (Term.haveDecl
                (Term.haveIdDecl
                 [`hm []]
                 [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `d.succ))]
                 ":="
                 (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "2"))))
               []
               (Term.app
                `card_order_of_eq_totient_aux₁
                [(Term.app `hm.trans [`hd])
                 (Term.app
                  (Term.proj `Finset.card_pos "." (fieldIdx "2"))
                  [(Term.anonymousCtor
                    "⟨"
                    [(«term_^_» `a "^" («term_/_» `d.succ "/" `m))
                     ","
                     (Term.app
                      (Term.proj `mem_filter "." (fieldIdx "2"))
                      [(Term.anonymousCtor
                        "⟨"
                        [(Term.app `mem_univ [(Term.hole "_")])
                         ","
                         (Term.byTactic
                          "by"
                          (Tactic.tacticSeq
                           (Tactic.tacticSeq1Indented
                            [(group
                              (Tactic.rwSeq
                               "rw"
                               []
                               (Tactic.rwRuleSeq
                                "["
                                [(Tactic.rwRule [] (Term.app `order_of_pow [`a]))
                                 ","
                                 (Tactic.rwRule [] `ha)
                                 ","
                                 (Tactic.rwRule [] (Term.app `gcd_eq_right [(Term.app `div_dvd_of_dvd [`hm])]))
                                 ","
                                 (Tactic.rwRule
                                  []
                                  (Term.app `Nat.div_div_self [`hm (Term.app `succ_pos [(Term.hole "_")])]))]
                                "]")
                               [])
                              [])])))]
                        "⟩")])]
                    "⟩")])])))))])))
       []
       (Term.have
        "have"
        (Term.haveDecl
         (Term.haveIdDecl
          [`hinsert []]
          [(Term.typeSpec
            ":"
            («term_=_»
             (Term.app
              `insert
              [`d.succ
               (Term.app
                (Term.proj (Term.app `range [`d.succ]) "." `filter)
                [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])])
             "="
             (Term.app
              (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
          ":="
          («term_$__»
           `Finset.ext
           "$"
           (Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`x] [])]
             "=>"
             (Term.anonymousCtor
              "⟨"
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`h] [])]
                 "=>"
                 (Term.app
                  (Term.proj (Term.app (Term.proj `mem_insert "." (fieldIdx "1")) [`h]) "." `elim)
                  [(Term.fun
                    "fun"
                    (Term.basicFun
                     [(Term.simpleBinder [`h] [])]
                     "=>"
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(group
                          (Tactic.simp
                           "simp"
                           []
                           []
                           ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `range_succ)] "]"]
                           [])
                          [])])))))
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(group
                        (Tactic.«tactic_<;>_»
                         (Tactic.clear "clear" [`_let_match])
                         "<;>"
                         (Tactic.«tactic_<;>_»
                          (Tactic.simp "simp" [] [] ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"] [])
                          "<;>"
                          (Tactic.tauto "tauto" [])))
                        [])])))])))
               ","
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.«tactic_<;>_»
                     (Tactic.clear "clear" [`_let_match])
                     "<;>"
                     (Tactic.«tactic_<;>_»
                      (Tactic.simp
                       "simp"
                       ["("
                        "config"
                        ":="
                        (Term.structInst
                         "{"
                         []
                         [(group
                           (Term.structInstField
                            (Term.structInstLVal `contextual [])
                            ":="
                            `Bool.true._@._internal._hyg.0)
                           [])]
                         (Term.optEllipsis [])
                         []
                         "}")
                        ")"]
                       []
                       ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"]
                       [])
                      "<;>"
                      (Tactic.tauto "tauto" [])))
                    [])])))]
              "⟩"))))))
        []
        (Term.have
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hinsert₁ []]
           [(Term.typeSpec
             ":"
             (Init.Core.«term_∉_»
              `d.succ
              " ∉ "
              (Term.app
               (Term.proj (Term.app `range [`d.succ]) "." `filter)
               [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(group
                (Tactic.simp
                 "simp"
                 []
                 []
                 ["["
                  [(Tactic.simpLemma [] [] `mem_range)
                   ","
                   (Tactic.simpLemma [] [] `zero_le_one)
                   ","
                   (Tactic.simpLemma [] [] `le_succ)]
                  "]"]
                 [])
                [])])))))
         []
         (Term.app
          (Term.proj
           (Term.app
            `add_left_injₓ
            [(Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               (Term.proj (Term.app `range [`d.succ]) "." `filter)
               [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
              ", "
              (Term.proj
               (Term.app
                (Term.proj `univ "." `filter)
                [(Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                   "=>"
                   («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
               "."
               `card))])
           "."
           (fieldIdx "1"))
          [(calc
            "calc"
            [(calcStep
              («term_=_»
               (Term.hole "_")
               "="
               (Algebra.BigOperators.Basic.«term∑_in_,_»
                "∑"
                (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                " in "
                (Term.app
                 `insert
                 [`d.succ
                  (Term.app `filter [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
                ", "
                (Term.proj
                 (Term.app
                  (Term.proj `univ "." `filter)
                  [(Term.fun
                    "fun"
                    (Term.basicFun
                     [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                     "=>"
                     («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
                 "."
                 `card)))
              ":="
              (Term.app
               `Eq.symm
               [(Term.app
                 `Finset.sum_insert
                 [(Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(group
                       (Tactic.simp
                        "simp"
                        []
                        []
                        ["["
                         [(Tactic.simpLemma [] [] `mem_range)
                          ","
                          (Tactic.simpLemma [] [] `zero_le_one)
                          ","
                          (Tactic.simpLemma [] [] `le_succ)]
                         "]"]
                        [])
                       [])])))])]))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               (Algebra.BigOperators.Basic.«term∑_in_,_»
                "∑"
                (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                " in "
                (Term.app
                 (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
                 [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
                ", "
                (Term.proj
                 (Term.app
                  (Term.proj `univ "." `filter)
                  [(Term.fun
                    "fun"
                    (Term.basicFun
                     [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                     "=>"
                     («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
                 "."
                 `card)))
              ":="
              (Term.app
               `sum_congr
               [`hinsert
                (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               (Term.proj
                (Term.app
                 (Term.proj `univ "." `filter)
                 [(Term.fun
                   "fun"
                   (Term.basicFun
                    [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                    "=>"
                    («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
                "."
                `card))
              ":="
              (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
             (calcStep
              («term_=_»
               (Term.hole "_")
               "="
               (Algebra.BigOperators.Basic.«term∑_in_,_»
                "∑"
                (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                " in "
                (Term.app
                 (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
                 [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
                ", "
                (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
              ":="
              (Term.subst
               `ha
               "▸"
               [(Term.subst
                 (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
                 "▸"
                 [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
             (calcStep
              («term_=_» (Term.hole "_") "=" (Term.hole "_"))
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.«tactic_<;>_»
                    (Tactic.rwSeq
                     "rw"
                     []
                     (Tactic.rwRuleSeq
                      "["
                      [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
                      "]")
                     [])
                    "<;>"
                    (Tactic.exact
                     "exact"
                     (Term.app
                      `Finset.sum_congr
                      [`hinsert.symm
                       (Term.fun
                        "fun"
                        (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
                   [])]))))])]))))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.let
   "let"
   (Term.letDecl
    (Term.letPatDecl
     (Term.anonymousCtor "⟨" [`a "," `ha] "⟩")
     []
     []
     ":="
     (Term.app (Term.proj `card_pos "." (fieldIdx "1")) [`hd0])))
   []
   (Term.have
    "have"
    (Term.haveDecl
     (Term.haveIdDecl
      [`ha []]
      [(Term.typeSpec ":" («term_=_» (Term.app `orderOf [`a]) "=" `d.succ))]
      ":="
      (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`ha]) "." (fieldIdx "2"))))
    []
    (Term.have
     "have"
     (Term.haveDecl
      (Term.haveIdDecl
       [`h []]
       [(Term.typeSpec
         ":"
         («term_=_»
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj (Term.app `range [`d.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
           ", "
           (Term.proj
            (Term.app
             (Term.proj `univ "." `filter)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                "=>"
                («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
            "."
            `card))
          "="
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj (Term.app `range [`d.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
           ", "
           (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))]
       ":="
       (Term.app
        `Finset.sum_congr
        [`rfl
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`m `hm] [])]
           "=>"
           (Term.have
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hmd []]
              [(Term.typeSpec ":" («term_<_» `m "<" `d.succ))]
              ":="
              (Term.app
               (Term.proj `mem_range "." (fieldIdx "1"))
               [(Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "1"))])))
            []
            (Term.have
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hm []]
               [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `d.succ))]
               ":="
               (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "2"))))
             []
             (Term.app
              `card_order_of_eq_totient_aux₁
              [(Term.app `hm.trans [`hd])
               (Term.app
                (Term.proj `Finset.card_pos "." (fieldIdx "2"))
                [(Term.anonymousCtor
                  "⟨"
                  [(«term_^_» `a "^" («term_/_» `d.succ "/" `m))
                   ","
                   (Term.app
                    (Term.proj `mem_filter "." (fieldIdx "2"))
                    [(Term.anonymousCtor
                      "⟨"
                      [(Term.app `mem_univ [(Term.hole "_")])
                       ","
                       (Term.byTactic
                        "by"
                        (Tactic.tacticSeq
                         (Tactic.tacticSeq1Indented
                          [(group
                            (Tactic.rwSeq
                             "rw"
                             []
                             (Tactic.rwRuleSeq
                              "["
                              [(Tactic.rwRule [] (Term.app `order_of_pow [`a]))
                               ","
                               (Tactic.rwRule [] `ha)
                               ","
                               (Tactic.rwRule [] (Term.app `gcd_eq_right [(Term.app `div_dvd_of_dvd [`hm])]))
                               ","
                               (Tactic.rwRule
                                []
                                (Term.app `Nat.div_div_self [`hm (Term.app `succ_pos [(Term.hole "_")])]))]
                              "]")
                             [])
                            [])])))]
                      "⟩")])]
                  "⟩")])])))))])))
     []
     (Term.have
      "have"
      (Term.haveDecl
       (Term.haveIdDecl
        [`hinsert []]
        [(Term.typeSpec
          ":"
          («term_=_»
           (Term.app
            `insert
            [`d.succ
             (Term.app
              (Term.proj (Term.app `range [`d.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])])
           "="
           (Term.app
            (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
        ":="
        («term_$__»
         `Finset.ext
         "$"
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`x] [])]
           "=>"
           (Term.anonymousCtor
            "⟨"
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`h] [])]
               "=>"
               (Term.app
                (Term.proj (Term.app (Term.proj `mem_insert "." (fieldIdx "1")) [`h]) "." `elim)
                [(Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`h] [])]
                   "=>"
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(group
                        (Tactic.simp
                         "simp"
                         []
                         []
                         ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `range_succ)] "]"]
                         [])
                        [])])))))
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(group
                      (Tactic.«tactic_<;>_»
                       (Tactic.clear "clear" [`_let_match])
                       "<;>"
                       (Tactic.«tactic_<;>_»
                        (Tactic.simp "simp" [] [] ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"] [])
                        "<;>"
                        (Tactic.tauto "tauto" [])))
                      [])])))])))
             ","
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(group
                  (Tactic.«tactic_<;>_»
                   (Tactic.clear "clear" [`_let_match])
                   "<;>"
                   (Tactic.«tactic_<;>_»
                    (Tactic.simp
                     "simp"
                     ["("
                      "config"
                      ":="
                      (Term.structInst
                       "{"
                       []
                       [(group
                         (Term.structInstField (Term.structInstLVal `contextual []) ":=" `Bool.true._@._internal._hyg.0)
                         [])]
                       (Term.optEllipsis [])
                       []
                       "}")
                      ")"]
                     []
                     ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"]
                     [])
                    "<;>"
                    (Tactic.tauto "tauto" [])))
                  [])])))]
            "⟩"))))))
      []
      (Term.have
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`hinsert₁ []]
         [(Term.typeSpec
           ":"
           (Init.Core.«term_∉_»
            `d.succ
            " ∉ "
            (Term.app
             (Term.proj (Term.app `range [`d.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group
              (Tactic.simp
               "simp"
               []
               []
               ["["
                [(Tactic.simpLemma [] [] `mem_range)
                 ","
                 (Tactic.simpLemma [] [] `zero_le_one)
                 ","
                 (Tactic.simpLemma [] [] `le_succ)]
                "]"]
               [])
              [])])))))
       []
       (Term.app
        (Term.proj
         (Term.app
          `add_left_injₓ
          [(Algebra.BigOperators.Basic.«term∑_in_,_»
            "∑"
            (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
            " in "
            (Term.app
             (Term.proj (Term.app `range [`d.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
            ", "
            (Term.proj
             (Term.app
              (Term.proj `univ "." `filter)
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                 "=>"
                 («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
             "."
             `card))])
         "."
         (fieldIdx "1"))
        [(calc
          "calc"
          [(calcStep
            («term_=_»
             (Term.hole "_")
             "="
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               `insert
               [`d.succ
                (Term.app `filter [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
              ", "
              (Term.proj
               (Term.app
                (Term.proj `univ "." `filter)
                [(Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                   "=>"
                   («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
               "."
               `card)))
            ":="
            (Term.app
             `Eq.symm
             [(Term.app
               `Finset.sum_insert
               [(Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.simp
                      "simp"
                      []
                      []
                      ["["
                       [(Tactic.simpLemma [] [] `mem_range)
                        ","
                        (Tactic.simpLemma [] [] `zero_le_one)
                        ","
                        (Tactic.simpLemma [] [] `le_succ)]
                       "]"]
                      [])
                     [])])))])]))
           (calcStep
            («term_=_»
             (Term.hole "_")
             "="
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
               [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
              ", "
              (Term.proj
               (Term.app
                (Term.proj `univ "." `filter)
                [(Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                   "=>"
                   («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
               "."
               `card)))
            ":="
            (Term.app
             `sum_congr
             [`hinsert
              (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
           (calcStep
            («term_=_»
             (Term.hole "_")
             "="
             (Term.proj
              (Term.app
               (Term.proj `univ "." `filter)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                  "=>"
                  («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
              "."
              `card))
            ":="
            (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
           (calcStep
            («term_=_»
             (Term.hole "_")
             "="
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
               [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
              ", "
              (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
            ":="
            (Term.subst
             `ha
             "▸"
             [(Term.subst
               (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
               "▸"
               [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
           (calcStep
            («term_=_» (Term.hole "_") "=" (Term.hole "_"))
            ":="
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(group
                 (Tactic.«tactic_<;>_»
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
                    "]")
                   [])
                  "<;>"
                  (Tactic.exact
                   "exact"
                   (Term.app
                    `Finset.sum_congr
                    [`hinsert.symm
                     (Term.fun
                      "fun"
                      (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
                 [])]))))])]))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.let', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.let', expected 'Lean.Parser.Term.let.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.have
   "have"
   (Term.haveDecl
    (Term.haveIdDecl
     [`ha []]
     [(Term.typeSpec ":" («term_=_» (Term.app `orderOf [`a]) "=" `d.succ))]
     ":="
     (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`ha]) "." (fieldIdx "2"))))
   []
   (Term.have
    "have"
    (Term.haveDecl
     (Term.haveIdDecl
      [`h []]
      [(Term.typeSpec
        ":"
        («term_=_»
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj (Term.app `range [`d.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
          ", "
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
           "."
           `card))
         "="
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj (Term.app `range [`d.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
          ", "
          (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))]
      ":="
      (Term.app
       `Finset.sum_congr
       [`rfl
        (Term.fun
         "fun"
         (Term.basicFun
          [(Term.simpleBinder [`m `hm] [])]
          "=>"
          (Term.have
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hmd []]
             [(Term.typeSpec ":" («term_<_» `m "<" `d.succ))]
             ":="
             (Term.app
              (Term.proj `mem_range "." (fieldIdx "1"))
              [(Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "1"))])))
           []
           (Term.have
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hm []]
              [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `d.succ))]
              ":="
              (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "2"))))
            []
            (Term.app
             `card_order_of_eq_totient_aux₁
             [(Term.app `hm.trans [`hd])
              (Term.app
               (Term.proj `Finset.card_pos "." (fieldIdx "2"))
               [(Term.anonymousCtor
                 "⟨"
                 [(«term_^_» `a "^" («term_/_» `d.succ "/" `m))
                  ","
                  (Term.app
                   (Term.proj `mem_filter "." (fieldIdx "2"))
                   [(Term.anonymousCtor
                     "⟨"
                     [(Term.app `mem_univ [(Term.hole "_")])
                      ","
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(group
                           (Tactic.rwSeq
                            "rw"
                            []
                            (Tactic.rwRuleSeq
                             "["
                             [(Tactic.rwRule [] (Term.app `order_of_pow [`a]))
                              ","
                              (Tactic.rwRule [] `ha)
                              ","
                              (Tactic.rwRule [] (Term.app `gcd_eq_right [(Term.app `div_dvd_of_dvd [`hm])]))
                              ","
                              (Tactic.rwRule
                               []
                               (Term.app `Nat.div_div_self [`hm (Term.app `succ_pos [(Term.hole "_")])]))]
                             "]")
                            [])
                           [])])))]
                     "⟩")])]
                 "⟩")])])))))])))
    []
    (Term.have
     "have"
     (Term.haveDecl
      (Term.haveIdDecl
       [`hinsert []]
       [(Term.typeSpec
         ":"
         («term_=_»
          (Term.app
           `insert
           [`d.succ
            (Term.app
             (Term.proj (Term.app `range [`d.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])])
          "="
          (Term.app
           (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
       ":="
       («term_$__»
        `Finset.ext
        "$"
        (Term.fun
         "fun"
         (Term.basicFun
          [(Term.simpleBinder [`x] [])]
          "=>"
          (Term.anonymousCtor
           "⟨"
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`h] [])]
              "=>"
              (Term.app
               (Term.proj (Term.app (Term.proj `mem_insert "." (fieldIdx "1")) [`h]) "." `elim)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`h] [])]
                  "=>"
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(group
                       (Tactic.simp
                        "simp"
                        []
                        []
                        ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `range_succ)] "]"]
                        [])
                       [])])))))
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.«tactic_<;>_»
                      (Tactic.clear "clear" [`_let_match])
                      "<;>"
                      (Tactic.«tactic_<;>_»
                       (Tactic.simp "simp" [] [] ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"] [])
                       "<;>"
                       (Tactic.tauto "tauto" [])))
                     [])])))])))
            ","
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(group
                 (Tactic.«tactic_<;>_»
                  (Tactic.clear "clear" [`_let_match])
                  "<;>"
                  (Tactic.«tactic_<;>_»
                   (Tactic.simp
                    "simp"
                    ["("
                     "config"
                     ":="
                     (Term.structInst
                      "{"
                      []
                      [(group
                        (Term.structInstField (Term.structInstLVal `contextual []) ":=" `Bool.true._@._internal._hyg.0)
                        [])]
                      (Term.optEllipsis [])
                      []
                      "}")
                     ")"]
                    []
                    ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"]
                    [])
                   "<;>"
                   (Tactic.tauto "tauto" [])))
                 [])])))]
           "⟩"))))))
     []
     (Term.have
      "have"
      (Term.haveDecl
       (Term.haveIdDecl
        [`hinsert₁ []]
        [(Term.typeSpec
          ":"
          (Init.Core.«term_∉_»
           `d.succ
           " ∉ "
           (Term.app
            (Term.proj (Term.app `range [`d.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
        ":="
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(group
             (Tactic.simp
              "simp"
              []
              []
              ["["
               [(Tactic.simpLemma [] [] `mem_range)
                ","
                (Tactic.simpLemma [] [] `zero_le_one)
                ","
                (Tactic.simpLemma [] [] `le_succ)]
               "]"]
              [])
             [])])))))
      []
      (Term.app
       (Term.proj
        (Term.app
         `add_left_injₓ
         [(Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj (Term.app `range [`d.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
           ", "
           (Term.proj
            (Term.app
             (Term.proj `univ "." `filter)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                "=>"
                («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
            "."
            `card))])
        "."
        (fieldIdx "1"))
       [(calc
         "calc"
         [(calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              `insert
              [`d.succ
               (Term.app `filter [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
             ", "
             (Term.proj
              (Term.app
               (Term.proj `univ "." `filter)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                  "=>"
                  («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
              "."
              `card)))
           ":="
           (Term.app
            `Eq.symm
            [(Term.app
              `Finset.sum_insert
              [(Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.simp
                     "simp"
                     []
                     []
                     ["["
                      [(Tactic.simpLemma [] [] `mem_range)
                       ","
                       (Tactic.simpLemma [] [] `zero_le_one)
                       ","
                       (Tactic.simpLemma [] [] `le_succ)]
                      "]"]
                     [])
                    [])])))])]))
          (calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
             ", "
             (Term.proj
              (Term.app
               (Term.proj `univ "." `filter)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                  "=>"
                  («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
              "."
              `card)))
           ":="
           (Term.app
            `sum_congr
            [`hinsert
             (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
          (calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Term.proj
             (Term.app
              (Term.proj `univ "." `filter)
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                 "=>"
                 («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
             "."
             `card))
           ":="
           (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
          (calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
             ", "
             (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
           ":="
           (Term.subst
            `ha
            "▸"
            [(Term.subst
              (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
              "▸"
              [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
          (calcStep
           («term_=_» (Term.hole "_") "=" (Term.hole "_"))
           ":="
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(group
                (Tactic.«tactic_<;>_»
                 (Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq
                   "["
                   [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
                   "]")
                  [])
                 "<;>"
                 (Tactic.exact
                  "exact"
                  (Term.app
                   `Finset.sum_congr
                   [`hinsert.symm
                    (Term.fun
                     "fun"
                     (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
                [])]))))])])))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'Lean.Parser.Term.have.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.have
   "have"
   (Term.haveDecl
    (Term.haveIdDecl
     [`h []]
     [(Term.typeSpec
       ":"
       («term_=_»
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          (Term.proj (Term.app `range [`d.succ]) "." `filter)
          [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
         ", "
         (Term.proj
          (Term.app
           (Term.proj `univ "." `filter)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
              "=>"
              («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
          "."
          `card))
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          (Term.proj (Term.app `range [`d.succ]) "." `filter)
          [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
         ", "
         (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))]
     ":="
     (Term.app
      `Finset.sum_congr
      [`rfl
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`m `hm] [])]
         "=>"
         (Term.have
          "have"
          (Term.haveDecl
           (Term.haveIdDecl
            [`hmd []]
            [(Term.typeSpec ":" («term_<_» `m "<" `d.succ))]
            ":="
            (Term.app
             (Term.proj `mem_range "." (fieldIdx "1"))
             [(Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "1"))])))
          []
          (Term.have
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hm []]
             [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `d.succ))]
             ":="
             (Term.proj (Term.app (Term.proj `mem_filter "." (fieldIdx "1")) [`hm]) "." (fieldIdx "2"))))
           []
           (Term.app
            `card_order_of_eq_totient_aux₁
            [(Term.app `hm.trans [`hd])
             (Term.app
              (Term.proj `Finset.card_pos "." (fieldIdx "2"))
              [(Term.anonymousCtor
                "⟨"
                [(«term_^_» `a "^" («term_/_» `d.succ "/" `m))
                 ","
                 (Term.app
                  (Term.proj `mem_filter "." (fieldIdx "2"))
                  [(Term.anonymousCtor
                    "⟨"
                    [(Term.app `mem_univ [(Term.hole "_")])
                     ","
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(group
                          (Tactic.rwSeq
                           "rw"
                           []
                           (Tactic.rwRuleSeq
                            "["
                            [(Tactic.rwRule [] (Term.app `order_of_pow [`a]))
                             ","
                             (Tactic.rwRule [] `ha)
                             ","
                             (Tactic.rwRule [] (Term.app `gcd_eq_right [(Term.app `div_dvd_of_dvd [`hm])]))
                             ","
                             (Tactic.rwRule
                              []
                              (Term.app `Nat.div_div_self [`hm (Term.app `succ_pos [(Term.hole "_")])]))]
                            "]")
                           [])
                          [])])))]
                    "⟩")])]
                "⟩")])])))))])))
   []
   (Term.have
    "have"
    (Term.haveDecl
     (Term.haveIdDecl
      [`hinsert []]
      [(Term.typeSpec
        ":"
        («term_=_»
         (Term.app
          `insert
          [`d.succ
           (Term.app
            (Term.proj (Term.app `range [`d.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])])
         "="
         (Term.app
          (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
          [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
      ":="
      («term_$__»
       `Finset.ext
       "$"
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`x] [])]
         "=>"
         (Term.anonymousCtor
          "⟨"
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`h] [])]
             "=>"
             (Term.app
              (Term.proj (Term.app (Term.proj `mem_insert "." (fieldIdx "1")) [`h]) "." `elim)
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`h] [])]
                 "=>"
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(group
                      (Tactic.simp
                       "simp"
                       []
                       []
                       ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `range_succ)] "]"]
                       [])
                      [])])))))
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.«tactic_<;>_»
                     (Tactic.clear "clear" [`_let_match])
                     "<;>"
                     (Tactic.«tactic_<;>_»
                      (Tactic.simp "simp" [] [] ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"] [])
                      "<;>"
                      (Tactic.tauto "tauto" [])))
                    [])])))])))
           ","
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(group
                (Tactic.«tactic_<;>_»
                 (Tactic.clear "clear" [`_let_match])
                 "<;>"
                 (Tactic.«tactic_<;>_»
                  (Tactic.simp
                   "simp"
                   ["("
                    "config"
                    ":="
                    (Term.structInst
                     "{"
                     []
                     [(group
                       (Term.structInstField (Term.structInstLVal `contextual []) ":=" `Bool.true._@._internal._hyg.0)
                       [])]
                     (Term.optEllipsis [])
                     []
                     "}")
                    ")"]
                   []
                   ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"]
                   [])
                  "<;>"
                  (Tactic.tauto "tauto" [])))
                [])])))]
          "⟩"))))))
    []
    (Term.have
     "have"
     (Term.haveDecl
      (Term.haveIdDecl
       [`hinsert₁ []]
       [(Term.typeSpec
         ":"
         (Init.Core.«term_∉_»
          `d.succ
          " ∉ "
          (Term.app
           (Term.proj (Term.app `range [`d.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(group
            (Tactic.simp
             "simp"
             []
             []
             ["["
              [(Tactic.simpLemma [] [] `mem_range)
               ","
               (Tactic.simpLemma [] [] `zero_le_one)
               ","
               (Tactic.simpLemma [] [] `le_succ)]
              "]"]
             [])
            [])])))))
     []
     (Term.app
      (Term.proj
       (Term.app
        `add_left_injₓ
        [(Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj (Term.app `range [`d.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
          ", "
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
           "."
           `card))])
       "."
       (fieldIdx "1"))
      [(calc
        "calc"
        [(calcStep
          («term_=_»
           (Term.hole "_")
           "="
           (Algebra.BigOperators.Basic.«term∑_in_,_»
            "∑"
            (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
            " in "
            (Term.app
             `insert
             [`d.succ
              (Term.app `filter [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
            ", "
            (Term.proj
             (Term.app
              (Term.proj `univ "." `filter)
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                 "=>"
                 («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
             "."
             `card)))
          ":="
          (Term.app
           `Eq.symm
           [(Term.app
             `Finset.sum_insert
             [(Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.simp
                    "simp"
                    []
                    []
                    ["["
                     [(Tactic.simpLemma [] [] `mem_range)
                      ","
                      (Tactic.simpLemma [] [] `zero_le_one)
                      ","
                      (Tactic.simpLemma [] [] `le_succ)]
                     "]"]
                    [])
                   [])])))])]))
         (calcStep
          («term_=_»
           (Term.hole "_")
           "="
           (Algebra.BigOperators.Basic.«term∑_in_,_»
            "∑"
            (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
            " in "
            (Term.app
             (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
            ", "
            (Term.proj
             (Term.app
              (Term.proj `univ "." `filter)
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                 "=>"
                 («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
             "."
             `card)))
          ":="
          (Term.app
           `sum_congr
           [`hinsert
            (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
         (calcStep
          («term_=_»
           (Term.hole "_")
           "="
           (Term.proj
            (Term.app
             (Term.proj `univ "." `filter)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                "=>"
                («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
            "."
            `card))
          ":="
          (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
         (calcStep
          («term_=_»
           (Term.hole "_")
           "="
           (Algebra.BigOperators.Basic.«term∑_in_,_»
            "∑"
            (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
            " in "
            (Term.app
             (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
            ", "
            (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
          ":="
          (Term.subst
           `ha
           "▸"
           [(Term.subst
             (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
             "▸"
             [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
         (calcStep
          («term_=_» (Term.hole "_") "=" (Term.hole "_"))
          ":="
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(group
               (Tactic.«tactic_<;>_»
                (Tactic.rwSeq
                 "rw"
                 []
                 (Tactic.rwRuleSeq
                  "["
                  [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
                  "]")
                 [])
                "<;>"
                (Tactic.exact
                 "exact"
                 (Term.app
                  `Finset.sum_congr
                  [`hinsert.symm
                   (Term.fun
                    "fun"
                    (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
               [])]))))])]))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'Lean.Parser.Term.have.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.have
   "have"
   (Term.haveDecl
    (Term.haveIdDecl
     [`hinsert []]
     [(Term.typeSpec
       ":"
       («term_=_»
        (Term.app
         `insert
         [`d.succ
          (Term.app
           (Term.proj (Term.app `range [`d.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])])
        "="
        (Term.app
         (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
         [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
     ":="
     («term_$__»
      `Finset.ext
      "$"
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.simpleBinder [`x] [])]
        "=>"
        (Term.anonymousCtor
         "⟨"
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`h] [])]
            "=>"
            (Term.app
             (Term.proj (Term.app (Term.proj `mem_insert "." (fieldIdx "1")) [`h]) "." `elim)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`h] [])]
                "=>"
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.simp
                      "simp"
                      []
                      []
                      ["[" [(Tactic.simpLemma [] [] `h) "," (Tactic.simpLemma [] [] `range_succ)] "]"]
                      [])
                     [])])))))
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.«tactic_<;>_»
                    (Tactic.clear "clear" [`_let_match])
                    "<;>"
                    (Tactic.«tactic_<;>_»
                     (Tactic.simp "simp" [] [] ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"] [])
                     "<;>"
                     (Tactic.tauto "tauto" [])))
                   [])])))])))
          ","
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(group
               (Tactic.«tactic_<;>_»
                (Tactic.clear "clear" [`_let_match])
                "<;>"
                (Tactic.«tactic_<;>_»
                 (Tactic.simp
                  "simp"
                  ["("
                   "config"
                   ":="
                   (Term.structInst
                    "{"
                    []
                    [(group
                      (Term.structInstField (Term.structInstLVal `contextual []) ":=" `Bool.true._@._internal._hyg.0)
                      [])]
                    (Term.optEllipsis [])
                    []
                    "}")
                   ")"]
                  []
                  ["[" [(Tactic.simpLemma [] [] `range_succ)] "]"]
                  [])
                 "<;>"
                 (Tactic.tauto "tauto" [])))
               [])])))]
         "⟩"))))))
   []
   (Term.have
    "have"
    (Term.haveDecl
     (Term.haveIdDecl
      [`hinsert₁ []]
      [(Term.typeSpec
        ":"
        (Init.Core.«term_∉_»
         `d.succ
         " ∉ "
         (Term.app
          (Term.proj (Term.app `range [`d.succ]) "." `filter)
          [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
      ":="
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(group
           (Tactic.simp
            "simp"
            []
            []
            ["["
             [(Tactic.simpLemma [] [] `mem_range)
              ","
              (Tactic.simpLemma [] [] `zero_le_one)
              ","
              (Tactic.simpLemma [] [] `le_succ)]
             "]"]
            [])
           [])])))))
    []
    (Term.app
     (Term.proj
      (Term.app
       `add_left_injₓ
       [(Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          (Term.proj (Term.app `range [`d.succ]) "." `filter)
          [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
         ", "
         (Term.proj
          (Term.app
           (Term.proj `univ "." `filter)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
              "=>"
              («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
          "."
          `card))])
      "."
      (fieldIdx "1"))
     [(calc
       "calc"
       [(calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            `insert
            [`d.succ
             (Term.app `filter [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
           ", "
           (Term.proj
            (Term.app
             (Term.proj `univ "." `filter)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                "=>"
                («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
            "."
            `card)))
         ":="
         (Term.app
          `Eq.symm
          [(Term.app
            `Finset.sum_insert
            [(Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(group
                  (Tactic.simp
                   "simp"
                   []
                   []
                   ["["
                    [(Tactic.simpLemma [] [] `mem_range)
                     ","
                     (Tactic.simpLemma [] [] `zero_le_one)
                     ","
                     (Tactic.simpLemma [] [] `le_succ)]
                    "]"]
                   [])
                  [])])))])]))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
           ", "
           (Term.proj
            (Term.app
             (Term.proj `univ "." `filter)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                "=>"
                («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
            "."
            `card)))
         ":="
         (Term.app
          `sum_congr
          [`hinsert
           (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
           "."
           `card))
         ":="
         (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
           ", "
           (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
         ":="
         (Term.subst
          `ha
          "▸"
          [(Term.subst
            (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
            "▸"
            [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
        (calcStep
         («term_=_» (Term.hole "_") "=" (Term.hole "_"))
         ":="
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group
              (Tactic.«tactic_<;>_»
               (Tactic.rwSeq
                "rw"
                []
                (Tactic.rwRuleSeq
                 "["
                 [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
                 "]")
                [])
               "<;>"
               (Tactic.exact
                "exact"
                (Term.app
                 `Finset.sum_congr
                 [`hinsert.symm
                  (Term.fun
                   "fun"
                   (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
              [])]))))])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'Lean.Parser.Term.have.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.have
   "have"
   (Term.haveDecl
    (Term.haveIdDecl
     [`hinsert₁ []]
     [(Term.typeSpec
       ":"
       (Init.Core.«term_∉_»
        `d.succ
        " ∉ "
        (Term.app
         (Term.proj (Term.app `range [`d.succ]) "." `filter)
         [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])))]
     ":="
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(group
          (Tactic.simp
           "simp"
           []
           []
           ["["
            [(Tactic.simpLemma [] [] `mem_range)
             ","
             (Tactic.simpLemma [] [] `zero_le_one)
             ","
             (Tactic.simpLemma [] [] `le_succ)]
            "]"]
           [])
          [])])))))
   []
   (Term.app
    (Term.proj
     (Term.app
      `add_left_injₓ
      [(Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
        " in "
        (Term.app
         (Term.proj (Term.app `range [`d.succ]) "." `filter)
         [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
        ", "
        (Term.proj
         (Term.app
          (Term.proj `univ "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
             "=>"
             («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
         "."
         `card))])
     "."
     (fieldIdx "1"))
    [(calc
      "calc"
      [(calcStep
        («term_=_»
         (Term.hole "_")
         "="
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           `insert
           [`d.succ
            (Term.app `filter [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
          ", "
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
           "."
           `card)))
        ":="
        (Term.app
         `Eq.symm
         [(Term.app
           `Finset.sum_insert
           [(Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(group
                 (Tactic.simp
                  "simp"
                  []
                  []
                  ["["
                   [(Tactic.simpLemma [] [] `mem_range)
                    ","
                    (Tactic.simpLemma [] [] `zero_le_one)
                    ","
                    (Tactic.simpLemma [] [] `le_succ)]
                   "]"]
                  [])
                 [])])))])]))
       (calcStep
        («term_=_»
         (Term.hole "_")
         "="
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
          ", "
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
           "."
           `card)))
        ":="
        (Term.app
         `sum_congr
         [`hinsert
          (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
       (calcStep
        («term_=_»
         (Term.hole "_")
         "="
         (Term.proj
          (Term.app
           (Term.proj `univ "." `filter)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
              "=>"
              («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
          "."
          `card))
        ":="
        (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
       (calcStep
        («term_=_»
         (Term.hole "_")
         "="
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
          ", "
          (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
        ":="
        (Term.subst
         `ha
         "▸"
         [(Term.subst
           (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
           "▸"
           [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
       (calcStep
        («term_=_» (Term.hole "_") "=" (Term.hole "_"))
        ":="
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(group
             (Tactic.«tactic_<;>_»
              (Tactic.rwSeq
               "rw"
               []
               (Tactic.rwRuleSeq
                "["
                [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
                "]")
               [])
              "<;>"
              (Tactic.exact
               "exact"
               (Term.app
                `Finset.sum_congr
                [`hinsert.symm
                 (Term.fun
                  "fun"
                  (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
             [])]))))])]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'Lean.Parser.Term.have.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app
   (Term.proj
    (Term.app
     `add_left_injₓ
     [(Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app
        (Term.proj (Term.app `range [`d.succ]) "." `filter)
        [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
       ", "
       (Term.proj
        (Term.app
         (Term.proj `univ "." `filter)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
            "=>"
            («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
        "."
        `card))])
    "."
    (fieldIdx "1"))
   [(calc
     "calc"
     [(calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          `insert
          [`d.succ
           (Term.app `filter [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
         ", "
         (Term.proj
          (Term.app
           (Term.proj `univ "." `filter)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
              "=>"
              («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
          "."
          `card)))
       ":="
       (Term.app
        `Eq.symm
        [(Term.app
          `Finset.sum_insert
          [(Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(group
                (Tactic.simp
                 "simp"
                 []
                 []
                 ["["
                  [(Tactic.simpLemma [] [] `mem_range)
                   ","
                   (Tactic.simpLemma [] [] `zero_le_one)
                   ","
                   (Tactic.simpLemma [] [] `le_succ)]
                  "]"]
                 [])
                [])])))])]))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
          [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
         ", "
         (Term.proj
          (Term.app
           (Term.proj `univ "." `filter)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
              "=>"
              («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
          "."
          `card)))
       ":="
       (Term.app
        `sum_congr
        [`hinsert
         (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Term.proj
         (Term.app
          (Term.proj `univ "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
             "=>"
             («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
         "."
         `card))
       ":="
       (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
          [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
         ", "
         (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
       ":="
       (Term.subst
        `ha
        "▸"
        [(Term.subst
          (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
          "▸"
          [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
      (calcStep
       («term_=_» (Term.hole "_") "=" (Term.hole "_"))
       ":="
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(group
            (Tactic.«tactic_<;>_»
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
               "]")
              [])
             "<;>"
             (Tactic.exact
              "exact"
              (Term.app
               `Finset.sum_congr
               [`hinsert.symm
                (Term.fun
                 "fun"
                 (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
            [])]))))])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calc', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calc', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calc', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calc', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calc', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (calc
   "calc"
   [(calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app
        `insert
        [`d.succ (Term.app `filter [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) (Term.app `range [`d.succ])])])
       ", "
       (Term.proj
        (Term.app
         (Term.proj `univ "." `filter)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
            "=>"
            («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
        "."
        `card)))
     ":="
     (Term.app
      `Eq.symm
      [(Term.app
        `Finset.sum_insert
        [(Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group
              (Tactic.simp
               "simp"
               []
               []
               ["["
                [(Tactic.simpLemma [] [] `mem_range)
                 ","
                 (Tactic.simpLemma [] [] `zero_le_one)
                 ","
                 (Tactic.simpLemma [] [] `le_succ)]
                "]"]
               [])
              [])])))])]))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app
        (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
        [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
       ", "
       (Term.proj
        (Term.app
         (Term.proj `univ "." `filter)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
            "=>"
            («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
        "."
        `card)))
     ":="
     (Term.app
      `sum_congr
      [`hinsert (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Term.proj
       (Term.app
        (Term.proj `univ "." `filter)
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
           "=>"
           («term_=_» («term_^_» `a "^" `d.succ) "=" (numLit "1"))))])
       "."
       `card))
     ":="
     (Term.app `sum_card_order_of_eq_card_pow_eq_one [(Term.app `succ_pos [`d])]))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app
        (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
        [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
       ", "
       (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
     ":="
     (Term.subst
      `ha
      "▸"
      [(Term.subst
        (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
        "▸"
        [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])]))
    (calcStep
     («term_=_» (Term.hole "_") "=" (Term.hole "_"))
     ":="
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(group
          (Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))]
             "]")
            [])
           "<;>"
           (Tactic.exact
            "exact"
            (Term.app
             `Finset.sum_congr
             [`hinsert.symm
              (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
          [])]))))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calc', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calcStep', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.byTactic
   "by"
   (Tactic.tacticSeq
    (Tactic.tacticSeq1Indented
     [(group
       (Tactic.«tactic_<;>_»
        (Tactic.rwSeq
         "rw"
         []
         (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))] "]")
         [])
        "<;>"
        (Tactic.exact
         "exact"
         (Term.app
          `Finset.sum_congr
          [`hinsert.symm
           (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
       [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.byTactic.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq', expected 'Lean.Parser.Tactic.tacticSeq.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeq1Indented.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.«tactic_<;>_»
   (Tactic.rwSeq
    "rw"
    []
    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))] "]")
    [])
   "<;>"
   (Tactic.exact
    "exact"
    (Term.app
     `Finset.sum_congr
     [`hinsert.symm
      (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.«tactic_<;>_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.exact
   "exact"
   (Term.app
    `Finset.sum_congr
    [`hinsert.symm
     (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.exact', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app
   `Finset.sum_congr
   [`hinsert.symm
    (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `rfl
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.simpleBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  `hinsert.symm
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `Finset.sum_congr
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
  (Tactic.rwSeq
   "rw"
   []
   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h) "," (Tactic.rwRule ["←"] (Term.app `sum_insert [`hinsert₁]))] "]")
   [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwSeq', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `sum_insert [`hinsert₁])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `hinsert₁
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `sum_insert
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«←»', expected 'optional.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `h
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_=_» (Term.hole "_") "=" (Term.hole "_"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calcStep', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
  (Term.subst
   `ha
   "▸"
   [(Term.subst
     (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
     "▸"
     [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.subst', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.subst', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.subst
   (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
   "▸"
   [(Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.subst', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.proj (Term.app `sum_totient [(Term.hole "_")]) "." `symm)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  (Term.app `sum_totient [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `sum_totient
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" [(Term.app `sum_totient [(Term.hole "_")]) []] ")")
[PrettyPrinter.parenthesize] ...precedences are 75 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 75, term))
  (Term.proj (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) "." `symm)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  (Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `a
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `hn
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `card_pow_eq_one_eq_order_of_aux
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
 "("
 [(Term.app `card_pow_eq_one_eq_order_of_aux [`hn `a]) []]
 ")")
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 75, term)
[PrettyPrinter.parenthesize] ...precedences are 75 >? 75, (some 75, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 75, term))
  `ha
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 75, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 75, (some 75, term) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_=_»
   (Term.hole "_")
   "="
   (Algebra.BigOperators.Basic.«term∑_in_,_»
    "∑"
    (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
    " in "
    (Term.app
     (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
     [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
    ", "
    (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Algebra.BigOperators.Basic.«term∑_in_,_»
   "∑"
   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
   " in "
   (Term.app
    (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
    [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
   ", "
   (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∑_in_,_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `m
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Nat.Data.Nat.Totient.termφ "φ")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Nat.Data.Nat.Totient.termφ', expected 'antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app
   (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
   [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `d.succ
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
  (Term.cdot "·")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.cdot', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.cdot', expected 'Lean.Parser.Term.cdot.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 50 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
 "("
 [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `d.succ) []]
 ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Term.proj (Term.app `range [`d.succ.succ]) "." `filter)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  (Term.app `range [`d.succ.succ])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `d.succ.succ
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `range
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" [(Term.app `range [`d.succ.succ]) []] ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.explicitBinders', expected 'Mathlib.ExtendedBinder.extBinders'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValEqns', expected 'Lean.Parser.Command.whereStructInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValEqns', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
private
  theorem
    card_order_of_eq_totient_aux₁
    :
      ∀
        { d : ℕ }
        ,
        d ∣ Fintype.card α
          →
          0 < univ . filter fun a : α => orderOf a = d . card → univ . filter fun a : α => orderOf a = d . card = φ d
    | 0 => fun hd hd0 => let ⟨ a , ha ⟩ := card_pos . 1 hd0 absurd mem_filter . 1 ha . 2 $ ne_of_gtₓ $ order_of_pos a
      |
        d + 1
        =>
        fun
          hd hd0
            =>
            let
              ⟨ a , ha ⟩ := card_pos . 1 hd0
              have
                ha : orderOf a = d.succ := mem_filter . 1 ha . 2
                have
                  h
                    :
                      ∑ m in range d.succ . filter · ∣ d.succ , univ . filter fun a : α => orderOf a = m . card
                        =
                        ∑ m in range d.succ . filter · ∣ d.succ , φ m
                    :=
                    Finset.sum_congr
                      rfl
                        fun
                          m hm
                            =>
                            have
                              hmd : m < d.succ := mem_range . 1 mem_filter . 1 hm . 1
                              have
                                hm : m ∣ d.succ := mem_filter . 1 hm . 2
                                card_order_of_eq_totient_aux₁
                                  hm.trans hd
                                    Finset.card_pos . 2
                                      ⟨
                                        a ^ d.succ / m
                                          ,
                                          mem_filter . 2
                                            ⟨
                                              mem_univ _
                                                ,
                                                by
                                                  rw
                                                    [
                                                      order_of_pow a
                                                        ,
                                                        ha
                                                        ,
                                                        gcd_eq_right div_dvd_of_dvd hm
                                                        ,
                                                        Nat.div_div_self hm succ_pos _
                                                      ]
                                              ⟩
                                        ⟩
                  have
                    hinsert
                      : insert d.succ range d.succ . filter · ∣ d.succ = range d.succ.succ . filter · ∣ d.succ
                      :=
                      Finset.ext
                        $
                        fun
                          x
                            =>
                            ⟨
                              fun
                                  h
                                    =>
                                    mem_insert . 1 h . elim
                                      fun h => by simp [ h , range_succ ]
                                        by clear _let_match <;> simp [ range_succ ] <;> tauto
                                ,
                                by
                                  clear _let_match
                                    <;>
                                    simp ( config := { contextual := Bool.true._@._internal._hyg.0 } ) [ range_succ ]
                                      <;>
                                      tauto
                              ⟩
                    have
                      hinsert₁
                        : d.succ ∉ range d.succ . filter · ∣ d.succ
                        :=
                        by simp [ mem_range , zero_le_one , le_succ ]
                      add_left_injₓ
                            ∑ m in range d.succ . filter · ∣ d.succ , univ . filter fun a : α => orderOf a = m . card
                          .
                          1
                        calc
                          _
                                =
                                ∑
                                  m
                                  in
                                  insert d.succ filter · ∣ d.succ range d.succ
                                  ,
                                  univ . filter fun a : α => orderOf a = m . card
                              :=
                              Eq.symm Finset.sum_insert by simp [ mem_range , zero_le_one , le_succ ]
                            _
                                =
                                ∑
                                  m
                                  in
                                  range d.succ.succ . filter · ∣ d.succ
                                  ,
                                  univ . filter fun a : α => orderOf a = m . card
                              :=
                              sum_congr hinsert fun _ _ => rfl
                            _ = univ . filter fun a : α => a ^ d.succ = 1 . card
                              :=
                              sum_card_order_of_eq_card_pow_eq_one succ_pos d
                            _ = ∑ m in range d.succ.succ . filter · ∣ d.succ , φ m
                              :=
                              ha ▸ card_pow_eq_one_eq_order_of_aux hn a . symm ▸ sum_totient _ . symm
                            _ = _
                              :=
                              by rw [ h , ← sum_insert hinsert₁ ] <;> exact Finset.sum_congr hinsert.symm fun _ _ => rfl

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers [] [] [] [] [] [])
 (Command.theorem
  "theorem"
  (Command.declId `card_order_of_eq_totient_aux₂ [])
  (Command.declSig
   [(Term.implicitBinder "{" [`d] [":" (termℕ "ℕ")] "}")
    (Term.explicitBinder "(" [`hd] [":" (Init.Core.«term_∣_» `d " ∣ " (Term.app `Fintype.card [`α]))] [] ")")]
   (Term.typeSpec
    ":"
    («term_=_»
     (Term.proj
      (Term.app
       (Term.proj `univ "." `filter)
       [(Term.fun
         "fun"
         (Term.basicFun
          [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
          "=>"
          («term_=_» (Term.app `orderOf [`a]) "=" `d)))])
      "."
      `card)
     "="
     (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d]))))
  (Command.declValSimple
   ":="
   («term_$__»
    `by_contradiction
    "$"
    (Term.fun
     "fun"
     (Term.basicFun
      [(Term.simpleBinder [`h] [])]
      "=>"
      (Term.have
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`h0 []]
         [(Term.typeSpec
           ":"
           («term_=_»
            (Term.proj
             (Term.app
              (Term.proj `univ "." `filter)
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                 "=>"
                 («term_=_» (Term.app `orderOf [`a]) "=" `d)))])
             "."
             `card)
            "="
            (numLit "0")))]
         ":="
         (Term.app
          (Term.proj `not_not "." (fieldIdx "1"))
          [(Term.app
            `mt
            [(Term.proj `pos_iff_ne_zero "." (fieldIdx "2"))
             (Term.app `mt [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hd]) `h])])])))
       []
       (Term.let
        "let"
        (Term.letDecl (Term.letIdDecl `c [] [] ":=" (Term.app `Fintype.card [`α])))
        []
        (Term.have
         "have"
         (Term.haveDecl
          (Term.haveIdDecl
           [`hc0 []]
           [(Term.typeSpec ":" («term_<_» (numLit "0") "<" `c))]
           ":="
           (Term.app
            (Term.proj `Fintype.card_pos_iff "." (fieldIdx "2"))
            [(Term.anonymousCtor "⟨" [(numLit "1")] "⟩")])))
         []
         («term_$__»
          (Term.app `lt_irreflₓ [`c])
          "$"
          (calc
           "calc"
           [(calcStep
             («term_=_»
              `c
              "="
              (Term.proj
               (Term.app
                (Term.proj `univ "." `filter)
                [(Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                   "=>"
                   («term_=_» («term_^_» `a "^" `c) "=" (numLit "1"))))])
               "."
               `card))
             ":="
             («term_$__»
              (Term.app `congr_argₓ [`card])
              "$"
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.simp
                    "simp"
                    []
                    []
                    ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff) "," (Tactic.simpLemma [] [] `c)] "]"]
                    [])
                   [])])))))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              (Algebra.BigOperators.Basic.«term∑_in_,_»
               "∑"
               (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
               " in "
               (Term.app
                (Term.proj (Term.app `range [`c.succ]) "." `filter)
                [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
               ", "
               (Term.proj
                (Term.app
                 (Term.proj `univ "." `filter)
                 [(Term.fun
                   "fun"
                   (Term.basicFun
                    [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                    "=>"
                    («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
                "."
                `card)))
             ":="
             (Term.proj (Term.app `sum_card_order_of_eq_card_pow_eq_one [`hc0]) "." `symm))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              (Algebra.BigOperators.Basic.«term∑_in_,_»
               "∑"
               (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
               " in "
               (Term.app
                (Term.proj
                 (Term.app
                  (Term.proj (Term.app `range [`c.succ]) "." `filter)
                  [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                 "."
                 `erase)
                [`d])
               ", "
               (Term.proj
                (Term.app
                 (Term.proj `univ "." `filter)
                 [(Term.fun
                   "fun"
                   (Term.basicFun
                    [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                    "=>"
                    («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
                "."
                `card)))
             ":="
             (Term.app
              `Eq.symm
              [(Term.app
                `sum_subset
                [(Term.app `erase_subset [(Term.hole "_") (Term.hole "_")])
                 (Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`m `hm₁ `hm₂] [])]
                   "=>"
                   (Term.have
                    "have"
                    (Term.haveDecl
                     (Term.haveIdDecl
                      []
                      [(Term.typeSpec ":" («term_=_» `m "=" `d))]
                      ":="
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(group
                           (Tactic.«tactic_<;>_»
                            (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationWildcard "*"))])
                            "<;>"
                            (Tactic.cc "cc"))
                           [])])))))
                    []
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(group
                         (Tactic.«tactic_<;>_»
                          (Tactic.simpAll "simp_all" [] [] ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff)] "]"])
                          "<;>"
                          (Tactic.exact "exact" `h0))
                         [])]))))))])]))
            (calcStep
             («term_≤_»
              (Term.hole "_")
              "≤"
              (Algebra.BigOperators.Basic.«term∑_in_,_»
               "∑"
               (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
               " in "
               (Term.app
                (Term.proj
                 (Term.app
                  (Term.proj (Term.app `range [`c.succ]) "." `filter)
                  [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                 "."
                 `erase)
                [`d])
               ", "
               (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
             ":="
             (Term.app
              `sum_le_sum
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`m `hm] [])]
                 "=>"
                 (Term.have
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    [`hmc []]
                    [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `c))]
                    ":="
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(group
                         (Tactic.«tactic_<;>_»
                          (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationHyp [`hm] []))])
                          "<;>"
                          (Tactic.tauto "tauto" []))
                         [])])))))
                  []
                  (Term.app
                   (Term.proj
                    (Term.app
                     (Term.proj `imp_iff_not_or "." (fieldIdx "1"))
                     [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hmc])])
                    "."
                    `elim)
                   [(Term.fun
                     "fun"
                     (Term.basicFun
                      [(Term.simpleBinder [`h] [])]
                      "=>"
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(group
                           (Tactic.simp
                            "simp"
                            []
                            []
                            ["["
                             [(Tactic.simpLemma
                               []
                               []
                               (Term.app
                                (Term.proj `Nat.le_zero_iffₓ "." (fieldIdx "1"))
                                [(Term.app `le_of_not_gtₓ [`h])]))
                              ","
                              (Tactic.simpLemma [] [] `Nat.zero_leₓ)]
                             "]"]
                            [])
                           [])])))))
                    (Term.fun
                     "fun"
                     (Term.basicFun
                      [(Term.simpleBinder [`h] [])]
                      "=>"
                      (Term.byTactic
                       "by"
                       (Tactic.tacticSeq
                        (Tactic.tacticSeq1Indented
                         [(group
                           (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h)] "]") [])
                           [])])))))]))))]))
            (calcStep
             («term_<_»
              (Term.hole "_")
              "<"
              (Init.Logic.«term_+_»
               (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])
               "+"
               (Algebra.BigOperators.Basic.«term∑_in_,_»
                "∑"
                (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
                " in "
                (Term.app
                 (Term.proj
                  (Term.app
                   (Term.proj (Term.app `range [`c.succ]) "." `filter)
                   [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                  "."
                  `erase)
                 [`d])
                ", "
                (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))
             ":="
             (Term.app
              `lt_add_of_pos_left
              [(Term.hole "_")
               (Term.app
                `totient_pos
                [(Term.app
                  `Nat.pos_of_ne_zeroₓ
                  [(Term.fun
                    "fun"
                    (Term.basicFun
                     [(Term.simpleBinder [`h] [])]
                     "=>"
                     (Term.app
                      (Term.proj `pos_iff_ne_zero "." (fieldIdx "1"))
                      [`hc0 («term_$__» `eq_zero_of_zero_dvd "$" (Term.subst `h "▸" [`hd]))])))])])]))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              (Algebra.BigOperators.Basic.«term∑_in_,_»
               "∑"
               (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
               " in "
               (Term.app
                `insert
                [`d
                 (Term.app
                  (Term.proj
                   (Term.app
                    (Term.proj (Term.app `range [`c.succ]) "." `filter)
                    [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                   "."
                   `erase)
                  [`d])])
               ", "
               (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
             ":="
             (Term.app
              `Eq.symm
              [(Term.app
                `sum_insert
                [(Term.byTactic
                  "by"
                  (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] []) [])])))])]))
            (calcStep
             («term_=_»
              (Term.hole "_")
              "="
              (Algebra.BigOperators.Basic.«term∑_in_,_»
               "∑"
               (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
               " in "
               (Term.app
                (Term.proj (Term.app `range [`c.succ]) "." `filter)
                [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
               ", "
               (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
             ":="
             (Term.app
              `Finset.sum_congr
              [(Term.app
                `Finset.insert_erase
                [(Term.app
                  (Term.proj `mem_filter "." (fieldIdx "2"))
                  [(Term.anonymousCtor
                    "⟨"
                    [(Term.app
                      (Term.proj `mem_range "." (fieldIdx "2"))
                      [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
                     ","
                     `hd]
                    "⟩")])])
               (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
            (calcStep («term_=_» (Term.hole "_") "=" `c) ":=" (Term.app `sum_totient [(Term.hole "_")]))]))))))))
   [])
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_$__»
   `by_contradiction
   "$"
   (Term.fun
    "fun"
    (Term.basicFun
     [(Term.simpleBinder [`h] [])]
     "=>"
     (Term.have
      "have"
      (Term.haveDecl
       (Term.haveIdDecl
        [`h0 []]
        [(Term.typeSpec
          ":"
          («term_=_»
           (Term.proj
            (Term.app
             (Term.proj `univ "." `filter)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                "=>"
                («term_=_» (Term.app `orderOf [`a]) "=" `d)))])
            "."
            `card)
           "="
           (numLit "0")))]
        ":="
        (Term.app
         (Term.proj `not_not "." (fieldIdx "1"))
         [(Term.app
           `mt
           [(Term.proj `pos_iff_ne_zero "." (fieldIdx "2"))
            (Term.app `mt [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hd]) `h])])])))
      []
      (Term.let
       "let"
       (Term.letDecl (Term.letIdDecl `c [] [] ":=" (Term.app `Fintype.card [`α])))
       []
       (Term.have
        "have"
        (Term.haveDecl
         (Term.haveIdDecl
          [`hc0 []]
          [(Term.typeSpec ":" («term_<_» (numLit "0") "<" `c))]
          ":="
          (Term.app
           (Term.proj `Fintype.card_pos_iff "." (fieldIdx "2"))
           [(Term.anonymousCtor "⟨" [(numLit "1")] "⟩")])))
        []
        («term_$__»
         (Term.app `lt_irreflₓ [`c])
         "$"
         (calc
          "calc"
          [(calcStep
            («term_=_»
             `c
             "="
             (Term.proj
              (Term.app
               (Term.proj `univ "." `filter)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                  "=>"
                  («term_=_» («term_^_» `a "^" `c) "=" (numLit "1"))))])
              "."
              `card))
            ":="
            («term_$__»
             (Term.app `congr_argₓ [`card])
             "$"
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(group
                  (Tactic.simp
                   "simp"
                   []
                   []
                   ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff) "," (Tactic.simpLemma [] [] `c)] "]"]
                   [])
                  [])])))))
           (calcStep
            («term_=_»
             (Term.hole "_")
             "="
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               (Term.proj (Term.app `range [`c.succ]) "." `filter)
               [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
              ", "
              (Term.proj
               (Term.app
                (Term.proj `univ "." `filter)
                [(Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                   "=>"
                   («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
               "."
               `card)))
            ":="
            (Term.proj (Term.app `sum_card_order_of_eq_card_pow_eq_one [`hc0]) "." `symm))
           (calcStep
            («term_=_»
             (Term.hole "_")
             "="
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               (Term.proj
                (Term.app
                 (Term.proj (Term.app `range [`c.succ]) "." `filter)
                 [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                "."
                `erase)
               [`d])
              ", "
              (Term.proj
               (Term.app
                (Term.proj `univ "." `filter)
                [(Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                   "=>"
                   («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
               "."
               `card)))
            ":="
            (Term.app
             `Eq.symm
             [(Term.app
               `sum_subset
               [(Term.app `erase_subset [(Term.hole "_") (Term.hole "_")])
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`m `hm₁ `hm₂] [])]
                  "=>"
                  (Term.have
                   "have"
                   (Term.haveDecl
                    (Term.haveIdDecl
                     []
                     [(Term.typeSpec ":" («term_=_» `m "=" `d))]
                     ":="
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(group
                          (Tactic.«tactic_<;>_»
                           (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationWildcard "*"))])
                           "<;>"
                           (Tactic.cc "cc"))
                          [])])))))
                   []
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(group
                        (Tactic.«tactic_<;>_»
                         (Tactic.simpAll "simp_all" [] [] ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff)] "]"])
                         "<;>"
                         (Tactic.exact "exact" `h0))
                        [])]))))))])]))
           (calcStep
            («term_≤_»
             (Term.hole "_")
             "≤"
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               (Term.proj
                (Term.app
                 (Term.proj (Term.app `range [`c.succ]) "." `filter)
                 [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                "."
                `erase)
               [`d])
              ", "
              (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
            ":="
            (Term.app
             `sum_le_sum
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`m `hm] [])]
                "=>"
                (Term.have
                 "have"
                 (Term.haveDecl
                  (Term.haveIdDecl
                   [`hmc []]
                   [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `c))]
                   ":="
                   (Term.byTactic
                    "by"
                    (Tactic.tacticSeq
                     (Tactic.tacticSeq1Indented
                      [(group
                        (Tactic.«tactic_<;>_»
                         (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationHyp [`hm] []))])
                         "<;>"
                         (Tactic.tauto "tauto" []))
                        [])])))))
                 []
                 (Term.app
                  (Term.proj
                   (Term.app
                    (Term.proj `imp_iff_not_or "." (fieldIdx "1"))
                    [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hmc])])
                   "."
                   `elim)
                  [(Term.fun
                    "fun"
                    (Term.basicFun
                     [(Term.simpleBinder [`h] [])]
                     "=>"
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(group
                          (Tactic.simp
                           "simp"
                           []
                           []
                           ["["
                            [(Tactic.simpLemma
                              []
                              []
                              (Term.app
                               (Term.proj `Nat.le_zero_iffₓ "." (fieldIdx "1"))
                               [(Term.app `le_of_not_gtₓ [`h])]))
                             ","
                             (Tactic.simpLemma [] [] `Nat.zero_leₓ)]
                            "]"]
                           [])
                          [])])))))
                   (Term.fun
                    "fun"
                    (Term.basicFun
                     [(Term.simpleBinder [`h] [])]
                     "=>"
                     (Term.byTactic
                      "by"
                      (Tactic.tacticSeq
                       (Tactic.tacticSeq1Indented
                        [(group
                          (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h)] "]") [])
                          [])])))))]))))]))
           (calcStep
            («term_<_»
             (Term.hole "_")
             "<"
             (Init.Logic.«term_+_»
              (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])
              "+"
              (Algebra.BigOperators.Basic.«term∑_in_,_»
               "∑"
               (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
               " in "
               (Term.app
                (Term.proj
                 (Term.app
                  (Term.proj (Term.app `range [`c.succ]) "." `filter)
                  [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                 "."
                 `erase)
                [`d])
               ", "
               (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))
            ":="
            (Term.app
             `lt_add_of_pos_left
             [(Term.hole "_")
              (Term.app
               `totient_pos
               [(Term.app
                 `Nat.pos_of_ne_zeroₓ
                 [(Term.fun
                   "fun"
                   (Term.basicFun
                    [(Term.simpleBinder [`h] [])]
                    "=>"
                    (Term.app
                     (Term.proj `pos_iff_ne_zero "." (fieldIdx "1"))
                     [`hc0 («term_$__» `eq_zero_of_zero_dvd "$" (Term.subst `h "▸" [`hd]))])))])])]))
           (calcStep
            («term_=_»
             (Term.hole "_")
             "="
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               `insert
               [`d
                (Term.app
                 (Term.proj
                  (Term.app
                   (Term.proj (Term.app `range [`c.succ]) "." `filter)
                   [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                  "."
                  `erase)
                 [`d])])
              ", "
              (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
            ":="
            (Term.app
             `Eq.symm
             [(Term.app
               `sum_insert
               [(Term.byTactic
                 "by"
                 (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] []) [])])))])]))
           (calcStep
            («term_=_»
             (Term.hole "_")
             "="
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               (Term.proj (Term.app `range [`c.succ]) "." `filter)
               [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
              ", "
              (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
            ":="
            (Term.app
             `Finset.sum_congr
             [(Term.app
               `Finset.insert_erase
               [(Term.app
                 (Term.proj `mem_filter "." (fieldIdx "2"))
                 [(Term.anonymousCtor
                   "⟨"
                   [(Term.app
                     (Term.proj `mem_range "." (fieldIdx "2"))
                     [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
                    ","
                    `hd]
                   "⟩")])])
              (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
           (calcStep («term_=_» (Term.hole "_") "=" `c) ":=" (Term.app `sum_totient [(Term.hole "_")]))]))))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_$__»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`h] [])]
    "=>"
    (Term.have
     "have"
     (Term.haveDecl
      (Term.haveIdDecl
       [`h0 []]
       [(Term.typeSpec
         ":"
         («term_=_»
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» (Term.app `orderOf [`a]) "=" `d)))])
           "."
           `card)
          "="
          (numLit "0")))]
       ":="
       (Term.app
        (Term.proj `not_not "." (fieldIdx "1"))
        [(Term.app
          `mt
          [(Term.proj `pos_iff_ne_zero "." (fieldIdx "2"))
           (Term.app `mt [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hd]) `h])])])))
     []
     (Term.let
      "let"
      (Term.letDecl (Term.letIdDecl `c [] [] ":=" (Term.app `Fintype.card [`α])))
      []
      (Term.have
       "have"
       (Term.haveDecl
        (Term.haveIdDecl
         [`hc0 []]
         [(Term.typeSpec ":" («term_<_» (numLit "0") "<" `c))]
         ":="
         (Term.app (Term.proj `Fintype.card_pos_iff "." (fieldIdx "2")) [(Term.anonymousCtor "⟨" [(numLit "1")] "⟩")])))
       []
       («term_$__»
        (Term.app `lt_irreflₓ [`c])
        "$"
        (calc
         "calc"
         [(calcStep
           («term_=_»
            `c
            "="
            (Term.proj
             (Term.app
              (Term.proj `univ "." `filter)
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                 "=>"
                 («term_=_» («term_^_» `a "^" `c) "=" (numLit "1"))))])
             "."
             `card))
           ":="
           («term_$__»
            (Term.app `congr_argₓ [`card])
            "$"
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(group
                 (Tactic.simp
                  "simp"
                  []
                  []
                  ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff) "," (Tactic.simpLemma [] [] `c)] "]"]
                  [])
                 [])])))))
          (calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              (Term.proj (Term.app `range [`c.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
             ", "
             (Term.proj
              (Term.app
               (Term.proj `univ "." `filter)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                  "=>"
                  («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
              "."
              `card)))
           ":="
           (Term.proj (Term.app `sum_card_order_of_eq_card_pow_eq_one [`hc0]) "." `symm))
          (calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              (Term.proj
               (Term.app
                (Term.proj (Term.app `range [`c.succ]) "." `filter)
                [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
               "."
               `erase)
              [`d])
             ", "
             (Term.proj
              (Term.app
               (Term.proj `univ "." `filter)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                  "=>"
                  («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
              "."
              `card)))
           ":="
           (Term.app
            `Eq.symm
            [(Term.app
              `sum_subset
              [(Term.app `erase_subset [(Term.hole "_") (Term.hole "_")])
               (Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`m `hm₁ `hm₂] [])]
                 "=>"
                 (Term.have
                  "have"
                  (Term.haveDecl
                   (Term.haveIdDecl
                    []
                    [(Term.typeSpec ":" («term_=_» `m "=" `d))]
                    ":="
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(group
                         (Tactic.«tactic_<;>_»
                          (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationWildcard "*"))])
                          "<;>"
                          (Tactic.cc "cc"))
                         [])])))))
                  []
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(group
                       (Tactic.«tactic_<;>_»
                        (Tactic.simpAll "simp_all" [] [] ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff)] "]"])
                        "<;>"
                        (Tactic.exact "exact" `h0))
                       [])]))))))])]))
          (calcStep
           («term_≤_»
            (Term.hole "_")
            "≤"
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              (Term.proj
               (Term.app
                (Term.proj (Term.app `range [`c.succ]) "." `filter)
                [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
               "."
               `erase)
              [`d])
             ", "
             (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
           ":="
           (Term.app
            `sum_le_sum
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`m `hm] [])]
               "=>"
               (Term.have
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  [`hmc []]
                  [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `c))]
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(group
                       (Tactic.«tactic_<;>_»
                        (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationHyp [`hm] []))])
                        "<;>"
                        (Tactic.tauto "tauto" []))
                       [])])))))
                []
                (Term.app
                 (Term.proj
                  (Term.app
                   (Term.proj `imp_iff_not_or "." (fieldIdx "1"))
                   [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hmc])])
                  "."
                  `elim)
                 [(Term.fun
                   "fun"
                   (Term.basicFun
                    [(Term.simpleBinder [`h] [])]
                    "=>"
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(group
                         (Tactic.simp
                          "simp"
                          []
                          []
                          ["["
                           [(Tactic.simpLemma
                             []
                             []
                             (Term.app
                              (Term.proj `Nat.le_zero_iffₓ "." (fieldIdx "1"))
                              [(Term.app `le_of_not_gtₓ [`h])]))
                            ","
                            (Tactic.simpLemma [] [] `Nat.zero_leₓ)]
                           "]"]
                          [])
                         [])])))))
                  (Term.fun
                   "fun"
                   (Term.basicFun
                    [(Term.simpleBinder [`h] [])]
                    "=>"
                    (Term.byTactic
                     "by"
                     (Tactic.tacticSeq
                      (Tactic.tacticSeq1Indented
                       [(group
                         (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h)] "]") [])
                         [])])))))]))))]))
          (calcStep
           («term_<_»
            (Term.hole "_")
            "<"
            (Init.Logic.«term_+_»
             (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])
             "+"
             (Algebra.BigOperators.Basic.«term∑_in_,_»
              "∑"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
              " in "
              (Term.app
               (Term.proj
                (Term.app
                 (Term.proj (Term.app `range [`c.succ]) "." `filter)
                 [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                "."
                `erase)
               [`d])
              ", "
              (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))
           ":="
           (Term.app
            `lt_add_of_pos_left
            [(Term.hole "_")
             (Term.app
              `totient_pos
              [(Term.app
                `Nat.pos_of_ne_zeroₓ
                [(Term.fun
                  "fun"
                  (Term.basicFun
                   [(Term.simpleBinder [`h] [])]
                   "=>"
                   (Term.app
                    (Term.proj `pos_iff_ne_zero "." (fieldIdx "1"))
                    [`hc0 («term_$__» `eq_zero_of_zero_dvd "$" (Term.subst `h "▸" [`hd]))])))])])]))
          (calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              `insert
              [`d
               (Term.app
                (Term.proj
                 (Term.app
                  (Term.proj (Term.app `range [`c.succ]) "." `filter)
                  [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
                 "."
                 `erase)
                [`d])])
             ", "
             (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
           ":="
           (Term.app
            `Eq.symm
            [(Term.app
              `sum_insert
              [(Term.byTactic
                "by"
                (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] []) [])])))])]))
          (calcStep
           («term_=_»
            (Term.hole "_")
            "="
            (Algebra.BigOperators.Basic.«term∑_in_,_»
             "∑"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
             " in "
             (Term.app
              (Term.proj (Term.app `range [`c.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
             ", "
             (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
           ":="
           (Term.app
            `Finset.sum_congr
            [(Term.app
              `Finset.insert_erase
              [(Term.app
                (Term.proj `mem_filter "." (fieldIdx "2"))
                [(Term.anonymousCtor
                  "⟨"
                  [(Term.app
                    (Term.proj `mem_range "." (fieldIdx "2"))
                    [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
                   ","
                   `hd]
                  "⟩")])])
             (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
          (calcStep («term_=_» (Term.hole "_") "=" `c) ":=" (Term.app `sum_totient [(Term.hole "_")]))])))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.have
   "have"
   (Term.haveDecl
    (Term.haveIdDecl
     [`h0 []]
     [(Term.typeSpec
       ":"
       («term_=_»
        (Term.proj
         (Term.app
          (Term.proj `univ "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
             "=>"
             («term_=_» (Term.app `orderOf [`a]) "=" `d)))])
         "."
         `card)
        "="
        (numLit "0")))]
     ":="
     (Term.app
      (Term.proj `not_not "." (fieldIdx "1"))
      [(Term.app
        `mt
        [(Term.proj `pos_iff_ne_zero "." (fieldIdx "2"))
         (Term.app `mt [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hd]) `h])])])))
   []
   (Term.let
    "let"
    (Term.letDecl (Term.letIdDecl `c [] [] ":=" (Term.app `Fintype.card [`α])))
    []
    (Term.have
     "have"
     (Term.haveDecl
      (Term.haveIdDecl
       [`hc0 []]
       [(Term.typeSpec ":" («term_<_» (numLit "0") "<" `c))]
       ":="
       (Term.app (Term.proj `Fintype.card_pos_iff "." (fieldIdx "2")) [(Term.anonymousCtor "⟨" [(numLit "1")] "⟩")])))
     []
     («term_$__»
      (Term.app `lt_irreflₓ [`c])
      "$"
      (calc
       "calc"
       [(calcStep
         («term_=_»
          `c
          "="
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» («term_^_» `a "^" `c) "=" (numLit "1"))))])
           "."
           `card))
         ":="
         («term_$__»
          (Term.app `congr_argₓ [`card])
          "$"
          (Term.byTactic
           "by"
           (Tactic.tacticSeq
            (Tactic.tacticSeq1Indented
             [(group
               (Tactic.simp
                "simp"
                []
                []
                ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff) "," (Tactic.simpLemma [] [] `c)] "]"]
                [])
               [])])))))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj (Term.app `range [`c.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
           ", "
           (Term.proj
            (Term.app
             (Term.proj `univ "." `filter)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                "=>"
                («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
            "."
            `card)))
         ":="
         (Term.proj (Term.app `sum_card_order_of_eq_card_pow_eq_one [`hc0]) "." `symm))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj
             (Term.app
              (Term.proj (Term.app `range [`c.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
             "."
             `erase)
            [`d])
           ", "
           (Term.proj
            (Term.app
             (Term.proj `univ "." `filter)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
                "=>"
                («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
            "."
            `card)))
         ":="
         (Term.app
          `Eq.symm
          [(Term.app
            `sum_subset
            [(Term.app `erase_subset [(Term.hole "_") (Term.hole "_")])
             (Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`m `hm₁ `hm₂] [])]
               "=>"
               (Term.have
                "have"
                (Term.haveDecl
                 (Term.haveIdDecl
                  []
                  [(Term.typeSpec ":" («term_=_» `m "=" `d))]
                  ":="
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(group
                       (Tactic.«tactic_<;>_»
                        (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationWildcard "*"))])
                        "<;>"
                        (Tactic.cc "cc"))
                       [])])))))
                []
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.«tactic_<;>_»
                      (Tactic.simpAll "simp_all" [] [] ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff)] "]"])
                      "<;>"
                      (Tactic.exact "exact" `h0))
                     [])]))))))])]))
        (calcStep
         («term_≤_»
          (Term.hole "_")
          "≤"
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj
             (Term.app
              (Term.proj (Term.app `range [`c.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
             "."
             `erase)
            [`d])
           ", "
           (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
         ":="
         (Term.app
          `sum_le_sum
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`m `hm] [])]
             "=>"
             (Term.have
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                [`hmc []]
                [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `c))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.«tactic_<;>_»
                      (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationHyp [`hm] []))])
                      "<;>"
                      (Tactic.tauto "tauto" []))
                     [])])))))
              []
              (Term.app
               (Term.proj
                (Term.app
                 (Term.proj `imp_iff_not_or "." (fieldIdx "1"))
                 [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hmc])])
                "."
                `elim)
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`h] [])]
                  "=>"
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(group
                       (Tactic.simp
                        "simp"
                        []
                        []
                        ["["
                         [(Tactic.simpLemma
                           []
                           []
                           (Term.app (Term.proj `Nat.le_zero_iffₓ "." (fieldIdx "1")) [(Term.app `le_of_not_gtₓ [`h])]))
                          ","
                          (Tactic.simpLemma [] [] `Nat.zero_leₓ)]
                         "]"]
                        [])
                       [])])))))
                (Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder [`h] [])]
                  "=>"
                  (Term.byTactic
                   "by"
                   (Tactic.tacticSeq
                    (Tactic.tacticSeq1Indented
                     [(group
                       (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h)] "]") [])
                       [])])))))]))))]))
        (calcStep
         («term_<_»
          (Term.hole "_")
          "<"
          (Init.Logic.«term_+_»
           (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])
           "+"
           (Algebra.BigOperators.Basic.«term∑_in_,_»
            "∑"
            (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
            " in "
            (Term.app
             (Term.proj
              (Term.app
               (Term.proj (Term.app `range [`c.succ]) "." `filter)
               [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
              "."
              `erase)
             [`d])
            ", "
            (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))
         ":="
         (Term.app
          `lt_add_of_pos_left
          [(Term.hole "_")
           (Term.app
            `totient_pos
            [(Term.app
              `Nat.pos_of_ne_zeroₓ
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`h] [])]
                 "=>"
                 (Term.app
                  (Term.proj `pos_iff_ne_zero "." (fieldIdx "1"))
                  [`hc0 («term_$__» `eq_zero_of_zero_dvd "$" (Term.subst `h "▸" [`hd]))])))])])]))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            `insert
            [`d
             (Term.app
              (Term.proj
               (Term.app
                (Term.proj (Term.app `range [`c.succ]) "." `filter)
                [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
               "."
               `erase)
              [`d])])
           ", "
           (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
         ":="
         (Term.app
          `Eq.symm
          [(Term.app
            `sum_insert
            [(Term.byTactic
              "by"
              (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] []) [])])))])]))
        (calcStep
         («term_=_»
          (Term.hole "_")
          "="
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj (Term.app `range [`c.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
           ", "
           (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
         ":="
         (Term.app
          `Finset.sum_congr
          [(Term.app
            `Finset.insert_erase
            [(Term.app
              (Term.proj `mem_filter "." (fieldIdx "2"))
              [(Term.anonymousCtor
                "⟨"
                [(Term.app
                  (Term.proj `mem_range "." (fieldIdx "2"))
                  [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
                 ","
                 `hd]
                "⟩")])])
           (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
        (calcStep («term_=_» (Term.hole "_") "=" `c) ":=" (Term.app `sum_totient [(Term.hole "_")]))])))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'Lean.Parser.Term.have.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.let
   "let"
   (Term.letDecl (Term.letIdDecl `c [] [] ":=" (Term.app `Fintype.card [`α])))
   []
   (Term.have
    "have"
    (Term.haveDecl
     (Term.haveIdDecl
      [`hc0 []]
      [(Term.typeSpec ":" («term_<_» (numLit "0") "<" `c))]
      ":="
      (Term.app (Term.proj `Fintype.card_pos_iff "." (fieldIdx "2")) [(Term.anonymousCtor "⟨" [(numLit "1")] "⟩")])))
    []
    («term_$__»
     (Term.app `lt_irreflₓ [`c])
     "$"
     (calc
      "calc"
      [(calcStep
        («term_=_»
         `c
         "="
         (Term.proj
          (Term.app
           (Term.proj `univ "." `filter)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
              "=>"
              («term_=_» («term_^_» `a "^" `c) "=" (numLit "1"))))])
          "."
          `card))
        ":="
        («term_$__»
         (Term.app `congr_argₓ [`card])
         "$"
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group
              (Tactic.simp
               "simp"
               []
               []
               ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff) "," (Tactic.simpLemma [] [] `c)] "]"]
               [])
              [])])))))
       (calcStep
        («term_=_»
         (Term.hole "_")
         "="
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj (Term.app `range [`c.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
          ", "
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
           "."
           `card)))
        ":="
        (Term.proj (Term.app `sum_card_order_of_eq_card_pow_eq_one [`hc0]) "." `symm))
       (calcStep
        («term_=_»
         (Term.hole "_")
         "="
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj
            (Term.app
             (Term.proj (Term.app `range [`c.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
            "."
            `erase)
           [`d])
          ", "
          (Term.proj
           (Term.app
            (Term.proj `univ "." `filter)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
               "=>"
               («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
           "."
           `card)))
        ":="
        (Term.app
         `Eq.symm
         [(Term.app
           `sum_subset
           [(Term.app `erase_subset [(Term.hole "_") (Term.hole "_")])
            (Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`m `hm₁ `hm₂] [])]
              "=>"
              (Term.have
               "have"
               (Term.haveDecl
                (Term.haveIdDecl
                 []
                 [(Term.typeSpec ":" («term_=_» `m "=" `d))]
                 ":="
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(group
                      (Tactic.«tactic_<;>_»
                       (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationWildcard "*"))])
                       "<;>"
                       (Tactic.cc "cc"))
                      [])])))))
               []
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.«tactic_<;>_»
                     (Tactic.simpAll "simp_all" [] [] ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff)] "]"])
                     "<;>"
                     (Tactic.exact "exact" `h0))
                    [])]))))))])]))
       (calcStep
        («term_≤_»
         (Term.hole "_")
         "≤"
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj
            (Term.app
             (Term.proj (Term.app `range [`c.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
            "."
            `erase)
           [`d])
          ", "
          (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
        ":="
        (Term.app
         `sum_le_sum
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`m `hm] [])]
            "=>"
            (Term.have
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               [`hmc []]
               [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `c))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.«tactic_<;>_»
                     (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationHyp [`hm] []))])
                     "<;>"
                     (Tactic.tauto "tauto" []))
                    [])])))))
             []
             (Term.app
              (Term.proj
               (Term.app
                (Term.proj `imp_iff_not_or "." (fieldIdx "1"))
                [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hmc])])
               "."
               `elim)
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`h] [])]
                 "=>"
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(group
                      (Tactic.simp
                       "simp"
                       []
                       []
                       ["["
                        [(Tactic.simpLemma
                          []
                          []
                          (Term.app (Term.proj `Nat.le_zero_iffₓ "." (fieldIdx "1")) [(Term.app `le_of_not_gtₓ [`h])]))
                         ","
                         (Tactic.simpLemma [] [] `Nat.zero_leₓ)]
                        "]"]
                       [])
                      [])])))))
               (Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder [`h] [])]
                 "=>"
                 (Term.byTactic
                  "by"
                  (Tactic.tacticSeq
                   (Tactic.tacticSeq1Indented
                    [(group
                      (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h)] "]") [])
                      [])])))))]))))]))
       (calcStep
        («term_<_»
         (Term.hole "_")
         "<"
         (Init.Logic.«term_+_»
          (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])
          "+"
          (Algebra.BigOperators.Basic.«term∑_in_,_»
           "∑"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
           " in "
           (Term.app
            (Term.proj
             (Term.app
              (Term.proj (Term.app `range [`c.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
             "."
             `erase)
            [`d])
           ", "
           (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))
        ":="
        (Term.app
         `lt_add_of_pos_left
         [(Term.hole "_")
          (Term.app
           `totient_pos
           [(Term.app
             `Nat.pos_of_ne_zeroₓ
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`h] [])]
                "=>"
                (Term.app
                 (Term.proj `pos_iff_ne_zero "." (fieldIdx "1"))
                 [`hc0 («term_$__» `eq_zero_of_zero_dvd "$" (Term.subst `h "▸" [`hd]))])))])])]))
       (calcStep
        («term_=_»
         (Term.hole "_")
         "="
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           `insert
           [`d
            (Term.app
             (Term.proj
              (Term.app
               (Term.proj (Term.app `range [`c.succ]) "." `filter)
               [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
              "."
              `erase)
             [`d])])
          ", "
          (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
        ":="
        (Term.app
         `Eq.symm
         [(Term.app
           `sum_insert
           [(Term.byTactic
             "by"
             (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] []) [])])))])]))
       (calcStep
        («term_=_»
         (Term.hole "_")
         "="
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj (Term.app `range [`c.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
          ", "
          (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
        ":="
        (Term.app
         `Finset.sum_congr
         [(Term.app
           `Finset.insert_erase
           [(Term.app
             (Term.proj `mem_filter "." (fieldIdx "2"))
             [(Term.anonymousCtor
               "⟨"
               [(Term.app
                 (Term.proj `mem_range "." (fieldIdx "2"))
                 [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
                ","
                `hd]
               "⟩")])])
          (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
       (calcStep («term_=_» (Term.hole "_") "=" `c) ":=" (Term.app `sum_totient [(Term.hole "_")]))]))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.let', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.let', expected 'Lean.Parser.Term.let.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.have
   "have"
   (Term.haveDecl
    (Term.haveIdDecl
     [`hc0 []]
     [(Term.typeSpec ":" («term_<_» (numLit "0") "<" `c))]
     ":="
     (Term.app (Term.proj `Fintype.card_pos_iff "." (fieldIdx "2")) [(Term.anonymousCtor "⟨" [(numLit "1")] "⟩")])))
   []
   («term_$__»
    (Term.app `lt_irreflₓ [`c])
    "$"
    (calc
     "calc"
     [(calcStep
       («term_=_»
        `c
        "="
        (Term.proj
         (Term.app
          (Term.proj `univ "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
             "=>"
             («term_=_» («term_^_» `a "^" `c) "=" (numLit "1"))))])
         "."
         `card))
       ":="
       («term_$__»
        (Term.app `congr_argₓ [`card])
        "$"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(group
             (Tactic.simp
              "simp"
              []
              []
              ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff) "," (Tactic.simpLemma [] [] `c)] "]"]
              [])
             [])])))))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
         ", "
         (Term.proj
          (Term.app
           (Term.proj `univ "." `filter)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
              "=>"
              («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
          "."
          `card)))
       ":="
       (Term.proj (Term.app `sum_card_order_of_eq_card_pow_eq_one [`hc0]) "." `symm))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          (Term.proj
           (Term.app
            (Term.proj (Term.app `range [`c.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
           "."
           `erase)
          [`d])
         ", "
         (Term.proj
          (Term.app
           (Term.proj `univ "." `filter)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
              "=>"
              («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
          "."
          `card)))
       ":="
       (Term.app
        `Eq.symm
        [(Term.app
          `sum_subset
          [(Term.app `erase_subset [(Term.hole "_") (Term.hole "_")])
           (Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`m `hm₁ `hm₂] [])]
             "=>"
             (Term.have
              "have"
              (Term.haveDecl
               (Term.haveIdDecl
                []
                [(Term.typeSpec ":" («term_=_» `m "=" `d))]
                ":="
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.«tactic_<;>_»
                      (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationWildcard "*"))])
                      "<;>"
                      (Tactic.cc "cc"))
                     [])])))))
              []
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.«tactic_<;>_»
                    (Tactic.simpAll "simp_all" [] [] ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff)] "]"])
                    "<;>"
                    (Tactic.exact "exact" `h0))
                   [])]))))))])]))
      (calcStep
       («term_≤_»
        (Term.hole "_")
        "≤"
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          (Term.proj
           (Term.app
            (Term.proj (Term.app `range [`c.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
           "."
           `erase)
          [`d])
         ", "
         (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
       ":="
       (Term.app
        `sum_le_sum
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`m `hm] [])]
           "=>"
           (Term.have
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              [`hmc []]
              [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `c))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.«tactic_<;>_»
                    (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationHyp [`hm] []))])
                    "<;>"
                    (Tactic.tauto "tauto" []))
                   [])])))))
            []
            (Term.app
             (Term.proj
              (Term.app
               (Term.proj `imp_iff_not_or "." (fieldIdx "1"))
               [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hmc])])
              "."
              `elim)
             [(Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`h] [])]
                "=>"
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.simp
                      "simp"
                      []
                      []
                      ["["
                       [(Tactic.simpLemma
                         []
                         []
                         (Term.app (Term.proj `Nat.le_zero_iffₓ "." (fieldIdx "1")) [(Term.app `le_of_not_gtₓ [`h])]))
                        ","
                        (Tactic.simpLemma [] [] `Nat.zero_leₓ)]
                       "]"]
                      [])
                     [])])))))
              (Term.fun
               "fun"
               (Term.basicFun
                [(Term.simpleBinder [`h] [])]
                "=>"
                (Term.byTactic
                 "by"
                 (Tactic.tacticSeq
                  (Tactic.tacticSeq1Indented
                   [(group
                     (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h)] "]") [])
                     [])])))))]))))]))
      (calcStep
       («term_<_»
        (Term.hole "_")
        "<"
        (Init.Logic.«term_+_»
         (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])
         "+"
         (Algebra.BigOperators.Basic.«term∑_in_,_»
          "∑"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
          " in "
          (Term.app
           (Term.proj
            (Term.app
             (Term.proj (Term.app `range [`c.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
            "."
            `erase)
           [`d])
          ", "
          (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))
       ":="
       (Term.app
        `lt_add_of_pos_left
        [(Term.hole "_")
         (Term.app
          `totient_pos
          [(Term.app
            `Nat.pos_of_ne_zeroₓ
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`h] [])]
               "=>"
               (Term.app
                (Term.proj `pos_iff_ne_zero "." (fieldIdx "1"))
                [`hc0 («term_$__» `eq_zero_of_zero_dvd "$" (Term.subst `h "▸" [`hd]))])))])])]))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          `insert
          [`d
           (Term.app
            (Term.proj
             (Term.app
              (Term.proj (Term.app `range [`c.succ]) "." `filter)
              [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
             "."
             `erase)
            [`d])])
         ", "
         (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
       ":="
       (Term.app
        `Eq.symm
        [(Term.app
          `sum_insert
          [(Term.byTactic
            "by"
            (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] []) [])])))])]))
      (calcStep
       («term_=_»
        (Term.hole "_")
        "="
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
         ", "
         (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
       ":="
       (Term.app
        `Finset.sum_congr
        [(Term.app
          `Finset.insert_erase
          [(Term.app
            (Term.proj `mem_filter "." (fieldIdx "2"))
            [(Term.anonymousCtor
              "⟨"
              [(Term.app
                (Term.proj `mem_range "." (fieldIdx "2"))
                [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
               ","
               `hd]
              "⟩")])])
         (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
      (calcStep («term_=_» (Term.hole "_") "=" `c) ":=" (Term.app `sum_totient [(Term.hole "_")]))])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.have', expected 'Lean.Parser.Term.have.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_$__»
   (Term.app `lt_irreflₓ [`c])
   "$"
   (calc
    "calc"
    [(calcStep
      («term_=_»
       `c
       "="
       (Term.proj
        (Term.app
         (Term.proj `univ "." `filter)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
            "=>"
            («term_=_» («term_^_» `a "^" `c) "=" (numLit "1"))))])
        "."
        `card))
      ":="
      («term_$__»
       (Term.app `congr_argₓ [`card])
       "$"
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(group
            (Tactic.simp
             "simp"
             []
             []
             ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff) "," (Tactic.simpLemma [] [] `c)] "]"]
             [])
            [])])))))
     (calcStep
      («term_=_»
       (Term.hole "_")
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
        " in "
        (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
        ", "
        (Term.proj
         (Term.app
          (Term.proj `univ "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
             "=>"
             («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
         "."
         `card)))
      ":="
      (Term.proj (Term.app `sum_card_order_of_eq_card_pow_eq_one [`hc0]) "." `symm))
     (calcStep
      («term_=_»
       (Term.hole "_")
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
        " in "
        (Term.app
         (Term.proj
          (Term.app
           (Term.proj (Term.app `range [`c.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
          "."
          `erase)
         [`d])
        ", "
        (Term.proj
         (Term.app
          (Term.proj `univ "." `filter)
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
             "=>"
             («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
         "."
         `card)))
      ":="
      (Term.app
       `Eq.symm
       [(Term.app
         `sum_subset
         [(Term.app `erase_subset [(Term.hole "_") (Term.hole "_")])
          (Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`m `hm₁ `hm₂] [])]
            "=>"
            (Term.have
             "have"
             (Term.haveDecl
              (Term.haveIdDecl
               []
               [(Term.typeSpec ":" («term_=_» `m "=" `d))]
               ":="
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.«tactic_<;>_»
                     (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationWildcard "*"))])
                     "<;>"
                     (Tactic.cc "cc"))
                    [])])))))
             []
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(group
                  (Tactic.«tactic_<;>_»
                   (Tactic.simpAll "simp_all" [] [] ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff)] "]"])
                   "<;>"
                   (Tactic.exact "exact" `h0))
                  [])]))))))])]))
     (calcStep
      («term_≤_»
       (Term.hole "_")
       "≤"
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
        " in "
        (Term.app
         (Term.proj
          (Term.app
           (Term.proj (Term.app `range [`c.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
          "."
          `erase)
         [`d])
        ", "
        (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
      ":="
      (Term.app
       `sum_le_sum
       [(Term.fun
         "fun"
         (Term.basicFun
          [(Term.simpleBinder [`m `hm] [])]
          "=>"
          (Term.have
           "have"
           (Term.haveDecl
            (Term.haveIdDecl
             [`hmc []]
             [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `c))]
             ":="
             (Term.byTactic
              "by"
              (Tactic.tacticSeq
               (Tactic.tacticSeq1Indented
                [(group
                  (Tactic.«tactic_<;>_»
                   (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationHyp [`hm] []))])
                   "<;>"
                   (Tactic.tauto "tauto" []))
                  [])])))))
           []
           (Term.app
            (Term.proj
             (Term.app
              (Term.proj `imp_iff_not_or "." (fieldIdx "1"))
              [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hmc])])
             "."
             `elim)
            [(Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`h] [])]
               "=>"
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group
                    (Tactic.simp
                     "simp"
                     []
                     []
                     ["["
                      [(Tactic.simpLemma
                        []
                        []
                        (Term.app (Term.proj `Nat.le_zero_iffₓ "." (fieldIdx "1")) [(Term.app `le_of_not_gtₓ [`h])]))
                       ","
                       (Tactic.simpLemma [] [] `Nat.zero_leₓ)]
                      "]"]
                     [])
                    [])])))))
             (Term.fun
              "fun"
              (Term.basicFun
               [(Term.simpleBinder [`h] [])]
               "=>"
               (Term.byTactic
                "by"
                (Tactic.tacticSeq
                 (Tactic.tacticSeq1Indented
                  [(group (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h)] "]") []) [])])))))]))))]))
     (calcStep
      («term_<_»
       (Term.hole "_")
       "<"
       (Init.Logic.«term_+_»
        (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])
        "+"
        (Algebra.BigOperators.Basic.«term∑_in_,_»
         "∑"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
         " in "
         (Term.app
          (Term.proj
           (Term.app
            (Term.proj (Term.app `range [`c.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
           "."
           `erase)
          [`d])
         ", "
         (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))
      ":="
      (Term.app
       `lt_add_of_pos_left
       [(Term.hole "_")
        (Term.app
         `totient_pos
         [(Term.app
           `Nat.pos_of_ne_zeroₓ
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`h] [])]
              "=>"
              (Term.app
               (Term.proj `pos_iff_ne_zero "." (fieldIdx "1"))
               [`hc0 («term_$__» `eq_zero_of_zero_dvd "$" (Term.subst `h "▸" [`hd]))])))])])]))
     (calcStep
      («term_=_»
       (Term.hole "_")
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
        " in "
        (Term.app
         `insert
         [`d
          (Term.app
           (Term.proj
            (Term.app
             (Term.proj (Term.app `range [`c.succ]) "." `filter)
             [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
            "."
            `erase)
           [`d])])
        ", "
        (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
      ":="
      (Term.app
       `Eq.symm
       [(Term.app
         `sum_insert
         [(Term.byTactic
           "by"
           (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] []) [])])))])]))
     (calcStep
      («term_=_»
       (Term.hole "_")
       "="
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
        " in "
        (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
        ", "
        (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
      ":="
      (Term.app
       `Finset.sum_congr
       [(Term.app
         `Finset.insert_erase
         [(Term.app
           (Term.proj `mem_filter "." (fieldIdx "2"))
           [(Term.anonymousCtor
             "⟨"
             [(Term.app
               (Term.proj `mem_range "." (fieldIdx "2"))
               [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
              ","
              `hd]
             "⟩")])])
        (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
     (calcStep («term_=_» (Term.hole "_") "=" `c) ":=" (Term.app `sum_totient [(Term.hole "_")]))]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_$__»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (calc
   "calc"
   [(calcStep
     («term_=_»
      `c
      "="
      (Term.proj
       (Term.app
        (Term.proj `univ "." `filter)
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
           "=>"
           («term_=_» («term_^_» `a "^" `c) "=" (numLit "1"))))])
       "."
       `card))
     ":="
     («term_$__»
      (Term.app `congr_argₓ [`card])
      "$"
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(group
           (Tactic.simp
            "simp"
            []
            []
            ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff) "," (Tactic.simpLemma [] [] `c)] "]"]
            [])
           [])])))))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
       ", "
       (Term.proj
        (Term.app
         (Term.proj `univ "." `filter)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
            "=>"
            («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
        "."
        `card)))
     ":="
     (Term.proj (Term.app `sum_card_order_of_eq_card_pow_eq_one [`hc0]) "." `symm))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app
        (Term.proj
         (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
         "."
         `erase)
        [`d])
       ", "
       (Term.proj
        (Term.app
         (Term.proj `univ "." `filter)
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder [`a] [(Term.typeSpec ":" `α)])]
            "=>"
            («term_=_» (Term.app `orderOf [`a]) "=" `m)))])
        "."
        `card)))
     ":="
     (Term.app
      `Eq.symm
      [(Term.app
        `sum_subset
        [(Term.app `erase_subset [(Term.hole "_") (Term.hole "_")])
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`m `hm₁ `hm₂] [])]
           "=>"
           (Term.have
            "have"
            (Term.haveDecl
             (Term.haveIdDecl
              []
              [(Term.typeSpec ":" («term_=_» `m "=" `d))]
              ":="
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.«tactic_<;>_»
                    (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationWildcard "*"))])
                    "<;>"
                    (Tactic.cc "cc"))
                   [])])))))
            []
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(group
                 (Tactic.«tactic_<;>_»
                  (Tactic.simpAll "simp_all" [] [] ["[" [(Tactic.simpLemma [] [] `Finset.ext_iff)] "]"])
                  "<;>"
                  (Tactic.exact "exact" `h0))
                 [])]))))))])]))
    (calcStep
     («term_≤_»
      (Term.hole "_")
      "≤"
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app
        (Term.proj
         (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
         "."
         `erase)
        [`d])
       ", "
       (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
     ":="
     (Term.app
      `sum_le_sum
      [(Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`m `hm] [])]
         "=>"
         (Term.have
          "have"
          (Term.haveDecl
           (Term.haveIdDecl
            [`hmc []]
            [(Term.typeSpec ":" (Init.Core.«term_∣_» `m " ∣ " `c))]
            ":="
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(group
                 (Tactic.«tactic_<;>_»
                  (Tactic.simp "simp" [] [] [] [(Tactic.location "at" (Tactic.locationHyp [`hm] []))])
                  "<;>"
                  (Tactic.tauto "tauto" []))
                 [])])))))
          []
          (Term.app
           (Term.proj
            (Term.app
             (Term.proj `imp_iff_not_or "." (fieldIdx "1"))
             [(Term.app `card_order_of_eq_totient_aux₁ [`hn `hmc])])
            "."
            `elim)
           [(Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`h] [])]
              "=>"
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group
                   (Tactic.simp
                    "simp"
                    []
                    []
                    ["["
                     [(Tactic.simpLemma
                       []
                       []
                       (Term.app (Term.proj `Nat.le_zero_iffₓ "." (fieldIdx "1")) [(Term.app `le_of_not_gtₓ [`h])]))
                      ","
                      (Tactic.simpLemma [] [] `Nat.zero_leₓ)]
                     "]"]
                    [])
                   [])])))))
            (Term.fun
             "fun"
             (Term.basicFun
              [(Term.simpleBinder [`h] [])]
              "=>"
              (Term.byTactic
               "by"
               (Tactic.tacticSeq
                (Tactic.tacticSeq1Indented
                 [(group (Tactic.rwSeq "rw" [] (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `h)] "]") []) [])])))))]))))]))
    (calcStep
     («term_<_»
      (Term.hole "_")
      "<"
      (Init.Logic.«term_+_»
       (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`d])
       "+"
       (Algebra.BigOperators.Basic.«term∑_in_,_»
        "∑"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
        " in "
        (Term.app
         (Term.proj
          (Term.app
           (Term.proj (Term.app `range [`c.succ]) "." `filter)
           [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
          "."
          `erase)
         [`d])
        ", "
        (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))))
     ":="
     (Term.app
      `lt_add_of_pos_left
      [(Term.hole "_")
       (Term.app
        `totient_pos
        [(Term.app
          `Nat.pos_of_ne_zeroₓ
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder [`h] [])]
             "=>"
             (Term.app
              (Term.proj `pos_iff_ne_zero "." (fieldIdx "1"))
              [`hc0 («term_$__» `eq_zero_of_zero_dvd "$" (Term.subst `h "▸" [`hd]))])))])])]))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app
        `insert
        [`d
         (Term.app
          (Term.proj
           (Term.app
            (Term.proj (Term.app `range [`c.succ]) "." `filter)
            [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
           "."
           `erase)
          [`d])])
       ", "
       (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
     ":="
     (Term.app
      `Eq.symm
      [(Term.app
        `sum_insert
        [(Term.byTactic
          "by"
          (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] []) [])])))])]))
    (calcStep
     («term_=_»
      (Term.hole "_")
      "="
      (Algebra.BigOperators.Basic.«term∑_in_,_»
       "∑"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
       " in "
       (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
       ", "
       (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
     ":="
     (Term.app
      `Finset.sum_congr
      [(Term.app
        `Finset.insert_erase
        [(Term.app
          (Term.proj `mem_filter "." (fieldIdx "2"))
          [(Term.anonymousCtor
            "⟨"
            [(Term.app
              (Term.proj `mem_range "." (fieldIdx "2"))
              [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
             ","
             `hd]
            "⟩")])])
       (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))]))
    (calcStep («term_=_» (Term.hole "_") "=" `c) ":=" (Term.app `sum_totient [(Term.hole "_")]))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calc', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calcStep', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `sum_totient [(Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `sum_totient
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_=_» (Term.hole "_") "=" `c)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `c
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'calcStep', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, term))
  (Term.app
   `Finset.sum_congr
   [(Term.app
     `Finset.insert_erase
     [(Term.app
       (Term.proj `mem_filter "." (fieldIdx "2"))
       [(Term.anonymousCtor
         "⟨"
         [(Term.app
           (Term.proj `mem_range "." (fieldIdx "2"))
           [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
          ","
          `hd]
         "⟩")])])
    (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun "fun" (Term.basicFun [(Term.simpleBinder [(Term.hole "_") (Term.hole "_")] [])] "=>" `rfl))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `rfl
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.simpleBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  (Term.app
   `Finset.insert_erase
   [(Term.app
     (Term.proj `mem_filter "." (fieldIdx "2"))
     [(Term.anonymousCtor
       "⟨"
       [(Term.app
         (Term.proj `mem_range "." (fieldIdx "2"))
         [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
        ","
        `hd]
       "⟩")])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app
   (Term.proj `mem_filter "." (fieldIdx "2"))
   [(Term.anonymousCtor
     "⟨"
     [(Term.app
       (Term.proj `mem_range "." (fieldIdx "2"))
       [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
      ","
      `hd]
     "⟩")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.anonymousCtor
   "⟨"
   [(Term.app (Term.proj `mem_range "." (fieldIdx "2")) [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
    ","
    `hd]
   "⟩")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.anonymousCtor.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `hd
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app (Term.proj `mem_range "." (fieldIdx "2")) [(Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `lt_succ_of_le [(Term.app `le_of_dvd [`hc0 `hd])])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `le_of_dvd [`hc0 `hd])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `hd
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `hc0
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `le_of_dvd
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" [(Term.app `le_of_dvd [`hc0 `hd]) []] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `lt_succ_of_le
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
 "("
 [(Term.app `lt_succ_of_le [(Term.paren "(" [(Term.app `le_of_dvd [`hc0 `hd]) []] ")")]) []]
 ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Term.proj `mem_range "." (fieldIdx "2"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `mem_range
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Term.proj `mem_filter "." (fieldIdx "2"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `mem_filter
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
 "("
 [(Term.app
   (Term.proj `mem_filter "." (fieldIdx "2"))
   [(Term.anonymousCtor
     "⟨"
     [(Term.app
       (Term.proj `mem_range "." (fieldIdx "2"))
       [(Term.paren
         "("
         [(Term.app `lt_succ_of_le [(Term.paren "(" [(Term.app `le_of_dvd [`hc0 `hd]) []] ")")]) []]
         ")")])
      ","
      `hd]
     "⟩")])
  []]
 ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `Finset.insert_erase
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren
 "("
 [(Term.app
   `Finset.insert_erase
   [(Term.paren
     "("
     [(Term.app
       (Term.proj `mem_filter "." (fieldIdx "2"))
       [(Term.anonymousCtor
         "⟨"
         [(Term.app
           (Term.proj `mem_range "." (fieldIdx "2"))
           [(Term.paren
             "("
             [(Term.app `lt_succ_of_le [(Term.paren "(" [(Term.app `le_of_dvd [`hc0 `hd]) []] ")")]) []]
             ")")])
          ","
          `hd]
         "⟩")])
      []]
     ")")])
  []]
 ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `Finset.sum_congr
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_=_»
   (Term.hole "_")
   "="
   (Algebra.BigOperators.Basic.«term∑_in_,_»
    "∑"
    (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
    " in "
    (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
    ", "
    (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Algebra.BigOperators.Basic.«term∑_in_,_»
   "∑"
   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `m)] []))
   " in "
   (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
   ", "
   (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Algebra.BigOperators.Basic.«term∑_in_,_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app (Nat.Data.Nat.Totient.termφ "φ") [`m])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `m
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Nat.Data.Nat.Totient.termφ "φ")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Nat.Data.Nat.Totient.termφ', expected 'antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app (Term.proj (Term.app `range [`c.succ]) "." `filter) [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Init.Core.«term_∣_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `c
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 51 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 50, term))
  (Term.cdot "·")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.cdot', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.cdot', expected 'Lean.Parser.Term.cdot.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 50 >? 1024, (none, [anonymous]) <=? (some 50, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 50, (some 51, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" [(Init.Core.«term_∣_» (Term.cdot "·") " ∣ " `c) []] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  (Term.proj (Term.app `range [`c.succ]) "." `filter)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.proj', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  (Term.app `range [`c.succ])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `c.succ
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `range
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" [(Term.app `range [`c.succ]) []] ")")
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.explicitBinders', expected 'Mathlib.ExtendedBinder.extBinders'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
theorem
  card_order_of_eq_totient_aux₂
  { d : ℕ } ( hd : d ∣ Fintype.card α ) : univ . filter fun a : α => orderOf a = d . card = φ d
  :=
    by_contradiction
      $
      fun
        h
          =>
          have
            h0
              : univ . filter fun a : α => orderOf a = d . card = 0
              :=
              not_not . 1 mt pos_iff_ne_zero . 2 mt card_order_of_eq_totient_aux₁ hn hd h
            let
              c := Fintype.card α
              have
                hc0 : 0 < c := Fintype.card_pos_iff . 2 ⟨ 1 ⟩
                lt_irreflₓ c
                  $
                  calc
                    c = univ . filter fun a : α => a ^ c = 1 . card := congr_argₓ card $ by simp [ Finset.ext_iff , c ]
                      _ = ∑ m in range c.succ . filter · ∣ c , univ . filter fun a : α => orderOf a = m . card
                        :=
                        sum_card_order_of_eq_card_pow_eq_one hc0 . symm
                      _ = ∑ m in range c.succ . filter · ∣ c . erase d , univ . filter fun a : α => orderOf a = m . card
                        :=
                        Eq.symm
                          sum_subset
                            erase_subset _ _
                              fun
                                m hm₁ hm₂
                                  =>
                                  have : m = d := by simp at * <;> cc by simp_all [ Finset.ext_iff ] <;> exact h0
                      _ ≤ ∑ m in range c.succ . filter · ∣ c . erase d , φ m
                        :=
                        sum_le_sum
                          fun
                            m hm
                              =>
                              have
                                hmc : m ∣ c := by simp at hm <;> tauto
                                imp_iff_not_or . 1 card_order_of_eq_totient_aux₁ hn hmc . elim
                                  fun h => by simp [ Nat.le_zero_iffₓ . 1 le_of_not_gtₓ h , Nat.zero_leₓ ]
                                    fun h => by rw [ h ]
                      _ < φ d + ∑ m in range c.succ . filter · ∣ c . erase d , φ m
                        :=
                        lt_add_of_pos_left
                          _
                            totient_pos
                              Nat.pos_of_ne_zeroₓ fun h => pos_iff_ne_zero . 1 hc0 eq_zero_of_zero_dvd $ h ▸ hd
                      _ = ∑ m in insert d range c.succ . filter · ∣ c . erase d , φ m := Eq.symm sum_insert by simp
                      _ = ∑ m in range c.succ . filter · ∣ c , φ m
                        :=
                        Finset.sum_congr
                          Finset.insert_erase mem_filter . 2 ⟨ mem_range . 2 lt_succ_of_le le_of_dvd hc0 hd , hd ⟩
                            fun _ _ => rfl
                      _ = c := sum_totient _

theorem is_cyclic_of_card_pow_eq_one_le : IsCyclic α :=
  have : (univ.filter fun a : α => orderOf a = Fintype.card α).Nonempty :=
    card_pos.1 $ by
      rw [card_order_of_eq_totient_aux₂ hn dvd_rfl] <;> exact totient_pos (Fintype.card_pos_iff.2 ⟨1⟩)
  let ⟨x, hx⟩ := this
  is_cyclic_of_order_of_eq_card x (Finset.mem_filter.1 hx).2

theorem is_add_cyclic_of_card_pow_eq_one_le {α} [AddGroupₓ α] [DecidableEq α] [Fintype α]
    (hn : ∀ n : ℕ, 0 < n → (univ.filter fun a : α => n • a = 0).card ≤ n) : IsAddCyclic α := by
  obtain ⟨g, hg⟩ := @is_cyclic_of_card_pow_eq_one_le (Multiplicative α) _ _ _ hn
  exact ⟨⟨g, hg⟩⟩

attribute [to_additive is_cyclic_of_card_pow_eq_one_le] is_add_cyclic_of_card_pow_eq_one_le

end Totient

theorem IsCyclic.card_order_of_eq_totient [IsCyclic α] [Fintype α] {d : ℕ} (hd : d ∣ Fintype.card α) :
    (univ.filter fun a : α => orderOf a = d).card = totient d := by
  classical
  apply card_order_of_eq_totient_aux₂ (fun n => IsCyclic.card_pow_eq_one_le) hd

theorem IsAddCyclic.card_order_of_eq_totient {α} [AddGroupₓ α] [IsAddCyclic α] [Fintype α] {d : ℕ}
    (hd : d ∣ Fintype.card α) : (univ.filter fun a : α => addOrderOf a = d).card = totient d := by
  obtain ⟨g, hg⟩ := id ‹IsAddCyclic α›
  exact @IsCyclic.card_order_of_eq_totient (Multiplicative α) _ ⟨⟨g, hg⟩⟩ _ _ hd

attribute [to_additive IsCyclic.card_order_of_eq_totient] IsAddCyclic.card_order_of_eq_totient

/--  A finite group of prime order is simple. -/
@[to_additive]
theorem is_simple_group_of_prime_card {α : Type u} [Groupₓ α] [Fintype α] {p : ℕ} [hp : Fact p.prime]
    (h : Fintype.card α = p) : IsSimpleGroup α :=
  ⟨by
    have h' := Nat.Prime.one_lt (Fact.out p.prime)
    rw [← h] at h'
    have := Fintype.one_lt_card_iff_nontrivial.1 h'
    apply exists_pair_ne α, fun H Hn => by
    classical
    have hcard := card_subgroup_dvd_card H
    rw [h, dvd_prime (Fact.out p.prime)] at hcard
    refine' hcard.imp (fun h1 => _) fun hp => _
    ·
      have := Fintype.card_le_one_iff_subsingleton.1 (le_of_eqₓ h1)
      apply eq_bot_of_subsingleton
    ·
      exact eq_top_of_card_eq _ (hp.trans h.symm)⟩

end Cyclic

section QuotientCenter

open Subgroup

variable {G : Type _} {H : Type _} [Groupₓ G] [Groupₓ H]

/--  A group is commutative if the quotient by the center is cyclic.
  Also see `comm_group_of_cycle_center_quotient` for the `comm_group` instance. -/
@[to_additive commutative_of_add_cyclic_center_quotient
      "A group is commutative if the quotient by\n  the center is cyclic. Also see `add_comm_group_of_cycle_center_quotient`\n  for the `add_comm_group` instance."]
theorem commutative_of_cyclic_center_quotient [IsCyclic H] (f : G →* H) (hf : f.ker ≤ center G) (a b : G) :
    (a*b) = b*a :=
  let ⟨⟨x, y, (hxy : f y = x)⟩, (hx : ∀ a : f.range, a ∈ zpowers _)⟩ := IsCyclic.exists_generator f.range
  let ⟨m, hm⟩ := hx ⟨f a, a, rfl⟩
  let ⟨n, hn⟩ := hx ⟨f b, b, rfl⟩
  have hm : x ^ m = f a := by
    simpa [Subtype.ext_iff] using hm
  have hn : x ^ n = f b := by
    simpa [Subtype.ext_iff] using hn
  have ha : ((y ^ -m)*a) ∈ center G :=
    hf
      (by
        rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hm, inv_mul_selfₓ])
  have hb : ((y ^ -n)*b) ∈ center G :=
    hf
      (by
        rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hn, inv_mul_selfₓ])
  calc (a*b) = ((y ^ m)*((y ^ -m)*a)*y ^ n)*(y ^ -n)*b := by
    simp [mul_assocₓ]
    _ = ((y ^ m)*(y ^ n)*(y ^ -m)*a)*(y ^ -n)*b := by
    rw [mem_center_iff.1 ha]
    _ = (((y ^ m)*y ^ n)*y ^ -m)*a*(y ^ -n)*b := by
    simp [mul_assocₓ]
    _ = (((y ^ m)*y ^ n)*y ^ -m)*((y ^ -n)*b)*a := by
    rw [mem_center_iff.1 hb]
    _ = b*a := by
    group
    

/--  A group is commutative if the quotient by the center is cyclic. -/
@[to_additive commutativeOfAddCycleCenterQuotient "A group is commutative if the quotient by\n  the center is cyclic."]
def commGroupOfCycleCenterQuotient [IsCyclic H] (f : G →* H) (hf : f.ker ≤ center G) : CommGroupₓ G :=
  { show Groupₓ G by
      infer_instance with
    mul_comm := commutative_of_cyclic_center_quotient f hf }

end QuotientCenter

namespace IsSimpleGroup

section CommGroupₓ

variable [CommGroupₓ α] [IsSimpleGroup α]

@[to_additive IsSimpleAddGroup.is_add_cyclic]
instance (priority := 100) : IsCyclic α := by
  cases' subsingleton_or_nontrivial α with hi hi <;> have := hi
  ·
    apply is_cyclic_of_subsingleton
  ·
    obtain ⟨g, hg⟩ := exists_ne (1 : α)
    refine' ⟨⟨g, fun x => _⟩⟩
    cases' IsSimpleOrder.eq_bot_or_eq_top (Subgroup.zpowers g) with hb ht
    ·
      exfalso
      apply hg
      rw [← Subgroup.mem_bot, ← hb]
      apply Subgroup.mem_zpowers
    ·
      rw [ht]
      apply Subgroup.mem_top

@[to_additive]
theorem prime_card [Fintype α] : (Fintype.card α).Prime := by
  have h0 : 0 < Fintype.card α :=
    Fintype.card_pos_iff.2
      (by
        infer_instance)
  obtain ⟨g, hg⟩ := IsCyclic.exists_generator α
  refine' ⟨Fintype.one_lt_card_iff_nontrivial.2 inferInstance, fun n hn => _⟩
  refine' (IsSimpleOrder.eq_bot_or_eq_top (Subgroup.zpowers (g ^ n))).symm.imp _ _
  ·
    intro h
    have hgo := order_of_pow g
    rw [order_of_eq_card_of_forall_mem_zpowers hg, Nat.gcd_eq_right_iff_dvdₓ.1 hn,
      order_of_eq_card_of_forall_mem_zpowers, eq_comm, Nat.div_eq_iff_eq_mul_left (Nat.pos_of_dvd_of_posₓ hn h0) hn] at
      hgo
    ·
      exact (mul_left_cancel₀ (ne_of_gtₓ h0) ((mul_oneₓ (Fintype.card α)).trans hgo)).symm
    ·
      intro x
      rw [h]
      exact Subgroup.mem_top _
  ·
    intro h
    apply le_antisymmₓ (Nat.le_of_dvdₓ h0 hn)
    rw [← order_of_eq_card_of_forall_mem_zpowers hg]
    apply order_of_le_of_pow_eq_one (Nat.pos_of_dvd_of_posₓ hn h0)
    rw [← Subgroup.mem_bot, ← h]
    exact Subgroup.mem_zpowers _

end CommGroupₓ

end IsSimpleGroup

@[to_additive AddCommGroupₓ.is_simple_iff_is_add_cyclic_and_prime_card]
theorem CommGroupₓ.is_simple_iff_is_cyclic_and_prime_card [Fintype α] [CommGroupₓ α] :
    IsSimpleGroup α ↔ IsCyclic α ∧ (Fintype.card α).Prime := by
  constructor
  ·
    intro h
    exact ⟨IsSimpleGroup.is_cyclic, IsSimpleGroup.prime_card⟩
  ·
    rintro ⟨hc, hp⟩
    have : Fact (Fintype.card α).Prime := ⟨hp⟩
    exact is_simple_group_of_prime_card rfl

