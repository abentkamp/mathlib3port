import Mathbin.Algebra.BigOperators.Order 
import Mathbin.Data.Nat.Totient 
import Mathbin.GroupTheory.OrderOfElement 
import Mathbin.Tactic.Group

/-!
# Cyclic groups

A group `G` is called cyclic if there exists an element `g : G` such that every element of `G` is of
the form `g ^ n` for some `n : ℕ`. This file only deals with the predicate on a group to be cyclic.
For the concrete cyclic group of order `n`, see `data.zmod.basic`.

## Main definitions

* `is_cyclic` is a predicate on a group stating that the group is cyclic.

## Main statements

* `is_cyclic_of_prime_card` proves that a finite group of prime order is cyclic.
* `is_simple_group_of_prime_card`, `is_simple_group.is_cyclic`,
  and `is_simple_group.prime_card` classify finite simple abelian groups.

## Tags

cyclic group
-/


universe u

variable {α : Type u} {a : α}

section Cyclic

open_locale BigOperators

attribute [local instance] setFintype

open Subgroup

/-- A group is called *cyclic* if it is generated by a single element. -/
class IsAddCyclic (α : Type u) [AddGroupₓ α] : Prop where 
  exists_generator{} : ∃ g : α, ∀ x, x ∈ AddSubgroup.zmultiples g

/-- A group is called *cyclic* if it is generated by a single element. -/
@[toAdditive IsAddCyclic]
class IsCyclic (α : Type u) [Groupₓ α] : Prop where 
  exists_generator{} : ∃ g : α, ∀ x, x ∈ zpowers g

@[toAdditive is_add_cyclic_of_subsingleton]
instance (priority := 100) is_cyclic_of_subsingleton [Groupₓ α] [Subsingleton α] : IsCyclic α :=
  ⟨⟨1,
      fun x =>
        by 
          rw [Subsingleton.elimₓ x 1]
          exact mem_zpowers 1⟩⟩

/-- A cyclic group is always commutative. This is not an `instance` because often we have a better
proof of `comm_group`. -/
@[toAdditive
      "A cyclic group is always commutative. This is not an `instance` because often we have\n  a better proof of `add_comm_group`."]
def IsCyclic.commGroup [hg : Groupₓ α] [IsCyclic α] : CommGroupₓ α :=
  { hg with
    mul_comm :=
      fun x y =>
        show (x*y) = y*x from
          let ⟨g, hg⟩ := IsCyclic.exists_generator α 
          let ⟨n, hn⟩ := hg x 
          let ⟨m, hm⟩ := hg y 
          hm ▸ hn ▸ zpow_mul_comm _ _ _ }

variable [Groupₓ α]

@[toAdditive MonoidAddHom.map_add_cyclic]
theorem MonoidHom.map_cyclic {G : Type _} [Groupₓ G] [h : IsCyclic G] (σ : G →* G) : ∃ m : ℤ, ∀ g : G, σ g = g ^ m :=
  by 
    obtain ⟨h, hG⟩ := IsCyclic.exists_generator G 
    obtain ⟨m, hm⟩ := hG (σ h)
    use m 
    intro g 
    obtain ⟨n, rfl⟩ := hG g 
    rw [MonoidHom.map_zpow, ←hm, ←zpow_mul, ←zpow_mul']

@[toAdditive is_add_cyclic_of_order_of_eq_card]
theorem is_cyclic_of_order_of_eq_card [Fintype α] (x : α) (hx : orderOf x = Fintype.card α) : IsCyclic α :=
  by 
    classical 
    use x 
    simpRw [←SetLike.mem_coe]
    rw [←Set.eq_univ_iff_forall]
    apply Set.eq_of_subset_of_card_le (Set.subset_univ _)
    rw [Fintype.card_congr (Equivₓ.Set.univ α), ←hx, order_eq_card_zpowers]

/-- A finite group of prime order is cyclic. -/
@[toAdditive is_add_cyclic_of_prime_card]
theorem is_cyclic_of_prime_card {α : Type u} [Groupₓ α] [Fintype α] {p : ℕ} [hp : Fact p.prime]
  (h : Fintype.card α = p) : IsCyclic α :=
  ⟨by 
      obtain ⟨g, hg⟩ : ∃ g : α, g ≠ 1 
      exact
        Fintype.exists_ne_of_one_lt_card
          (by 
            rw [h]
            exact hp.1.one_lt)
          1
      classical 
      have  : Fintype.card (Subgroup.zpowers g) ∣ p
      ·
        rw [←h]
        apply card_subgroup_dvd_card 
      rw [Nat.dvd_prime hp.1] at this 
      cases this
      ·
        rw [Fintype.card_eq_one_iff] at this 
        cases' this with t ht 
        suffices  : g = 1
        ·
          contradiction 
        have hgt :=
          ht
            ⟨g,
              by 
                change g ∈ Subgroup.zpowers g 
                exact Subgroup.mem_zpowers g⟩
        rw [←ht 1] at hgt 
        change (⟨_, _⟩ : Subgroup.zpowers g) = ⟨_, _⟩ at hgt 
        simpa using hgt
      ·
        use g 
        intro x 
        rw [←h] at this 
        rw [Subgroup.eq_top_of_card_eq _ this]
        exact Subgroup.mem_top _⟩

@[toAdditive add_order_of_eq_card_of_forall_mem_zmultiples]
theorem order_of_eq_card_of_forall_mem_zpowers [Fintype α] {g : α} (hx : ∀ x, x ∈ zpowers g) :
  orderOf g = Fintype.card α :=
  by 
    classical 
    rw [←Fintype.card_congr (Equivₓ.Set.univ α), order_eq_card_zpowers]
    simp [hx]
    apply Fintype.card_of_finset' 
    simp 
    intro x 
    exact hx x

@[toAdditive Bot.is_add_cyclic]
instance Bot.is_cyclic {α : Type u} [Groupₓ α] : IsCyclic (⊥ : Subgroup α) :=
  ⟨⟨1, fun x => ⟨0, Subtype.eq$ Eq.symm (Subgroup.mem_bot.1 x.2)⟩⟩⟩

@[toAdditive AddSubgroup.is_add_cyclic]
instance Subgroup.is_cyclic {α : Type u} [Groupₓ α] [IsCyclic α] (H : Subgroup α) : IsCyclic H :=
  by 
    have  := Classical.propDecidable <;>
      exact
        let ⟨g, hg⟩ := IsCyclic.exists_generator α 
        if hx : ∃ x : α, x ∈ H ∧ x ≠ (1 : α) then
          let ⟨x, hx₁, hx₂⟩ := hx 
          let ⟨k, hk⟩ := hg x 
          have hex : ∃ n : ℕ, 0 < n ∧ g ^ n ∈ H :=
            ⟨k.nat_abs,
              Nat.pos_of_ne_zeroₓ
                fun h =>
                  hx₂$
                    by 
                      rw [←hk, Int.eq_zero_of_nat_abs_eq_zero h, zpow_zero],
              match k, hk with 
              | (k : ℕ), hk =>
                by 
                  rw [Int.nat_abs_of_nat, ←zpow_coe_nat, hk] <;> exact hx₁
              | -[1+ k], hk =>
                by 
                  rw [Int.nat_abs_of_neg_succ_of_nat, ←Subgroup.inv_mem_iff H] <;> simp_all ⟩
          ⟨⟨⟨g ^ Nat.findₓ hex, (Nat.find_specₓ hex).2⟩,
              fun ⟨x, hx⟩ =>
                let ⟨k, hk⟩ := hg x 
                have hk₁ : (g ^ (Nat.findₓ hex : ℤ)*k / Nat.findₓ hex) ∈ zpowers (g ^ Nat.findₓ hex) :=
                  ⟨k / Nat.findₓ hex,
                    by 
                      rw [←zpow_coe_nat, zpow_mul]⟩
                have hk₂ : (g ^ (Nat.findₓ hex : ℤ)*k / Nat.findₓ hex) ∈ H :=
                  by 
                    rw [zpow_mul]
                    apply H.zpow_mem 
                    exactModCast (Nat.find_specₓ hex).2
                have hk₃ : g ^ (k % Nat.findₓ hex) ∈ H :=
                  (Subgroup.mul_mem_cancel_right H hk₂).1$
                    by 
                      rw [←zpow_add, Int.mod_add_div, hk] <;> exact hx 
                have hk₄ : k % Nat.findₓ hex = (k % Nat.findₓ hex).natAbs :=
                  by 
                    rw [Int.nat_abs_of_nonneg (Int.mod_nonneg _ (Int.coe_nat_ne_zero_iff_pos.2 (Nat.find_specₓ hex).1))]
                have hk₅ : g ^ (k % Nat.findₓ hex).natAbs ∈ H :=
                  by 
                    rwa [←zpow_coe_nat, ←hk₄]
                have hk₆ : (k % (Nat.findₓ hex : ℤ)).natAbs = 0 :=
                  by_contradiction
                    fun h =>
                      Nat.find_minₓ hex
                        (Int.coe_nat_lt.1$
                          by 
                            rw [←hk₄] <;> exact Int.mod_lt_of_pos _ (Int.coe_nat_pos.2 (Nat.find_specₓ hex).1))
                        ⟨Nat.pos_of_ne_zeroₓ h, hk₅⟩
                ⟨k / (Nat.findₓ hex : ℤ),
                  Subtype.ext_iff_val.2
                    (by 
                      suffices  : (g ^ (Nat.findₓ hex : ℤ)*k / Nat.findₓ hex) = x
                      ·
                        simpa [zpow_mul]
                      rw [Int.mul_div_cancel' (Int.dvd_of_mod_eq_zero (Int.eq_zero_of_nat_abs_eq_zero hk₆)), hk])⟩⟩⟩
        else
          have  : H = (⊥ : Subgroup α) :=
            Subgroup.ext$
              fun x =>
                ⟨fun h =>
                    by 
                      simp  at * <;> tauto,
                  fun h =>
                    by 
                      rw [Subgroup.mem_bot.1 h] <;> exact H.one_mem⟩
          by 
            clear _let_match <;> subst this <;> infer_instance

open Finset Nat

section Classical

open_locale Classical

-- ././Mathport/Syntax/Translate/Tactic/Lean3.lean:98:4: warning: unsupported: rw with cfg: { occs := occurrences.pos «expr[ , ]»([2, 3]) }
@[toAdditive IsAddCyclic.card_pow_eq_one_le]
theorem IsCyclic.card_pow_eq_one_le [DecidableEq α] [Fintype α] [IsCyclic α] {n : ℕ} (hn0 : 0 < n) :
  (univ.filter fun a : α => a ^ n = 1).card ≤ n :=
  let ⟨g, hg⟩ := IsCyclic.exists_generator α 
  calc
    (univ.filter fun a : α => a ^ n = 1).card ≤
      (zpowers (g ^ (Fintype.card α / gcd n (Fintype.card α))) : Set α).toFinset.card :=
    card_le_of_subset
      fun x hx =>
        let ⟨m, hm⟩ := show x ∈ Submonoid.powers g from mem_powers_iff_mem_zpowers.2$ hg x 
        Set.mem_to_finset.2
          ⟨(m / (Fintype.card α / gcd n (Fintype.card α)) : ℕ),
            have hgmn : (g ^ m*gcd n (Fintype.card α)) = 1 :=
              by 
                rw [pow_mulₓ, hm, ←pow_gcd_card_eq_one_iff] <;> exact (mem_filter.1 hx).2
            by 
              rw [zpow_coe_nat, ←pow_mulₓ, Nat.mul_div_cancel_left', hm]
              refine' dvd_of_mul_dvd_mul_right (gcd_pos_of_pos_left (Fintype.card α) hn0) _ 
              conv  => lhs rw [Nat.div_mul_cancelₓ (gcd_dvd_right _ _), ←order_of_eq_card_of_forall_mem_zpowers hg]
              exact order_of_dvd_of_pow_eq_one hgmn⟩
    _ ≤ n :=
    let ⟨m, hm⟩ := gcd_dvd_right n (Fintype.card α)
    have hm0 : 0 < m :=
      Nat.pos_of_ne_zeroₓ$
        fun hm0 =>
          by 
            rw [hm0, mul_zero, Fintype.card_eq_zero_iff] at hm 
            exact hm.elim' 1
    by 
      rw [←Fintype.card_of_finset' _ fun _ => Set.mem_to_finset, ←order_eq_card_zpowers, order_of_pow g,
        order_of_eq_card_of_forall_mem_zpowers hg]
      rw [hm]
      rw [Nat.mul_div_cancel_leftₓ _ (gcd_pos_of_pos_left _ hn0), gcd_mul_left_left, hm, Nat.mul_div_cancelₓ _ hm0]
      exact le_of_dvd hn0 (gcd_dvd_left _ _)
    

end Classical

@[toAdditive]
theorem IsCyclic.exists_monoid_generator [Fintype α] [IsCyclic α] : ∃ x : α, ∀ y : α, y ∈ Submonoid.powers x :=
  by 
    simpRw [mem_powers_iff_mem_zpowers]
    exact IsCyclic.exists_generator α

section 

variable [DecidableEq α] [Fintype α]

@[toAdditive]
theorem IsCyclic.image_range_order_of (ha : ∀ x : α, x ∈ zpowers a) :
  Finset.image (fun i => a ^ i) (range (orderOf a)) = univ :=
  by 
    simpRw [←SetLike.mem_coe]  at ha 
    simp only [image_range_order_of, set.eq_univ_iff_forall.mpr ha]
    convert Set.to_finset_univ

@[toAdditive]
theorem IsCyclic.image_range_card (ha : ∀ x : α, x ∈ zpowers a) :
  Finset.image (fun i => a ^ i) (range (Fintype.card α)) = univ :=
  by 
    rw [←order_of_eq_card_of_forall_mem_zpowers ha, IsCyclic.image_range_order_of ha]

end 

section Totient

variable [DecidableEq α] [Fintype α] (hn : ∀ n : ℕ, 0 < n → (univ.filter fun a : α => a ^ n = 1).card ≤ n)

include hn

private theorem card_pow_eq_one_eq_order_of_aux (a : α) :
  (Finset.univ.filter fun b : α => b ^ orderOf a = 1).card = orderOf a :=
  le_antisymmₓ (hn _ (order_of_pos a))
    (calc orderOf a = @Fintype.card (zpowers a) (id _) := order_eq_card_zpowers 
      _ ≤ @Fintype.card (↑univ.filter fun b : α => b ^ orderOf a = 1 : Set α) (Fintype.ofFinset _ fun _ => Iff.rfl) :=
      @Fintype.card_le_of_injective (zpowers a) (↑univ.filter fun b : α => b ^ orderOf a = 1 : Set α) (id _) (id _)
        (fun b =>
          ⟨b.1,
            mem_filter.2
              ⟨mem_univ _,
                let ⟨i, hi⟩ := b.2
                by 
                  rw [←hi, ←zpow_coe_nat, ←zpow_mul, mul_commₓ, zpow_mul, zpow_coe_nat, pow_order_of_eq_one,
                    one_zpow]⟩⟩)
        fun _ _ h => Subtype.eq (Subtype.mk.injₓ h)
      _ = (univ.filter fun b : α => b ^ orderOf a = 1).card := Fintype.card_of_finset _ _
      )

open_locale Nat

-- failed to parenthesize: parenthesize: uncaught backtrack exception
-- failed to format: format: uncaught backtrack exception
private
  theorem
    card_order_of_eq_totient_aux₁
    :
      ∀
        { d : ℕ }
        ,
        d ∣ Fintype.card α
          →
          0 < univ . filter fun a : α => orderOf a = d . card → univ . filter fun a : α => orderOf a = d . card = φ d
    | 0 => fun hd hd0 => let ⟨ a , ha ⟩ := card_pos . 1 hd0 absurd mem_filter . 1 ha . 2 $ ne_of_gtₓ $ order_of_pos a
      |
        d + 1
        =>
        fun
          hd hd0
            =>
            let
              ⟨ a , ha ⟩ := card_pos . 1 hd0
              have
                ha : orderOf a = d.succ := mem_filter . 1 ha . 2
                have
                  h
                    :
                      ∑ m in range d.succ . filter · ∣ d.succ , univ . filter fun a : α => orderOf a = m . card
                        =
                        ∑ m in range d.succ . filter · ∣ d.succ , φ m
                    :=
                    Finset.sum_congr
                      rfl
                        fun
                          m hm
                            =>
                            have
                              hmd : m < d.succ := mem_range . 1 mem_filter . 1 hm . 1
                              have
                                hm : m ∣ d.succ := mem_filter . 1 hm . 2
                                card_order_of_eq_totient_aux₁
                                  hm.trans hd
                                    Finset.card_pos . 2
                                      ⟨
                                        a ^ d.succ / m
                                          ,
                                          mem_filter . 2
                                            ⟨
                                              mem_univ _
                                                ,
                                                by
                                                  rw
                                                    [
                                                      order_of_pow a
                                                        ,
                                                        ha
                                                        ,
                                                        gcd_eq_right div_dvd_of_dvd hm
                                                        ,
                                                        Nat.div_div_self hm succ_pos _
                                                      ]
                                              ⟩
                                        ⟩
                  have
                    hinsert
                      : insert d.succ range d.succ . filter · ∣ d.succ = range d.succ.succ . filter · ∣ d.succ
                      :=
                      Finset.ext
                        $
                        fun
                          x
                            =>
                            ⟨
                              fun
                                  h
                                    =>
                                    mem_insert . 1 h . elim
                                      fun h => by simp [ h , range_succ ]
                                        by clear _let_match <;> simp [ range_succ ] <;> tauto
                                ,
                                by
                                  clear _let_match
                                    <;>
                                    simp ( config := { contextual := Bool.true._@._internal._hyg.0 } ) [ range_succ ]
                                      <;>
                                      tauto
                              ⟩
                    have
                      hinsert₁
                        : d.succ ∉ range d.succ . filter · ∣ d.succ
                        :=
                        by simp [ mem_range , zero_le_one , le_succ ]
                      add_left_injₓ
                            ∑ m in range d.succ . filter · ∣ d.succ , univ . filter fun a : α => orderOf a = m . card
                          .
                          1
                        calc
                          _
                                =
                                ∑
                                  m
                                  in
                                  insert d.succ filter · ∣ d.succ range d.succ
                                  ,
                                  univ . filter fun a : α => orderOf a = m . card
                              :=
                              Eq.symm Finset.sum_insert by simp [ mem_range , zero_le_one , le_succ ]
                            _
                                =
                                ∑
                                  m
                                  in
                                  range d.succ.succ . filter · ∣ d.succ
                                  ,
                                  univ . filter fun a : α => orderOf a = m . card
                              :=
                              sum_congr hinsert fun _ _ => rfl
                            _ = univ . filter fun a : α => a ^ d.succ = 1 . card
                              :=
                              sum_card_order_of_eq_card_pow_eq_one succ_pos d
                            _ = ∑ m in range d.succ.succ . filter · ∣ d.succ , φ m
                              :=
                              ha ▸ card_pow_eq_one_eq_order_of_aux hn a . symm ▸ sum_totient _ . symm
                            _ = _
                              :=
                              by rw [ h , ← sum_insert hinsert₁ ] <;> exact Finset.sum_congr hinsert.symm fun _ _ => rfl

theorem card_order_of_eq_totient_aux₂ {d : ℕ} (hd : d ∣ Fintype.card α) :
  (univ.filter fun a : α => orderOf a = d).card = φ d :=
  by_contradiction$
    fun h =>
      have h0 : (univ.filter fun a : α => orderOf a = d).card = 0 :=
        not_not.1 (mt pos_iff_ne_zero.2 (mt (card_order_of_eq_totient_aux₁ hn hd) h))
      let c := Fintype.card α 
      have hc0 : 0 < c := Fintype.card_pos_iff.2 ⟨1⟩
      lt_irreflₓ c$
        calc c = (univ.filter fun a : α => a ^ c = 1).card :=
          congr_argₓ card$
            by 
              simp [Finset.ext_iff, c]
          _ = ∑ m in (range c.succ).filter (· ∣ c), (univ.filter fun a : α => orderOf a = m).card :=
          (sum_card_order_of_eq_card_pow_eq_one hc0).symm 
          _ = ∑ m in ((range c.succ).filter (· ∣ c)).erase d, (univ.filter fun a : α => orderOf a = m).card :=
          Eq.symm
            (sum_subset (erase_subset _ _)
              fun m hm₁ hm₂ =>
                have  : m = d :=
                  by 
                    simp  at * <;> cc 
                by 
                  simp_all [Finset.ext_iff] <;> exact h0)
          _ ≤ ∑ m in ((range c.succ).filter (· ∣ c)).erase d, φ m :=
          sum_le_sum
            fun m hm =>
              have hmc : m ∣ c :=
                by 
                  simp  at hm <;> tauto
              (imp_iff_not_or.1 (card_order_of_eq_totient_aux₁ hn hmc)).elim
                (fun h =>
                  by 
                    simp [Nat.le_zero_iff.1 (le_of_not_gtₓ h), Nat.zero_leₓ])
                fun h =>
                  by 
                    rw [h]
          _ < φ d+∑ m in ((range c.succ).filter (· ∣ c)).erase d, φ m :=
          lt_add_of_pos_left _
            (totient_pos (Nat.pos_of_ne_zeroₓ fun h => pos_iff_ne_zero.1 hc0 (eq_zero_of_zero_dvd$ h ▸ hd)))
          _ = ∑ m in insert d (((range c.succ).filter (· ∣ c)).erase d), φ m :=
          Eq.symm
            (sum_insert
              (by 
                simp ))
          _ = ∑ m in (range c.succ).filter (· ∣ c), φ m :=
          Finset.sum_congr (Finset.insert_erase (mem_filter.2 ⟨mem_range.2 (lt_succ_of_le (le_of_dvd hc0 hd)), hd⟩))
            fun _ _ => rfl 
          _ = c := sum_totient _
          

theorem is_cyclic_of_card_pow_eq_one_le : IsCyclic α :=
  have  : (univ.filter fun a : α => orderOf a = Fintype.card α).Nonempty :=
    card_pos.1$
      by 
        rw [card_order_of_eq_totient_aux₂ hn dvd_rfl] <;> exact totient_pos (Fintype.card_pos_iff.2 ⟨1⟩)
  let ⟨x, hx⟩ := this 
  is_cyclic_of_order_of_eq_card x (Finset.mem_filter.1 hx).2

theorem is_add_cyclic_of_card_pow_eq_one_le {α} [AddGroupₓ α] [DecidableEq α] [Fintype α]
  (hn : ∀ n : ℕ, 0 < n → (univ.filter fun a : α => n • a = 0).card ≤ n) : IsAddCyclic α :=
  by 
    obtain ⟨g, hg⟩ := @is_cyclic_of_card_pow_eq_one_le (Multiplicative α) _ _ _ hn 
    exact ⟨⟨g, hg⟩⟩

attribute [toAdditive is_cyclic_of_card_pow_eq_one_le] is_add_cyclic_of_card_pow_eq_one_le

end Totient

theorem IsCyclic.card_order_of_eq_totient [IsCyclic α] [Fintype α] {d : ℕ} (hd : d ∣ Fintype.card α) :
  (univ.filter fun a : α => orderOf a = d).card = totient d :=
  by 
    classical 
    apply card_order_of_eq_totient_aux₂ (fun n => IsCyclic.card_pow_eq_one_le) hd

theorem IsAddCyclic.card_order_of_eq_totient {α} [AddGroupₓ α] [IsAddCyclic α] [Fintype α] {d : ℕ}
  (hd : d ∣ Fintype.card α) : (univ.filter fun a : α => addOrderOf a = d).card = totient d :=
  by 
    obtain ⟨g, hg⟩ := id ‹IsAddCyclic α›
    exact @IsCyclic.card_order_of_eq_totient (Multiplicative α) _ ⟨⟨g, hg⟩⟩ _ _ hd

attribute [toAdditive IsCyclic.card_order_of_eq_totient] IsAddCyclic.card_order_of_eq_totient

/-- A finite group of prime order is simple. -/
@[toAdditive]
theorem is_simple_group_of_prime_card {α : Type u} [Groupₓ α] [Fintype α] {p : ℕ} [hp : Fact p.prime]
  (h : Fintype.card α = p) : IsSimpleGroup α :=
  ⟨by 
      have h' := Nat.Prime.one_lt (Fact.out p.prime)
      rw [←h] at h' 
      have  := Fintype.one_lt_card_iff_nontrivial.1 h' 
      apply exists_pair_ne α,
    fun H Hn =>
      by 
        classical 
        have hcard := card_subgroup_dvd_card H 
        rw [h, dvd_prime (Fact.out p.prime)] at hcard 
        refine' hcard.imp (fun h1 => _) fun hp => _
        ·
          have  := Fintype.card_le_one_iff_subsingleton.1 (le_of_eqₓ h1)
          apply eq_bot_of_subsingleton
        ·
          exact eq_top_of_card_eq _ (hp.trans h.symm)⟩

end Cyclic

section QuotientCenter

open Subgroup

variable {G : Type _} {H : Type _} [Groupₓ G] [Groupₓ H]

/-- A group is commutative if the quotient by the center is cyclic.
  Also see `comm_group_of_cycle_center_quotient` for the `comm_group` instance. -/
@[toAdditive commutative_of_add_cyclic_center_quotient
      "A group is commutative if the quotient by\n  the center is cyclic. Also see `add_comm_group_of_cycle_center_quotient`\n  for the `add_comm_group` instance."]
theorem commutative_of_cyclic_center_quotient [IsCyclic H] (f : G →* H) (hf : f.ker ≤ center G) (a b : G) :
  (a*b) = b*a :=
  let ⟨⟨x, y, (hxy : f y = x)⟩, (hx : ∀ a : f.range, a ∈ zpowers _)⟩ := IsCyclic.exists_generator f.range 
  let ⟨m, hm⟩ := hx ⟨f a, a, rfl⟩
  let ⟨n, hn⟩ := hx ⟨f b, b, rfl⟩
  have hm : x ^ m = f a :=
    by 
      simpa [Subtype.ext_iff] using hm 
  have hn : x ^ n = f b :=
    by 
      simpa [Subtype.ext_iff] using hn 
  have ha : ((y ^ -m)*a) ∈ center G :=
    hf
      (by 
        rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hm, inv_mul_selfₓ])
  have hb : ((y ^ -n)*b) ∈ center G :=
    hf
      (by 
        rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hn, inv_mul_selfₓ])
  calc (a*b) = ((y ^ m)*((y ^ -m)*a)*y ^ n)*(y ^ -n)*b :=
    by 
      simp [mul_assocₓ]
    _ = ((y ^ m)*(y ^ n)*(y ^ -m)*a)*(y ^ -n)*b :=
    by 
      rw [mem_center_iff.1 ha]
    _ = (((y ^ m)*y ^ n)*y ^ -m)*a*(y ^ -n)*b :=
    by 
      simp [mul_assocₓ]
    _ = (((y ^ m)*y ^ n)*y ^ -m)*((y ^ -n)*b)*a :=
    by 
      rw [mem_center_iff.1 hb]
    _ = b*a :=
    by 
      group
    

/-- A group is commutative if the quotient by the center is cyclic. -/
@[toAdditive commutativeOfAddCycleCenterQuotient "A group is commutative if the quotient by\n  the center is cyclic."]
def commGroupOfCycleCenterQuotient [IsCyclic H] (f : G →* H) (hf : f.ker ≤ center G) : CommGroupₓ G :=
  { show Groupₓ G by 
      infer_instance with
    mul_comm := commutative_of_cyclic_center_quotient f hf }

end QuotientCenter

namespace IsSimpleGroup

section CommGroupₓ

variable [CommGroupₓ α] [IsSimpleGroup α]

@[toAdditive IsSimpleAddGroup.is_add_cyclic]
instance (priority := 100) : IsCyclic α :=
  by 
    cases' subsingleton_or_nontrivial α with hi hi <;> have  := hi
    ·
      apply is_cyclic_of_subsingleton
    ·
      obtain ⟨g, hg⟩ := exists_ne (1 : α)
      refine' ⟨⟨g, fun x => _⟩⟩
      cases' IsSimpleOrder.eq_bot_or_eq_top (Subgroup.zpowers g) with hb ht
      ·
        exfalso 
        apply hg 
        rw [←Subgroup.mem_bot, ←hb]
        apply Subgroup.mem_zpowers
      ·
        rw [ht]
        apply Subgroup.mem_top

@[toAdditive]
theorem prime_card [Fintype α] : (Fintype.card α).Prime :=
  by 
    have h0 : 0 < Fintype.card α :=
      Fintype.card_pos_iff.2
        (by 
          infer_instance)
    obtain ⟨g, hg⟩ := IsCyclic.exists_generator α 
    refine' ⟨Fintype.one_lt_card_iff_nontrivial.2 inferInstance, fun n hn => _⟩
    refine' (IsSimpleOrder.eq_bot_or_eq_top (Subgroup.zpowers (g ^ n))).symm.imp _ _
    ·
      intro h 
      have hgo := order_of_pow g 
      rw [order_of_eq_card_of_forall_mem_zpowers hg, Nat.gcd_eq_right_iff_dvdₓ.1 hn,
        order_of_eq_card_of_forall_mem_zpowers, eq_comm,
        Nat.div_eq_iff_eq_mul_left (Nat.pos_of_dvd_of_posₓ hn h0) hn] at hgo
      ·
        exact (mul_left_cancel₀ (ne_of_gtₓ h0) ((mul_oneₓ (Fintype.card α)).trans hgo)).symm
      ·
        intro x 
        rw [h]
        exact Subgroup.mem_top _
    ·
      intro h 
      apply le_antisymmₓ (Nat.le_of_dvdₓ h0 hn)
      rw [←order_of_eq_card_of_forall_mem_zpowers hg]
      apply order_of_le_of_pow_eq_one (Nat.pos_of_dvd_of_posₓ hn h0)
      rw [←Subgroup.mem_bot, ←h]
      exact Subgroup.mem_zpowers _

end CommGroupₓ

end IsSimpleGroup

@[toAdditive AddCommGroupₓ.is_simple_iff_is_add_cyclic_and_prime_card]
theorem CommGroupₓ.is_simple_iff_is_cyclic_and_prime_card [Fintype α] [CommGroupₓ α] :
  IsSimpleGroup α ↔ IsCyclic α ∧ (Fintype.card α).Prime :=
  by 
    constructor
    ·
      intro h 
      exact ⟨IsSimpleGroup.is_cyclic, IsSimpleGroup.prime_card⟩
    ·
      rintro ⟨hc, hp⟩
      have  : Fact (Fintype.card α).Prime := ⟨hp⟩
      exact is_simple_group_of_prime_card rfl

