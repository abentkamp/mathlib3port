import Mathbin.LinearAlgebra.Matrix.Symmetric 
import Mathbin.LinearAlgebra.Matrix.Orthogonal 
import Mathbin.Data.Matrix.Kronecker

/-!
# Diagonal matrices

This file contains the definition and basic results about diagonal matrices.

## Main results

- `matrix.is_diag`: a proposition that states a given square matrix `A` is diagonal.

## Tags

diag, diagonal, matrix
-/


namespace Matrix

variable {α β R n m : Type _}

open Function

open_locale Matrix Kronecker

/-- `A.is_diag` means square matrix `A` is a diagonal matrix. -/
def is_diag [HasZero α] (A : Matrix n n α) : Prop :=
  ∀ ⦃i j⦄, i ≠ j → A i j = 0

@[simp]
theorem is_diag_diagonal [HasZero α] [DecidableEq n] (d : n → α) : (diagonal d).IsDiag :=
  fun i j => Matrix.diagonal_apply_ne

/-- Diagonal matrices are generated by `matrix.diagonal`. -/
theorem is_diag.exists_diagonal [HasZero α] [DecidableEq n] {A : Matrix n n α} (h : A.is_diag) : ∃ d, diagonal d = A :=
  by 
    refine' ⟨fun i => A i i, ext$ fun i j => _⟩
    obtain rfl | hij := Decidable.eq_or_ne i j
    ·
      rw [diagonal_apply_eq]
    ·
      rw [diagonal_apply_ne hij, h hij]

/-- `matrix.is_diag.exists_diagonal` as an iff. -/
theorem is_diag_iff_exists_diagonal [HasZero α] [DecidableEq n] (A : Matrix n n α) : A.is_diag ↔ ∃ d, diagonal d = A :=
  ⟨is_diag.exists_diagonal, fun ⟨d, hd⟩ => hd ▸ is_diag_diagonal d⟩

/-- Every matrix indexed by a subsingleton is diagonal. -/
theorem is_diag_of_subsingleton [HasZero α] [Subsingleton n] (A : Matrix n n α) : A.is_diag :=
  fun i j h => (h$ Subsingleton.elimₓ i j).elim

/-- Every zero matrix is diagonal. -/
@[simp]
theorem is_diag_zero [HasZero α] : (0 : Matrix n n α).IsDiag :=
  fun i j h => rfl

/-- Every identity matrix is diagonal. -/
@[simp]
theorem is_diag_one [DecidableEq n] [HasZero α] [HasOne α] : (1 : Matrix n n α).IsDiag :=
  fun i j => one_apply_ne

theorem is_diag.map [HasZero α] [HasZero β] {A : Matrix n n α} (ha : A.is_diag) {f : α → β} (hf : f 0 = 0) :
  (A.map f).IsDiag :=
  by 
    intro i j h 
    simp [ha h, hf]

theorem is_diag.neg [AddGroupₓ α] {A : Matrix n n α} (ha : A.is_diag) : (-A).IsDiag :=
  by 
    intro i j h 
    simp [ha h]

@[simp]
theorem is_diag_neg_iff [AddGroupₓ α] {A : Matrix n n α} : (-A).IsDiag ↔ A.is_diag :=
  ⟨fun ha i j h => neg_eq_zero.1 (ha h), is_diag.neg⟩

theorem is_diag.add [AddZeroClass α] {A B : Matrix n n α} (ha : A.is_diag) (hb : B.is_diag) : (A+B).IsDiag :=
  by 
    intro i j h 
    simp [ha h, hb h]

theorem is_diag.sub [AddGroupₓ α] {A B : Matrix n n α} (ha : A.is_diag) (hb : B.is_diag) : (A - B).IsDiag :=
  by 
    intro i j h 
    simp [ha h, hb h]

theorem is_diag.smul [Monoidₓ R] [AddMonoidₓ α] [DistribMulAction R α] (k : R) {A : Matrix n n α} (ha : A.is_diag) :
  (k • A).IsDiag :=
  by 
    intro i j h 
    simp [ha h]

@[simp]
theorem is_diag_smul_one n [Semiringₓ α] [DecidableEq n] (k : α) : (k • (1 : Matrix n n α)).IsDiag :=
  is_diag_one.smul k

theorem is_diag.transpose [HasZero α] {A : Matrix n n α} (ha : A.is_diag) : (A)ᵀ.IsDiag :=
  fun i j h => ha h.symm

@[simp]
theorem is_diag_transpose_iff [HasZero α] {A : Matrix n n α} : (A)ᵀ.IsDiag ↔ A.is_diag :=
  ⟨is_diag.transpose, is_diag.transpose⟩

theorem is_diag.conj_transpose [Semiringₓ α] [StarRing α] {A : Matrix n n α} (ha : A.is_diag) : (A)ᴴ.IsDiag :=
  ha.transpose.map (star_zero _)

@[simp]
theorem is_diag_conj_transpose_iff [Semiringₓ α] [StarRing α] {A : Matrix n n α} : (A)ᴴ.IsDiag ↔ A.is_diag :=
  ⟨fun ha =>
      by 
        convert ha.conj_transpose 
        simp ,
    is_diag.conj_transpose⟩

theorem is_diag.minor [HasZero α] {A : Matrix n n α} (ha : A.is_diag) {f : m → n} (hf : injective f) :
  (A.minor f f).IsDiag :=
  fun i j h => ha (hf.ne h)

/-- `(A ⊗ B).is_diag` if both `A` and `B` are diagonal. -/
theorem is_diag.kronecker [MulZeroClass α] {A : Matrix m m α} {B : Matrix n n α} (hA : A.is_diag) (hB : B.is_diag) :
  (A ⊗ₖ B).IsDiag :=
  by 
    rintro ⟨a, b⟩ ⟨c, d⟩ h 
    simp only [Prod.mk.inj_iffₓ, Ne.def, not_and_distrib] at h 
    cases' h with hac hbd
    ·
      simp [hA hac]
    ·
      simp [hB hbd]

theorem is_diag.is_symm [HasZero α] {A : Matrix n n α} (h : A.is_diag) : A.is_symm :=
  by 
    ext i j 
    byCases' g : i = j
    ·
      rw [g]
    simp [h g, h (Ne.symm g)]

/-- The block matrix `A.from_blocks 0 0 D` is diagonal if `A` and `D` are diagonal. -/
theorem is_diag.from_blocks [HasZero α] {A : Matrix m m α} {D : Matrix n n α} (ha : A.is_diag) (hd : D.is_diag) :
  (A.from_blocks 0 0 D).IsDiag :=
  by 
    rintro (i | i) (j | j) hij
    ·
      exact ha (ne_of_apply_ne _ hij)
    ·
      rfl
    ·
      rfl
    ·
      exact hd (ne_of_apply_ne _ hij)

/-- This is the `iff` version of `matrix.is_diag.from_blocks`. -/
theorem is_diag_from_blocks_iff [HasZero α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α}
  {D : Matrix n n α} : (A.from_blocks B C D).IsDiag ↔ A.is_diag ∧ B = 0 ∧ C = 0 ∧ D.is_diag :=
  by 
    split 
    ·
      intro h 
      refine' ⟨fun i j hij => _, ext$ fun i j => _, ext$ fun i j => _, fun i j hij => _⟩
      ·
        exact h (sum.inl_injective.ne hij)
      ·
        exact h Sum.inl_ne_inr
      ·
        exact h Sum.inr_ne_inl
      ·
        exact h (sum.inr_injective.ne hij)
    ·
      rintro ⟨ha, hb, hc, hd⟩
      convert is_diag.from_blocks ha hd

/-- A symmetric block matrix `A.from_blocks B C D` is diagonal
    if  `A` and `D` are diagonal and `B` is `0`. -/
theorem is_diag.from_blocks_of_is_symm [HasZero α] {A : Matrix m m α} {C : Matrix n m α} {D : Matrix n n α}
  (h : (A.from_blocks 0 C D).IsSymm) (ha : A.is_diag) (hd : D.is_diag) : (A.from_blocks 0 C D).IsDiag :=
  by 
    rw [←(is_symm_from_blocks_iff.1 h).2.1]
    exact ha.from_blocks hd

theorem mul_transpose_self_is_diag_iff_has_orthogonal_rows [Fintype n] [Mul α] [AddCommMonoidₓ α] {A : Matrix m n α} :
  (A ⬝ (A)ᵀ).IsDiag ↔ A.has_orthogonal_rows :=
  Iff.rfl

theorem transpose_mul_self_is_diag_iff_has_orthogonal_cols [Fintype m] [Mul α] [AddCommMonoidₓ α] {A : Matrix m n α} :
  ((A)ᵀ ⬝ A).IsDiag ↔ A.has_orthogonal_cols :=
  Iff.rfl

end Matrix

