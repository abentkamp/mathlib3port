import Mathbin.MeasureTheory.Measure.GiryMonad
import Mathbin.CategoryTheory.ConcreteCategory.UnbundledHom
import Mathbin.CategoryTheory.Monad.Algebra
import Mathbin.Topology.Category.Top.Basic

/-!
# The category of measurable spaces

Measurable spaces and measurable functions form a (concrete) category `Meas`.

## Main definitions

* `Measure : Meas ⥤ Meas`: the functor which sends a measurable space `X`
to the space of measures on `X`; it is a monad (the "Giry monad").

* `Borel : Top ⥤ Meas`: sends a topological space `X` to `X` equipped with the
`σ`-algebra of Borel sets (the `σ`-algebra generated by the open subsets of `X`).

## Tags

measurable space, giry monad, borel
-/


noncomputable section

open CategoryTheory MeasureTheory

open_locale Ennreal

universe u v

/--  The category of measurable spaces and measurable functions. -/
def Meas : Type (u + 1) :=
  bundled MeasurableSpace

namespace Meas

instance : CoeSort Meas (Type _) :=
  bundled.has_coe_to_sort

instance (X : Meas) : MeasurableSpace X :=
  X.str

/--  Construct a bundled `Meas` from the underlying type and the typeclass. -/
def of (α : Type u) [MeasurableSpace α] : Meas :=
  ⟨α⟩

@[simp]
theorem coe_of (X : Type u) [MeasurableSpace X] : (of X : Type u) = X :=
  rfl

instance unbundled_hom : unbundled_hom @Measurable :=
  ⟨@measurable_id, @Measurable.comp⟩

-- ././Mathport/Syntax/Translate/Basic.lean:833:9: unsupported derive handler large_category
-- ././Mathport/Syntax/Translate/Basic.lean:833:9: unsupported derive handler concrete_category
deriving instance [anonymous], [anonymous] for Meas

instance : Inhabited Meas :=
  ⟨Meas.of Empty⟩

/--  `Measure X` is the measurable space of measures over the measurable space `X`. It is the
weakest measurable space, s.t. λμ, μ s is measurable for all measurable sets `s` in `X`. An
important purpose is to assign a monadic structure on it, the Giry monad. In the Giry monad,
the pure values are the Dirac measure, and the bind operation maps to the integral:
`(μ >>= ν) s = ∫ x. (ν x) s dμ`.

In probability theory, the `Meas`-morphisms `X → Prob X` are (sub-)Markov kernels (here `Prob` is
the restriction of `Measure` to (sub-)probability space.)
-/
def Measure : Meas ⥤ Meas :=
  { obj := fun X => ⟨@MeasureTheory.Measure X.1 X.2⟩,
    map := fun X Y f => ⟨measure.map (f : X → Y), measure.measurable_map f f.2⟩,
    map_id' := fun ⟨α, I⟩ => Subtype.eq $ funext $ fun μ => @measure.map_id α I μ,
    map_comp' := fun X Y Z ⟨f, hf⟩ ⟨g, hg⟩ => Subtype.eq $ funext $ fun μ => (measure.map_map hg hf).symm }

/--  The Giry monad, i.e. the monadic structure associated with `Measure`. -/
def Giry : CategoryTheory.Monad Meas :=
  { toFunctor := Measure,
    η' :=
      { app := fun X => ⟨@measure.dirac X.1 X.2, measure.measurable_dirac⟩,
        naturality' := fun X Y ⟨f, hf⟩ => Subtype.eq $ funext $ fun a => (measure.map_dirac hf a).symm },
    μ' :=
      { app := fun X => ⟨@measure.join X.1 X.2, measure.measurable_join⟩,
        naturality' := fun X Y ⟨f, hf⟩ => Subtype.eq $ funext $ fun μ => measure.join_map_map hf μ },
    assoc' := fun α => Subtype.eq $ funext $ fun μ => @measure.join_map_join _ _ _,
    left_unit' := fun α => Subtype.eq $ funext $ fun μ => @measure.join_dirac _ _ _,
    right_unit' := fun α => Subtype.eq $ funext $ fun μ => @measure.join_map_dirac _ _ _ }

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers
  [(Command.docComment
    "/--"
    " An example for an algebra on `Measure`: the nonnegative Lebesgue integral is a hom, behaving\nnicely under the monad operations. -/")]
  []
  []
  []
  []
  [])
 (Command.def
  "def"
  (Command.declId `Integral [])
  (Command.optDeclSig [] [(Term.typeSpec ":" (Term.proj `Giry "." `Algebra))])
  (Command.declValSimple
   ":="
   (Term.structInst
    "{"
    []
    [(group
      (Term.structInstField
       (Term.structInstLVal `A [])
       ":="
       (Term.app `Meas.of [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))
      [","])
     (group
      (Term.structInstField
       (Term.structInstLVal `a [])
       ":="
       (Term.anonymousCtor
        "⟨"
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`m] [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
           "=>"
           (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
            "∫⁻"
            (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
            ", "
            `x
            " ∂"
            `m)))
         ","
         (Term.app `measure.measurable_lintegral [`measurable_id])]
        "⟩"))
      [","])
     (group
      (Term.structInstField
       (Term.structInstLVal `unit' [])
       ":="
       («term_$__»
        `Subtype.eq
        "$"
        («term_$__»
         `funext
         "$"
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`r] [(Term.typeSpec ":" (Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞"))])]
           "=>"
           (Term.app `lintegral_dirac' [(Term.hole "_") `measurable_id]))))))
      [","])
     (group
      (Term.structInstField
       (Term.structInstLVal `assoc' [])
       ":="
       («term_$__»
        `Subtype.eq
        "$"
        («term_$__»
         `funext
         "$"
         (Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder
             [`μ]
             [(Term.typeSpec ":" (Term.app `Measureₓ [(Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")])]))])]
           "=>"
           (Term.show
            "show"
            («term_=_»
             (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
              "∫⁻"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
              ", "
              `x
              " ∂"
              `μ.join)
             "="
             (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
              "∫⁻"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
              ", "
              `x
              " ∂"
              (Term.app
               `measure.map
               [(Term.fun
                 "fun"
                 (Term.basicFun
                  [(Term.simpleBinder
                    [`m]
                    [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
                  "=>"
                  (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
                   "∫⁻"
                   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
                   ", "
                   `x
                   " ∂"
                   `m)))
                `μ])))
            (Term.byTactic
             "by"
             (Tactic.tacticSeq
              (Tactic.tacticSeq1Indented
               [(group
                 (Tactic.«tactic_<;>_»
                  (Tactic.rwSeq
                   "rw"
                   []
                   (Tactic.rwRuleSeq
                    "["
                    [(Tactic.rwRule [] `measure.lintegral_join) "," (Tactic.rwRule [] `lintegral_map)]
                    "]")
                   [])
                  "<;>"
                  (Tactic.applyRules "apply_rules" [] "[" [`measurable_id "," `measure.measurable_lintegral] "]" []))
                 [])])))))))))
      [])]
    (Term.optEllipsis [])
    []
    "}")
   [])
  []
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.structInst
   "{"
   []
   [(group
     (Term.structInstField (Term.structInstLVal `A []) ":=" (Term.app `Meas.of [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))
     [","])
    (group
     (Term.structInstField
      (Term.structInstLVal `a [])
      ":="
      (Term.anonymousCtor
       "⟨"
       [(Term.fun
         "fun"
         (Term.basicFun
          [(Term.simpleBinder [`m] [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
          "=>"
          (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
           "∫⁻"
           (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
           ", "
           `x
           " ∂"
           `m)))
        ","
        (Term.app `measure.measurable_lintegral [`measurable_id])]
       "⟩"))
     [","])
    (group
     (Term.structInstField
      (Term.structInstLVal `unit' [])
      ":="
      («term_$__»
       `Subtype.eq
       "$"
       («term_$__»
        `funext
        "$"
        (Term.fun
         "fun"
         (Term.basicFun
          [(Term.simpleBinder [`r] [(Term.typeSpec ":" (Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞"))])]
          "=>"
          (Term.app `lintegral_dirac' [(Term.hole "_") `measurable_id]))))))
     [","])
    (group
     (Term.structInstField
      (Term.structInstLVal `assoc' [])
      ":="
      («term_$__»
       `Subtype.eq
       "$"
       («term_$__»
        `funext
        "$"
        (Term.fun
         "fun"
         (Term.basicFun
          [(Term.simpleBinder
            [`μ]
            [(Term.typeSpec ":" (Term.app `Measureₓ [(Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")])]))])]
          "=>"
          (Term.show
           "show"
           («term_=_»
            (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
             "∫⁻"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
             ", "
             `x
             " ∂"
             `μ.join)
            "="
            (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
             "∫⁻"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
             ", "
             `x
             " ∂"
             (Term.app
              `measure.map
              [(Term.fun
                "fun"
                (Term.basicFun
                 [(Term.simpleBinder
                   [`m]
                   [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
                 "=>"
                 (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
                  "∫⁻"
                  (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
                  ", "
                  `x
                  " ∂"
                  `m)))
               `μ])))
           (Term.byTactic
            "by"
            (Tactic.tacticSeq
             (Tactic.tacticSeq1Indented
              [(group
                (Tactic.«tactic_<;>_»
                 (Tactic.rwSeq
                  "rw"
                  []
                  (Tactic.rwRuleSeq
                   "["
                   [(Tactic.rwRule [] `measure.lintegral_join) "," (Tactic.rwRule [] `lintegral_map)]
                   "]")
                  [])
                 "<;>"
                 (Tactic.applyRules "apply_rules" [] "[" [`measurable_id "," `measure.measurable_lintegral] "]" []))
                [])])))))))))
     [])]
   (Term.optEllipsis [])
   []
   "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInst', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInst', expected 'Lean.Parser.Term.structInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.optEllipsis', expected 'Lean.Parser.Term.optEllipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstField.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_$__»
   `Subtype.eq
   "$"
   («term_$__»
    `funext
    "$"
    (Term.fun
     "fun"
     (Term.basicFun
      [(Term.simpleBinder
        [`μ]
        [(Term.typeSpec ":" (Term.app `Measureₓ [(Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")])]))])]
      "=>"
      (Term.show
       "show"
       («term_=_»
        (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
         "∫⁻"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
         ", "
         `x
         " ∂"
         `μ.join)
        "="
        (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
         "∫⁻"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
         ", "
         `x
         " ∂"
         (Term.app
          `measure.map
          [(Term.fun
            "fun"
            (Term.basicFun
             [(Term.simpleBinder
               [`m]
               [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
             "=>"
             (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
              "∫⁻"
              (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
              ", "
              `x
              " ∂"
              `m)))
           `μ])))
       (Term.byTactic
        "by"
        (Tactic.tacticSeq
         (Tactic.tacticSeq1Indented
          [(group
            (Tactic.«tactic_<;>_»
             (Tactic.rwSeq
              "rw"
              []
              (Tactic.rwRuleSeq
               "["
               [(Tactic.rwRule [] `measure.lintegral_join) "," (Tactic.rwRule [] `lintegral_map)]
               "]")
              [])
             "<;>"
             (Tactic.applyRules "apply_rules" [] "[" [`measurable_id "," `measure.measurable_lintegral] "]" []))
            [])]))))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_$__»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  («term_$__»
   `funext
   "$"
   (Term.fun
    "fun"
    (Term.basicFun
     [(Term.simpleBinder
       [`μ]
       [(Term.typeSpec ":" (Term.app `Measureₓ [(Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")])]))])]
     "=>"
     (Term.show
      "show"
      («term_=_»
       (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
        "∫⁻"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
        ", "
        `x
        " ∂"
        `μ.join)
       "="
       (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
        "∫⁻"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
        ", "
        `x
        " ∂"
        (Term.app
         `measure.map
         [(Term.fun
           "fun"
           (Term.basicFun
            [(Term.simpleBinder
              [`m]
              [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
            "=>"
            (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
             "∫⁻"
             (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
             ", "
             `x
             " ∂"
             `m)))
          `μ])))
      (Term.byTactic
       "by"
       (Tactic.tacticSeq
        (Tactic.tacticSeq1Indented
         [(group
           (Tactic.«tactic_<;>_»
            (Tactic.rwSeq
             "rw"
             []
             (Tactic.rwRuleSeq
              "["
              [(Tactic.rwRule [] `measure.lintegral_join) "," (Tactic.rwRule [] `lintegral_map)]
              "]")
             [])
            "<;>"
            (Tactic.applyRules "apply_rules" [] "[" [`measurable_id "," `measure.measurable_lintegral] "]" []))
           [])])))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_$__»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder
      [`μ]
      [(Term.typeSpec ":" (Term.app `Measureₓ [(Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")])]))])]
    "=>"
    (Term.show
     "show"
     («term_=_»
      (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
       "∫⁻"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
       ", "
       `x
       " ∂"
       `μ.join)
      "="
      (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
       "∫⁻"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
       ", "
       `x
       " ∂"
       (Term.app
        `measure.map
        [(Term.fun
          "fun"
          (Term.basicFun
           [(Term.simpleBinder [`m] [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
           "=>"
           (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
            "∫⁻"
            (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
            ", "
            `x
            " ∂"
            `m)))
         `μ])))
     (Term.byTactic
      "by"
      (Tactic.tacticSeq
       (Tactic.tacticSeq1Indented
        [(group
          (Tactic.«tactic_<;>_»
           (Tactic.rwSeq
            "rw"
            []
            (Tactic.rwRuleSeq
             "["
             [(Tactic.rwRule [] `measure.lintegral_join) "," (Tactic.rwRule [] `lintegral_map)]
             "]")
            [])
           "<;>"
           (Tactic.applyRules "apply_rules" [] "[" [`measurable_id "," `measure.measurable_lintegral] "]" []))
          [])]))))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.show
   "show"
   («term_=_»
    (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
     "∫⁻"
     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
     ", "
     `x
     " ∂"
     `μ.join)
    "="
    (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
     "∫⁻"
     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
     ", "
     `x
     " ∂"
     (Term.app
      `measure.map
      [(Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`m] [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
         "=>"
         (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
          "∫⁻"
          (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
          ", "
          `x
          " ∂"
          `m)))
       `μ])))
   (Term.byTactic
    "by"
    (Tactic.tacticSeq
     (Tactic.tacticSeq1Indented
      [(group
        (Tactic.«tactic_<;>_»
         (Tactic.rwSeq
          "rw"
          []
          (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `measure.lintegral_join) "," (Tactic.rwRule [] `lintegral_map)] "]")
          [])
         "<;>"
         (Tactic.applyRules "apply_rules" [] "[" [`measurable_id "," `measure.measurable_lintegral] "]" []))
        [])]))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.show', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.show', expected 'Lean.Parser.Term.show.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.fromTerm.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.fromTerm'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.byTactic.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq', expected 'Lean.Parser.Tactic.tacticSeq.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeq1Indented.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.«tactic_<;>_»
   (Tactic.rwSeq
    "rw"
    []
    (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `measure.lintegral_join) "," (Tactic.rwRule [] `lintegral_map)] "]")
    [])
   "<;>"
   (Tactic.applyRules "apply_rules" [] "[" [`measurable_id "," `measure.measurable_lintegral] "]" []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.«tactic_<;>_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.applyRules "apply_rules" [] "[" [`measurable_id "," `measure.measurable_lintegral] "]" [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.applyRules', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `measure.measurable_lintegral
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `measurable_id
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1, tactic))
  (Tactic.rwSeq
   "rw"
   []
   (Tactic.rwRuleSeq "[" [(Tactic.rwRule [] `measure.lintegral_join) "," (Tactic.rwRule [] `lintegral_map)] "]")
   [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwSeq', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `lintegral_map
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rwRule', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `measure.lintegral_join
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, [anonymous]))
  («term_=_»
   (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
    "∫⁻"
    (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
    ", "
    `x
    " ∂"
    `μ.join)
   "="
   (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
    "∫⁻"
    (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
    ", "
    `x
    " ∂"
    (Term.app
     `measure.map
     [(Term.fun
       "fun"
       (Term.basicFun
        [(Term.simpleBinder [`m] [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
        "=>"
        (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
         "∫⁻"
         (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
         ", "
         `x
         " ∂"
         `m)))
      `μ])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«term_=_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
   "∫⁻"
   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
   ", "
   `x
   " ∂"
   (Term.app
    `measure.map
    [(Term.fun
      "fun"
      (Term.basicFun
       [(Term.simpleBinder [`m] [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
       "=>"
       (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
        "∫⁻"
        (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
        ", "
        `x
        " ∂"
        `m)))
     `μ]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app
   `measure.map
   [(Term.fun
     "fun"
     (Term.basicFun
      [(Term.simpleBinder [`m] [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
      "=>"
      (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
       "∫⁻"
       (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
       ", "
       `x
       " ∂"
       `m)))
    `μ])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `μ
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`m] [(Term.typeSpec ":" (Term.app `Measureₓ [(Data.Real.Ennreal.«termℝ≥0∞» "ℝ≥0∞")]))])]
    "=>"
    (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
     "∫⁻"
     (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
     ", "
     `x
     " ∂"
     `m)))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»
   "∫⁻"
   (Lean.explicitBinders (Lean.unbracketedExplicitBinders [(Lean.binderIdent `x)] []))
   ", "
   `x
   " ∂"
   `m)
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'MeasureTheory.MeasureTheory.Integral.Lebesgue.«term∫⁻_,_∂_»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `m
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `x
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.explicitBinders', expected 'Mathlib.ExtendedBinder.extBinders'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/--
    An example for an algebra on `Measure`: the nonnegative Lebesgue integral is a hom, behaving
    nicely under the monad operations. -/
  def
    Integral
    : Giry . Algebra
    :=
      {
        A := Meas.of ℝ≥0∞ ,
          a := ⟨ fun m : Measureₓ ℝ≥0∞ => ∫⁻ x , x ∂ m , measure.measurable_lintegral measurable_id ⟩ ,
          unit' := Subtype.eq $ funext $ fun r : ℝ≥0∞ => lintegral_dirac' _ measurable_id ,
          assoc'
            :=
            Subtype.eq
              $
              funext
                $
                fun
                  μ : Measureₓ Measureₓ ℝ≥0∞
                    =>
                    show
                      ∫⁻ x , x ∂ μ.join = ∫⁻ x , x ∂ measure.map fun m : Measureₓ ℝ≥0∞ => ∫⁻ x , x ∂ m μ
                      by
                        rw [ measure.lintegral_join , lintegral_map ]
                          <;>
                          apply_rules [ measurable_id , measure.measurable_lintegral ]
        }

end Meas

instance Top.hasForgetToMeas : has_forget₂ Top.{u} Meas.{u} :=
  bundled_hom.mk_has_forget₂ borel (fun X Y f => ⟨f.1, f.2.borel_measurable⟩)
    (by
      intros <;> rfl)

/--  The Borel functor, the canonical embedding of topological spaces into measurable spaces. -/
@[reducible]
def borelₓ : Top.{u} ⥤ Meas.{u} :=
  forget₂ Top.{u} Meas.{u}

