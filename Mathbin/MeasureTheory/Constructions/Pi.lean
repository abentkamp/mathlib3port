import Mathbin.MeasureTheory.Constructions.Prod

/-!
# Product measures

In this file we define and prove properties about finite products of measures
(and at some point, countable products of measures).

## Main definition

* `measure_theory.measure.pi`: The product of finitely many σ-finite measures.
  Given `μ : Π i : ι, measure (α i)` for `[fintype ι]` it has type `measure (Π i : ι, α i)`.

To apply Fubini along some subset of the variables, use
`measure_theory.measure.map_pi_equiv_pi_subtype_prod` to reduce to the situation of a product
of two measures: this lemma states that the bijection `equiv.pi_equiv_pi_subtype_prod p α`
between `(Π i : ι, α i)` and `(Π i : {i // p i}, α i) × (Π i : {i // ¬ p i}, α i)` maps a product
measure to a direct product of product measures, to which one can apply the usual Fubini for
direct product of measures.

## Implementation Notes

We define `measure_theory.outer_measure.pi`, the product of finitely many outer measures, as the
maximal outer measure `n` with the property that `n (pi univ s) ≤ ∏ i, m i (s i)`,
where `pi univ s` is the product of the sets `{s i | i : ι}`.

We then show that this induces a product of measures, called `measure_theory.measure.pi`.
For a collection of σ-finite measures `μ` and a collection of measurable sets `s` we show that
`measure.pi μ (pi univ s) = ∏ i, m i (s i)`. To do this, we follow the following steps:
* We know that there is some ordering on `ι`, given by an element of `[encodable ι]`.
* Using this, we have an equivalence `measurable_equiv.pi_measurable_equiv_tprod` between
  `Π ι, α i` and an iterated product of `α i`, called `list.tprod α l` for some list `l`.
* On this iterated product we can easily define a product measure `measure_theory.measure.tprod`
  by iterating `measure_theory.measure.prod`
* Using the previous two steps we construct `measure_theory.measure.pi'` on `Π ι, α i` for encodable
  `ι`.
* We know that `measure_theory.measure.pi'` sends products of sets to products of measures, and
  since `measure_theory.measure.pi` is the maximal such measure (or at least, it comes from an outer
  measure which is the maximal such outer measure), we get the same rule for
  `measure_theory.measure.pi`.

## Tags

finitary product measure

-/


noncomputable theory

open Function Set MeasureTheory.OuterMeasure Filter MeasurableSpace Encodable

open_locale Classical BigOperators TopologicalSpace Ennreal

variable{ι ι' : Type _}{α : ι → Type _}

/-! We start with some measurability properties -/


/-- Boxes formed by π-systems form a π-system. -/
theorem IsPiSystem.pi {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsPiSystem (C i)) : IsPiSystem (pi univ '' pi univ C) :=
  by 
    rintro _ _ ⟨s₁, hs₁, rfl⟩ ⟨s₂, hs₂, rfl⟩ hst 
    rw [←pi_inter_distrib] at hst⊢
    rw [univ_pi_nonempty_iff] at hst 
    exact mem_image_of_mem _ fun i _ => hC i _ _ (hs₁ i (mem_univ i)) (hs₂ i (mem_univ i)) (hst i)

/-- Boxes form a π-system. -/
theorem is_pi_system_pi [∀ i, MeasurableSpace (α i)] :
  IsPiSystem (pi univ '' pi univ fun i => { s : Set (α i) | MeasurableSet s }) :=
  IsPiSystem.pi fun i => is_pi_system_measurable_set

variable[Fintype ι][Fintype ι']

/-- Boxes of countably spanning sets are countably spanning. -/
theorem IsCountablySpanning.pi {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
  IsCountablySpanning (pi univ '' pi univ C) :=
  by 
    choose s h1s h2s using hC 
    haveI  := Fintype.encodable ι 
    let e : ℕ → ι → ℕ := fun n => (decode (ι → ℕ) n).iget 
    refine' ⟨fun n => pi univ fun i => s i (e n i), fun n => mem_image_of_mem _ fun i _ => h1s i _, _⟩
    simpRw [(surjective_decode_iget (ι → ℕ)).Union_comp fun x => pi univ fun i => s i (x i), Union_univ_pi s, h2s,
      pi_univ]

/-- The product of generated σ-algebras is the one generated by boxes, if both generating sets
  are countably spanning. -/
theorem generate_from_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
  (@MeasurableSpace.pi _ _ fun i => generate_from (C i)) = generate_from (pi univ '' pi univ C) :=
  by 
    haveI  := Fintype.encodable ι 
    apply le_antisymmₓ
    ·
      refine' supr_le _ 
      intro i 
      rw [comap_generate_from]
      apply generate_from_le 
      rintro _ ⟨s, hs, rfl⟩
      dsimp 
      choose t h1t h2t using hC 
      simpRw [eval_preimage, ←h2t]
      rw [←@Union_const _ ℕ _ s]
      have  :
        pi univ (update (fun i' : ι => Union (t i')) i (⋃i' : ℕ, s)) =
          pi univ fun k => ⋃j : ℕ, @update ι (fun i' => Set (α i')) _ (fun i' => t i' j) i s k
      ·
        ext 
        simpRw [mem_univ_pi]
        apply forall_congrₓ 
        intro i' 
        byCases' i' = i
        ·
          subst h 
          simp 
        ·
          rw [←Ne.def] at h 
          simp [h]
      rw [this, ←Union_univ_pi]
      apply MeasurableSet.Union 
      intro n 
      apply measurable_set_generate_from 
      apply mem_image_of_mem 
      intro j _ 
      dsimp only 
      byCases' h : j = i 
      subst h 
      rwa [update_same]
      rw [update_noteq h]
      apply h1t
    ·
      apply generate_from_le 
      rintro _ ⟨s, hs, rfl⟩
      rw [univ_pi_eq_Inter]
      apply MeasurableSet.Inter 
      intro i 
      apply measurable_pi_apply 
      exact measurable_set_generate_from (hs i (mem_univ i))

/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`
  generate the σ-algebra on `α × β`. -/
theorem generate_from_eq_pi [h : ∀ i, MeasurableSpace (α i)] {C : ∀ i, Set (Set (α i))}
  (hC : ∀ i, generate_from (C i) = h i) (h2C : ∀ i, IsCountablySpanning (C i)) :
  generate_from (pi univ '' pi univ C) = MeasurableSpace.pi :=
  by 
    rw [←funext hC, generate_from_pi_eq h2C]

/-- The product σ-algebra is generated from boxes, i.e. `s.prod t` for sets `s : set α` and
  `t : set β`. -/
theorem generate_from_pi [∀ i, MeasurableSpace (α i)] :
  generate_from (pi univ '' pi univ fun i => { s : Set (α i) | MeasurableSet s }) = MeasurableSpace.pi :=
  generate_from_eq_pi (fun i => generate_from_measurable_set) fun i => is_countably_spanning_measurable_set

namespace MeasureTheory

variable{m : ∀ i, outer_measure (α i)}

/-- An upper bound for the measure in a finite product space.
  It is defined to by taking the image of the set under all projections, and taking the product
  of the measures of these images.
  For measurable boxes it is equal to the correct measure. -/
@[simp]
def pi_premeasure (m : ∀ i, outer_measure (α i)) (s : Set (∀ i, α i)) : ℝ≥0∞ :=
  ∏i, m i (eval i '' s)

theorem pi_premeasure_pi {s : ∀ i, Set (α i)} (hs : (pi univ s).Nonempty) :
  pi_premeasure m (pi univ s) = ∏i, m i (s i) :=
  by 
    simp [hs]

theorem pi_premeasure_pi' [Nonempty ι] {s : ∀ i, Set (α i)} : pi_premeasure m (pi univ s) = ∏i, m i (s i) :=
  by 
    cases' (pi univ s).eq_empty_or_nonempty with h h
    ·
      rcases univ_pi_eq_empty_iff.mp h with ⟨i, hi⟩
      have  : ∃ i, m i (s i) = 0 :=
        ⟨i,
          by 
            simp [hi]⟩
      simpa [h, Finset.card_univ, zero_pow (fintype.card_pos_iff.mpr ‹_›), @eq_comm _ (0 : ℝ≥0∞),
        Finset.prod_eq_zero_iff]
    ·
      simp [h]

theorem pi_premeasure_pi_mono {s t : Set (∀ i, α i)} (h : s ⊆ t) : pi_premeasure m s ≤ pi_premeasure m t :=
  Finset.prod_le_prod' fun i _ => (m i).mono' (image_subset _ h)

theorem pi_premeasure_pi_eval [Nonempty ι] {s : Set (∀ i, α i)} :
  pi_premeasure m (pi univ fun i => eval i '' s) = pi_premeasure m s :=
  by 
    simp [pi_premeasure_pi']

namespace OuterMeasure

/-- `outer_measure.pi m` is the finite product of the outer measures `{m i | i : ι}`.
  It is defined to be the maximal outer measure `n` with the property that
  `n (pi univ s) ≤ ∏ i, m i (s i)`, where `pi univ s` is the product of the sets
  `{s i | i : ι}`. -/
protected def pi (m : ∀ i, outer_measure (α i)) : outer_measure (∀ i, α i) :=
  bounded_by (pi_premeasure m)

theorem pi_pi_le (m : ∀ i, outer_measure (α i)) (s : ∀ i, Set (α i)) : outer_measure.pi m (pi univ s) ≤ ∏i, m i (s i) :=
  by 
    cases' (pi univ s).eq_empty_or_nonempty with h h 
    simp [h]
    exact (bounded_by_le _).trans_eq (pi_premeasure_pi h)

theorem le_pi {m : ∀ i, outer_measure (α i)} {n : outer_measure (∀ i, α i)} :
  n ≤ outer_measure.pi m ↔ ∀ s : ∀ i, Set (α i), (pi univ s).Nonempty → n (pi univ s) ≤ ∏i, m i (s i) :=
  by 
    rw [outer_measure.pi, le_bounded_by']
    split 
    ·
      intro h s hs 
      refine' (h _ hs).trans_eq (pi_premeasure_pi hs)
    ·
      intro h s hs 
      refine' le_transₓ (n.mono$ subset_pi_eval_image univ s) (h _ _)
      simp [univ_pi_nonempty_iff, hs]

end OuterMeasure

namespace Measureₓ

variable[∀ i, MeasurableSpace (α i)](μ : ∀ i, Measureₓ (α i))

section Tprod

open List

variable{δ : Type _}{π : δ → Type _}[∀ x, MeasurableSpace (π x)]

/-- A product of measures in `tprod α l`. -/
protected def tprod (l : List δ) (μ : ∀ i, Measureₓ (π i)) : Measureₓ (tprod π l) :=
  by 
    induction' l with i l ih 
    exact dirac PUnit.unit 
    exact (μ i).Prod ih

@[simp]
theorem tprod_nil (μ : ∀ i, Measureₓ (π i)) : measure.tprod [] μ = dirac PUnit.unit :=
  rfl

@[simp]
theorem tprod_cons (i : δ) (l : List δ) (μ : ∀ i, Measureₓ (π i)) :
  measure.tprod (i :: l) μ = (μ i).Prod (measure.tprod l μ) :=
  rfl

instance sigma_finite_tprod (l : List δ) (μ : ∀ i, Measureₓ (π i)) [∀ i, sigma_finite (μ i)] :
  sigma_finite (measure.tprod l μ) :=
  by 
    induction' l with i l ih
    ·
      rw [tprod_nil]
      infer_instance
    ·
      rw [tprod_cons]
      resetI 
      infer_instance

theorem tprod_tprod (l : List δ) (μ : ∀ i, Measureₓ (π i)) [∀ i, sigma_finite (μ i)] (s : ∀ i, Set (π i)) :
  measure.tprod l μ (Set.Tprodₓ l s) = (l.map fun i => (μ i) (s i)).Prod :=
  by 
    induction' l with i l ih
    ·
      simp 
    rw [tprod_cons, Set.Tprodₓ, prod_prod, map_cons, prod_cons, ih]

end Tprod

section Encodable

open List MeasurableEquiv

variable[Encodable ι]

/-- The product measure on an encodable finite type, defined by mapping `measure.tprod` along the
  equivalence `measurable_equiv.pi_measurable_equiv_tprod`.
  The definition `measure_theory.measure.pi` should be used instead of this one. -/
def pi' : Measureₓ (∀ i, α i) :=
  measure.map (tprod.elim' mem_sorted_univ) (measure.tprod (sorted_univ ι) μ)

theorem pi'_pi [∀ i, sigma_finite (μ i)] (s : ∀ i, Set (α i)) : pi' μ (pi univ s) = ∏i, μ i (s i) :=
  by 
    rw [pi', ←MeasurableEquiv.pi_measurable_equiv_tprod_symm_apply, MeasurableEquiv.map_apply,
        MeasurableEquiv.pi_measurable_equiv_tprod_symm_apply, elim_preimage_pi, tprod_tprod _ μ, ←List.prod_to_finset,
        sorted_univ_to_finset] <;>
      exact sorted_univ_nodup ι

end Encodable

theorem pi_caratheodory : MeasurableSpace.pi ≤ (outer_measure.pi fun i => (μ i).toOuterMeasure).caratheodory :=
  by 
    refine' supr_le _ 
    intro i s hs 
    rw [MeasurableSpace.comap] at hs 
    rcases hs with ⟨s, hs, rfl⟩
    apply bounded_by_caratheodory 
    intro t 
    simpRw [pi_premeasure]
    refine' Finset.prod_add_prod_le' (Finset.mem_univ i) _ _ _
    ·
      simp [image_inter_preimage, image_diff_preimage, measure_inter_add_diff _ hs, le_reflₓ]
    ·
      rintro j - hj 
      apply mono' 
      apply image_subset 
      apply inter_subset_left
    ·
      rintro j - hj 
      apply mono' 
      apply image_subset 
      apply diff_subset

/-- `measure.pi μ` is the finite product of the measures `{μ i | i : ι}`.
  It is defined to be measure corresponding to `measure_theory.outer_measure.pi`. -/
@[irreducible]
protected def pi : Measureₓ (∀ i, α i) :=
  to_measure (outer_measure.pi fun i => (μ i).toOuterMeasure) (pi_caratheodory μ)

theorem pi_pi_aux [∀ i, sigma_finite (μ i)] (s : ∀ i, Set (α i)) (hs : ∀ i, MeasurableSet (s i)) :
  measure.pi μ (pi univ s) = ∏i, μ i (s i) :=
  by 
    refine' le_antisymmₓ _ _
    ·
      rw [measure.pi, to_measure_apply _ _ (MeasurableSet.pi_fintype fun i _ => hs i)]
      apply outer_measure.pi_pi_le
    ·
      haveI  : Encodable ι := Fintype.encodable ι 
      rw [←pi'_pi μ s]
      simpRw [←pi'_pi μ s, measure.pi, to_measure_apply _ _ (MeasurableSet.pi_fintype fun i _ => hs i),
        ←to_outer_measure_apply]
      suffices  : (pi' μ).toOuterMeasure ≤ outer_measure.pi fun i => (μ i).toOuterMeasure
      ·
        exact this _ 
      clear hs s 
      rw [outer_measure.le_pi]
      intro s hs 
      simpRw [to_outer_measure_apply]
      exact (pi'_pi μ s).le

variable{μ}

/-- `measure.pi μ` has finite spanning sets in rectangles of finite spanning sets. -/
def finite_spanning_sets_in.pi {C : ∀ i, Set (Set (α i))} (hμ : ∀ i, (μ i).FiniteSpanningSetsIn (C i)) :
  (measure.pi μ).FiniteSpanningSetsIn (pi univ '' pi univ C) :=
  by 
    haveI  := fun i => (hμ i).SigmaFinite 
    haveI  := Fintype.encodable ι 
    let e : ℕ → ι → ℕ := fun n => (decode (ι → ℕ) n).iget 
    refine' ⟨fun n => pi univ fun i => (hμ i).Set (e n i), fun n => _, fun n => _, _⟩
    ·
      refine' mem_image_of_mem _ fun i _ => (hμ i).set_mem _
    ·
      calc
        measure.pi μ (pi univ fun i => (hμ i).Set (e n i)) ≤
          measure.pi μ (pi univ fun i => to_measurable (μ i) ((hμ i).Set (e n i))) :=
        measure_mono
          (pi_mono$ fun i hi => subset_to_measurable _ _)_ = ∏i, μ i (to_measurable (μ i) ((hμ i).Set (e n i))) :=
        pi_pi_aux μ _ fun i => measurable_set_to_measurable _ _ _ = ∏i, μ i ((hμ i).Set (e n i)) :=
        by 
          simp only [measure_to_measurable]_ < ∞ :=
        Ennreal.prod_lt_top fun i hi => ((hμ i).Finite _).Ne
    ·
      simpRw [(surjective_decode_iget (ι → ℕ)).Union_comp fun x => pi univ fun i => (hμ i).Set (x i),
        Union_univ_pi fun i => (hμ i).Set, (hμ _).spanning, Set.pi_univ]

/-- A measure on a finite product space equals the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding σ-algebras. -/
theorem pi_eq_generate_from {C : ∀ i, Set (Set (α i))} (hC : ∀ i, generate_from (C i) = _inst_3 i)
  (h2C : ∀ i, IsPiSystem (C i)) (h3C : ∀ i, (μ i).FiniteSpanningSetsIn (C i)) {μν : Measureₓ (∀ i, α i)}
  (h₁ : ∀ s : ∀ i, Set (α i), (∀ i, s i ∈ C i) → μν (pi univ s) = ∏i, μ i (s i)) : measure.pi μ = μν :=
  by 
    have h4C : ∀ i s : Set (α i), s ∈ C i → MeasurableSet s
    ·
      intro i s hs 
      rw [←hC]
      exact measurable_set_generate_from hs 
    refine'
      (finite_spanning_sets_in.pi h3C).ext (generate_from_eq_pi hC fun i => (h3C i).IsCountablySpanning).symm
        (IsPiSystem.pi h2C) _ 
    rintro _ ⟨s, hs, rfl⟩
    rw [mem_univ_pi] at hs 
    haveI  := fun i => (h3C i).SigmaFinite 
    simpRw [h₁ s hs, pi_pi_aux μ s fun i => h4C i _ (hs i)]

variable[∀ i, sigma_finite (μ i)]

/-- A measure on a finite product space equals the product measure if they are equal on
  rectangles. -/
theorem pi_eq {μ' : Measureₓ (∀ i, α i)}
  (h : ∀ s : ∀ i, Set (α i), (∀ i, MeasurableSet (s i)) → μ' (pi univ s) = ∏i, μ i (s i)) : measure.pi μ = μ' :=
  pi_eq_generate_from (fun i => generate_from_measurable_set) (fun i => is_pi_system_measurable_set)
    (fun i => (μ i).toFiniteSpanningSetsIn) h

variable(μ)

theorem pi'_eq_pi [Encodable ι] : pi' μ = measure.pi μ :=
  Eq.symm$ pi_eq$ fun s hs => pi'_pi μ s

@[simp]
theorem pi_pi (s : ∀ i, Set (α i)) : measure.pi μ (pi univ s) = ∏i, μ i (s i) :=
  by 
    haveI  : Encodable ι := Fintype.encodable ι 
    rw [←pi'_eq_pi, pi'_pi]

theorem pi_univ : measure.pi μ univ = ∏i, μ i univ :=
  by 
    rw [←pi_univ, pi_pi μ]

theorem pi_ball [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 < r) :
  measure.pi μ (Metric.Ball x r) = ∏i, μ i (Metric.Ball (x i) r) :=
  by 
    rw [ball_pi _ hr, pi_pi]

theorem pi_closed_ball [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 ≤ r) :
  measure.pi μ (Metric.ClosedBall x r) = ∏i, μ i (Metric.ClosedBall (x i) r) :=
  by 
    rw [closed_ball_pi _ hr, pi_pi]

theorem pi_unique_eq_map {β : Type _} {m : MeasurableSpace β} (μ : Measureₓ β) (α : Type _) [Unique α] :
  (measure.pi fun a : α => μ) = map (MeasurableEquiv.funUnique α β).symm μ :=
  by 
    set e := MeasurableEquiv.funUnique α β 
    have  : (pi_premeasure fun _ : α => μ.to_outer_measure) = map e.symm μ
    ·
      ext1 s 
      rw [pi_premeasure, Fintype.prod_unique, to_outer_measure_apply, e.symm.map_apply]
      congr 1 
      exact e.to_equiv.image_eq_preimage s 
    simp only [measure.pi, outer_measure.pi, this, bounded_by_measure, to_outer_measure_to_measure]

theorem map_fun_unique {α β : Type _} [Unique α] {m : MeasurableSpace β} (μ : Measureₓ β) :
  map (MeasurableEquiv.funUnique α β) (measure.pi$ fun _ => μ) = μ :=
  (MeasurableEquiv.funUnique α β).map_apply_eq_iff_map_symm_apply_eq.2 (pi_unique_eq_map μ _).symm

instance pi.sigma_finite : sigma_finite (measure.pi μ) :=
  (finite_spanning_sets_in.pi fun i => (μ i).toFiniteSpanningSetsIn).SigmaFinite

theorem pi_of_empty {α : Type _} [IsEmpty α] {β : α → Type _} {m : ∀ a, MeasurableSpace (β a)}
  (μ : ∀ a : α, Measureₓ (β a)) (x : ∀ a, β a := isEmptyElim) : measure.pi μ = dirac x :=
  by 
    haveI  : ∀ a, sigma_finite (μ a) := isEmptyElim 
    refine' pi_eq fun s hs => _ 
    rw [Fintype.prod_empty, dirac_apply_of_mem]
    exact isEmptyElim

theorem pi_fin_two_eq_map.{u} {α : Finₓ 2 → Type u} {m : ∀ i, MeasurableSpace (α i)} (μ : ∀ i, Measureₓ (α i))
  [∀ i, sigma_finite (μ i)] : measure.pi μ = map (MeasurableEquiv.piFinTwo α).symm ((μ 0).Prod (μ 1)) :=
  by 
    refine' pi_eq fun s hs => _ 
    rw [MeasurableEquiv.map_apply, Finₓ.prod_univ_succ, Finₓ.prod_univ_succ, Finₓ.prod_univ_zero, mul_oneₓ,
      ←measure.prod_prod]
    congr 1 
    ext ⟨a, b⟩
    simp [Finₓ.forall_fin_succ, IsEmpty.forall_iff]

theorem map_pi_fin_two.{u} {α : Finₓ 2 → Type u} {m : ∀ i, MeasurableSpace (α i)} (μ : ∀ i, Measureₓ (α i))
  [∀ i, sigma_finite (μ i)] : map (MeasurableEquiv.piFinTwo α) (measure.pi μ) = (μ 0).Prod (μ 1) :=
  (MeasurableEquiv.piFinTwo α).map_apply_eq_iff_map_symm_apply_eq.2 (pi_fin_two_eq_map μ).symm

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:340:40: in haveI: ././Mathport/Syntax/Translate/Basic.lean:557:61: unsupported notation `«expr![ , ]»
theorem prod_eq_map_fin_two_arrow
{α : Type*}
{m : measurable_space α}
(μ ν : measure α)
[sigma_finite μ]
[sigma_finite ν] : «expr = »(μ.prod ν, map measurable_equiv.fin_two_arrow (measure.pi «expr![ , ]»([μ, ν]))) :=
begin
  haveI [] [":", expr ∀
   i, sigma_finite («expr![ , ]»([μ, ν]) i)] [":=", expr fin.forall_fin_two.2 ⟨«expr‹ ›»(_), «expr‹ ›»(_)⟩],
  exact [expr (map_pi_fin_two «expr![ , ]»([μ, ν])).symm]
end

theorem prod_eq_map_fin_two_arrow_same {α : Type _} {m : MeasurableSpace α} (μ : Measureₓ α) [sigma_finite μ] :
  μ.prod μ = map MeasurableEquiv.finTwoArrow (measure.pi$ fun _ => μ) :=
  by 
    rw [prod_eq_map_fin_two_arrow, Matrix.vec_single_eq_const, Matrix.vec_cons_const]

theorem pi_eval_preimage_null {i : ι} {s : Set (α i)} (hs : μ i s = 0) : measure.pi μ (eval i ⁻¹' s) = 0 :=
  by 
    rcases exists_measurable_superset_of_null hs with ⟨t, hst, htm, hμt⟩
    suffices  : measure.pi μ (eval i ⁻¹' t) = 0 
    exact measure_mono_null (preimage_mono hst) this 
    clear! s 
    rw [←univ_pi_update_univ, pi_pi]
    apply Finset.prod_eq_zero (Finset.mem_univ i)
    simp [hμt]

theorem pi_hyperplane (i : ι) [has_no_atoms (μ i)] (x : α i) : measure.pi μ { f : ∀ i, α i | f i = x } = 0 :=
  show measure.pi μ (eval i ⁻¹' {x}) = 0 from pi_eval_preimage_null _ (measure_singleton x)

theorem ae_eval_ne (i : ι) [has_no_atoms (μ i)] (x : α i) : ∀ᵐy : ∀ i, α i ∂measure.pi μ, y i ≠ x :=
  compl_mem_ae_iff.2 (pi_hyperplane μ i x)

variable{μ}

theorem tendsto_eval_ae_ae {i : ι} : tendsto (eval i) (measure.pi μ).ae (μ i).ae :=
  fun s hs => pi_eval_preimage_null μ hs

theorem ae_pi_le_infi_comap : (measure.pi μ).ae ≤ ⨅i, Filter.comap (eval i) (μ i).ae :=
  le_infi$ fun i => tendsto_eval_ae_ae.le_comap

theorem ae_eq_pi {β : ι → Type _} {f f' : ∀ i, α i → β i} (h : ∀ i, f i =ᵐ[μ i] f' i) :
  (fun x : ∀ i, α i i => f i (x i)) =ᵐ[measure.pi μ] fun x i => f' i (x i) :=
  (eventually_all.2 fun i => tendsto_eval_ae_ae.Eventually (h i)).mono$ fun x hx => funext hx

theorem ae_le_pi {β : ι → Type _} [∀ i, Preorderₓ (β i)] {f f' : ∀ i, α i → β i} (h : ∀ i, f i ≤ᵐ[μ i] f' i) :
  (fun x : ∀ i, α i i => f i (x i)) ≤ᵐ[measure.pi μ] fun x i => f' i (x i) :=
  (eventually_all.2 fun i => tendsto_eval_ae_ae.Eventually (h i)).mono$ fun x hx => hx

theorem ae_le_set_pi {I : Set ι} {s t : ∀ i, Set (α i)} (h : ∀ i _ : i ∈ I, s i ≤ᵐ[μ i] t i) :
  Set.Pi I s ≤ᵐ[measure.pi μ] Set.Pi I t :=
  ((eventually_all_finite (finite.of_fintype I)).2 fun i hi => tendsto_eval_ae_ae.Eventually (h i hi)).mono$
    fun x hst hx i hi => hst i hi$ hx i hi

theorem ae_eq_set_pi {I : Set ι} {s t : ∀ i, Set (α i)} (h : ∀ i _ : i ∈ I, s i =ᵐ[μ i] t i) :
  Set.Pi I s =ᵐ[measure.pi μ] Set.Pi I t :=
  (ae_le_set_pi fun i hi => (h i hi).le).antisymm (ae_le_set_pi fun i hi => (h i hi).symm.le)

section Intervals

variable{μ}[∀ i, PartialOrderₓ (α i)][∀ i, has_no_atoms (μ i)]

theorem pi_Iio_ae_eq_pi_Iic {s : Set ι} {f : ∀ i, α i} :
  (pi s fun i => Iio (f i)) =ᵐ[measure.pi μ] pi s fun i => Iic (f i) :=
  ae_eq_set_pi$ fun i hi => Iio_ae_eq_Iic

theorem pi_Ioi_ae_eq_pi_Ici {s : Set ι} {f : ∀ i, α i} :
  (pi s fun i => Ioi (f i)) =ᵐ[measure.pi μ] pi s fun i => Ici (f i) :=
  ae_eq_set_pi$ fun i hi => Ioi_ae_eq_Ici

theorem univ_pi_Iio_ae_eq_Iic {f : ∀ i, α i} : (pi univ fun i => Iio (f i)) =ᵐ[measure.pi μ] Iic f :=
  by 
    rw [←pi_univ_Iic]
    exact pi_Iio_ae_eq_pi_Iic

theorem univ_pi_Ioi_ae_eq_Ici {f : ∀ i, α i} : (pi univ fun i => Ioi (f i)) =ᵐ[measure.pi μ] Ici f :=
  by 
    rw [←pi_univ_Ici]
    exact pi_Ioi_ae_eq_pi_Ici

theorem pi_Ioo_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :
  (pi s fun i => Ioo (f i) (g i)) =ᵐ[measure.pi μ] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi$ fun i hi => Ioo_ae_eq_Icc

theorem univ_pi_Ioo_ae_eq_Icc {f g : ∀ i, α i} : (pi univ fun i => Ioo (f i) (g i)) =ᵐ[measure.pi μ] Icc f g :=
  by 
    rw [←pi_univ_Icc]
    exact pi_Ioo_ae_eq_pi_Icc

theorem pi_Ioc_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :
  (pi s fun i => Ioc (f i) (g i)) =ᵐ[measure.pi μ] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi$ fun i hi => Ioc_ae_eq_Icc

theorem univ_pi_Ioc_ae_eq_Icc {f g : ∀ i, α i} : (pi univ fun i => Ioc (f i) (g i)) =ᵐ[measure.pi μ] Icc f g :=
  by 
    rw [←pi_univ_Icc]
    exact pi_Ioc_ae_eq_pi_Icc

theorem pi_Ico_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :
  (pi s fun i => Ico (f i) (g i)) =ᵐ[measure.pi μ] pi s fun i => Icc (f i) (g i) :=
  ae_eq_set_pi$ fun i hi => Ico_ae_eq_Icc

theorem univ_pi_Ico_ae_eq_Icc {f g : ∀ i, α i} : (pi univ fun i => Ico (f i) (g i)) =ᵐ[measure.pi μ] Icc f g :=
  by 
    rw [←pi_univ_Icc]
    exact pi_Ico_ae_eq_pi_Icc

end Intervals

/-- If one of the measures `μ i` has no atoms, them `measure.pi µ`
has no atoms. The instance below assumes that all `μ i` have no atoms. -/
theorem pi_has_no_atoms (i : ι) [has_no_atoms (μ i)] : has_no_atoms (measure.pi μ) :=
  ⟨fun x => flip measure_mono_null (pi_hyperplane μ i (x i)) (singleton_subset_iff.2 rfl)⟩

instance  [h : Nonempty ι] [∀ i, has_no_atoms (μ i)] : has_no_atoms (measure.pi μ) :=
  h.elim$ fun i => pi_has_no_atoms i

instance  [∀ i, TopologicalSpace (α i)] [∀ i, is_locally_finite_measure (μ i)] :
  is_locally_finite_measure (measure.pi μ) :=
  by 
    refine' ⟨fun x => _⟩
    choose s hxs ho hμ using fun i => (μ i).exists_is_open_measure_lt_top (x i)
    refine' ⟨pi univ s, set_pi_mem_nhds finite_univ fun i hi => IsOpen.mem_nhds (ho i) (hxs i), _⟩
    rw [pi_pi]
    exact Ennreal.prod_lt_top fun i _ => (hμ i).Ne

variable(μ)

/-- Separating the indices into those that satisfy a predicate `p` and those that don't maps
a product measure to a product of product measures. This is useful to apply Fubini to some subset
of the variables. The converse is `measure_theory.measure.map_pi_equiv_pi_subtype_prod`. -/
theorem map_pi_equiv_pi_subtype_prod_symm (p : ι → Prop) [DecidablePred p] :
  map (Equiv.piEquivPiSubtypeProd p α).symm (measure.prod (measure.pi fun i => μ i) (measure.pi fun i => μ i)) =
    measure.pi μ :=
  by 
    refine' (measure.pi_eq fun s hs => _).symm 
    have A :
      ((Equiv.piEquivPiSubtypeProd p α).symm ⁻¹' Set.Pi Set.Univ fun i : ι => s i) =
        Set.Prod (Set.Pi Set.Univ fun i => s i) (Set.Pi Set.Univ fun i => s i)
    ·
      ext x 
      simp only [Equiv.pi_equiv_pi_subtype_prod_symm_apply, mem_prod, mem_univ_pi, mem_preimage, Subtype.forall]
      split 
      ·
        exact
          fun h =>
            ⟨fun i hi =>
                by 
                  simpa [dif_pos hi] using h i,
              fun i hi =>
                by 
                  simpa [dif_neg hi] using h i⟩
      ·
        intro h i 
        byCases' hi : p i
        ·
          simpa only [dif_pos hi] using h.1 i hi
        ·
          simpa only [dif_neg hi] using h.2 i hi 
    rw [measure.map_apply (measurable_pi_equiv_pi_subtype_prod_symm _ p) (MeasurableSet.univ_pi_fintype hs), A,
      measure.prod_prod, pi_pi, pi_pi, ←Fintype.prod_subtype_mul_prod_subtype p fun i => μ i (s i)]

theorem map_pi_equiv_pi_subtype_prod (p : ι → Prop) [DecidablePred p] :
  map (Equiv.piEquivPiSubtypeProd p α) (measure.pi μ) =
    measure.prod (measure.pi fun i => μ i) (measure.pi fun i => μ i) :=
  by 
    rw [←map_pi_equiv_pi_subtype_prod_symm μ p,
      measure.map_map (measurable_pi_equiv_pi_subtype_prod _ p) (measurable_pi_equiv_pi_subtype_prod_symm _ p)]
    simp only [Equiv.self_comp_symm, map_id]

end Measureₓ

instance measure_space.pi [∀ i, measure_space (α i)] : measure_space (∀ i, α i) :=
  ⟨measure.pi fun i => volume⟩

theorem volume_pi [∀ i, measure_space (α i)] : (volume : Measureₓ (∀ i, α i)) = measure.pi fun i => volume :=
  rfl

theorem volume_pi_pi [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : Measureₓ (α i))] (s : ∀ i, Set (α i)) :
  volume (pi univ s) = ∏i, volume (s i) :=
  measure.pi_pi (fun i => volume) s

theorem volume_pi_ball [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : Measureₓ (α i))] [∀ i, MetricSpace (α i)]
  (x : ∀ i, α i) {r : ℝ} (hr : 0 < r) : volume (Metric.Ball x r) = ∏i, volume (Metric.Ball (x i) r) :=
  measure.pi_ball _ _ hr

theorem volume_pi_closed_ball [∀ i, measure_space (α i)] [∀ i, sigma_finite (volume : Measureₓ (α i))]
  [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 ≤ r) :
  volume (Metric.ClosedBall x r) = ∏i, volume (Metric.ClosedBall (x i) r) :=
  measure.pi_closed_ball _ _ hr

section FunUnique

/-!
### Integral over `ι → α` with `[unique ι]`

In this section we prove some lemmas that relate integrals over `ι → β`, where `ι` is a type with
unique element (e.g., `unit` or `fin 1`) and integrals over `β`.
-/


variable{β E :
    Type
      _}[NormedGroup
      E][NormedSpace ℝ E][MeasurableSpace E][TopologicalSpace.SecondCountableTopology E][BorelSpace E][CompleteSpace E]

theorem integral_fun_unique_pi ι [Unique ι] {m : MeasurableSpace β} (μ : Measureₓ β) (f : (ι → β) → E) :
  (∫y, f y ∂measure.pi fun _ => μ) = ∫x, f fun _ => x ∂μ :=
  by 
    rw [measure.pi_unique_eq_map μ ι, integral_map_equiv] <;> rfl

theorem integral_fun_unique_pi' (ι : Type _) [Unique ι] {m : MeasurableSpace β} (μ : Measureₓ β) (f : β → E) :
  (∫y : ι → β, f (y (default ι)) ∂measure.pi fun _ => μ) = ∫x, f x ∂μ :=
  integral_fun_unique_pi ι μ _

theorem integral_fun_unique (ι : Type _) [Unique ι] [measure_space β] (f : (ι → β) → E) :
  (∫y, f y) = ∫x, f fun _ => x :=
  integral_fun_unique_pi ι volume f

theorem integral_fun_unique' (ι : Type _) [Unique ι] [measure_space β] (f : β → E) :
  (∫y : ι → β, f (y (default ι))) = ∫x, f x :=
  integral_fun_unique_pi' ι volume f

theorem set_integral_fun_unique_pi (ι : Type _) [Unique ι] {m : MeasurableSpace β} (μ : Measureₓ β) (f : (ι → β) → E)
  (s : Set (ι → β)) : (∫y in s, f y ∂measure.pi fun _ => μ) = ∫x in const ι ⁻¹' s, f fun _ => x ∂μ :=
  by 
    rw [measure.pi_unique_eq_map μ ι, set_integral_map_equiv] <;> rfl

theorem set_integral_fun_unique_pi' (ι : Type _) [Unique ι] {m : MeasurableSpace β} (μ : Measureₓ β) (f : β → E)
  (s : Set β) :
  (∫y : ι → β in Function.eval (default ι) ⁻¹' s, f (y (default ι)) ∂measure.pi fun _ => μ) = ∫x in s, f x ∂μ :=
  by 
    erw [set_integral_fun_unique_pi, (Equiv.funUnique ι β).symm_preimage_preimage]

theorem set_integral_fun_unique (ι : Type _) [Unique ι] [measure_space β] (f : (ι → β) → E) (s : Set (ι → β)) :
  (∫y in s, f y) = ∫x in const ι ⁻¹' s, f fun _ => x :=
  by 
    convert set_integral_fun_unique_pi ι volume f s

theorem set_integral_fun_unique' (ι : Type _) [Unique ι] [measure_space β] (f : β → E) (s : Set β) :
  (∫y : ι → β in @Function.eval ι (fun _ => β) (default ι) ⁻¹' s, f (y (default ι))) = ∫x in s, f x :=
  by 
    convert set_integral_fun_unique_pi' ι volume f s

end FunUnique

section FinTwoArrow

variable{β E :
    Type
      _}[NormedGroup
      E][NormedSpace ℝ E][MeasurableSpace E][TopologicalSpace.SecondCountableTopology E][BorelSpace E][CompleteSpace E]

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:340:40: in haveI: ././Mathport/Syntax/Translate/Basic.lean:557:61: unsupported notation `«expr![ , ]»
theorem integral_fin_two_arrow_pi
{m : measurable_space β}
(μ ν : measure β)
[sigma_finite μ]
[sigma_finite ν]
(f : (fin 2 → β) → E) : «expr = »(«expr∫ , ∂ »((y), f y, measure.pi «expr![ , ]»([μ, ν])), «expr∫ , ∂ »((x), f «expr![ , ]»([x.1, x.2]), μ.prod ν)) :=
begin
  haveI [] [":", expr ∀
   i, sigma_finite («expr![ , ]»([μ, ν]) i)] [":=", expr fin.forall_fin_two.2 ⟨«expr‹ ›»(_), «expr‹ ›»(_)⟩],
  rw ["[", expr measure.pi_fin_two_eq_map, ",", expr integral_map_equiv, "]"] [],
  refl
end

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:557:61: unsupported notation `«expr![ , ]»
theorem integral_fin_two_arrow_pi'
{m : measurable_space β}
(μ ν : measure β)
[sigma_finite μ]
[sigma_finite ν]
(f : «expr × »(β, β) → E) : «expr = »(«expr∫ , ∂ »((y : fin 2 → β), f (y 0, y 1), measure.pi «expr![ , ]»([μ, ν])), «expr∫ , ∂ »((x), f x, μ.prod ν)) :=
by { rw ["[", expr measure.prod_eq_map_fin_two_arrow, ",", expr integral_map_equiv, "]"] [],
  refl }

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:557:61: unsupported notation `«expr![ , ]»
theorem integral_fin_two_arrow
[measure_space β]
[sigma_finite (volume : measure β)]
(f : (fin 2 → β) → E) : «expr = »(«expr∫ , »((y), f y), «expr∫ , »((x : «expr × »(β, β)), f «expr![ , ]»([x.1, x.2]))) :=
by rw ["[", expr volume_pi, ",", expr measure.volume_eq_prod, ",", "<-", expr integral_fin_two_arrow_pi, ",", expr matrix.vec_single_eq_const, ",", expr matrix.vec_cons_const, "]"] []

theorem integral_fin_two_arrow' [measure_space β] [sigma_finite (volume : Measureₓ β)] (f : β × β → E) :
  (∫y : Finₓ 2 → β, f (y 0, y 1)) = ∫x, f x :=
  by 
    rw [volume_pi, measure.volume_eq_prod, ←integral_fin_two_arrow_pi', Matrix.vec_single_eq_const,
      Matrix.vec_cons_const]

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:340:40: in haveI: ././Mathport/Syntax/Translate/Basic.lean:557:61: unsupported notation `«expr![ , ]»
theorem set_integral_fin_two_arrow_pi
{m : measurable_space β}
(μ ν : measure β)
[sigma_finite μ]
[sigma_finite ν]
(f : (fin 2 → β) → E)
(s : set (fin 2 → β)) : «expr = »(«expr∫ in , ∂ »((y), s, f y, measure.pi «expr![ , ]»([μ, ν])), «expr∫ in , ∂ »((x : «expr × »(β, β)), «expr ⁻¹' »((fin_two_arrow_equiv β).symm, s), f «expr![ , ]»([x.1, x.2]), μ.prod ν)) :=
begin
  haveI [] [":", expr ∀
   i, sigma_finite («expr![ , ]»([μ, ν]) i)] [":=", expr fin.forall_fin_two.2 ⟨«expr‹ ›»(_), «expr‹ ›»(_)⟩],
  rw ["[", expr measure.pi_fin_two_eq_map, ",", expr set_integral_map_equiv, "]"] [],
  refl
end

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:557:61: unsupported notation `«expr![ , ]»
theorem set_integral_fin_two_arrow_pi'
{m : measurable_space β}
(μ ν : measure β)
[sigma_finite μ]
[sigma_finite ν]
(f : «expr × »(β, β) → E)
(s : set «expr × »(β, β)) : «expr = »(«expr∫ in , ∂ »((y : fin 2 → β), «expr ⁻¹' »(fin_two_arrow_equiv β, s), f (y 0, y 1), measure.pi «expr![ , ]»([μ, ν])), «expr∫ in , ∂ »((x), s, f x, μ.prod ν)) :=
by { rw ["[", expr set_integral_fin_two_arrow_pi, ",", expr equiv.symm_preimage_preimage, "]"] [],
  simp [] [] [] [] [] [] }

-- error in MeasureTheory.Constructions.Pi: ././Mathport/Syntax/Translate/Basic.lean:557:61: unsupported notation `«expr![ , ]»
theorem set_integral_fin_two_arrow
[measure_space β]
[sigma_finite (volume : measure β)]
(f : (fin 2 → β) → E)
(s : set (fin 2 → β)) : «expr = »(«expr∫ in , »((y), s, f y), «expr∫ in , »((x), «expr ⁻¹' »((fin_two_arrow_equiv β).symm, s), f «expr![ , ]»([x.1, x.2]))) :=
by rw ["[", expr measure.volume_eq_prod, ",", "<-", expr set_integral_fin_two_arrow_pi, ",", expr volume_pi, ",", expr matrix.vec_single_eq_const, ",", expr matrix.vec_cons_const, "]"] []

theorem set_integral_fin_two_arrow' [measure_space β] [sigma_finite (volume : Measureₓ β)] (f : β × β → E)
  (s : Set (β × β)) : (∫y : Finₓ 2 → β in finTwoArrowEquiv β ⁻¹' s, f (y 0, y 1)) = ∫x in s, f x :=
  by 
    rw [measure.volume_eq_prod, ←set_integral_fin_two_arrow_pi', volume_pi, Matrix.vec_single_eq_const,
      Matrix.vec_cons_const]

end FinTwoArrow

end MeasureTheory

