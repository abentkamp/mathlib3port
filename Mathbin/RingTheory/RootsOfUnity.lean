import Mathbin.Data.Nat.Parity 
import Mathbin.Data.Polynomial.RingDivision 
import Mathbin.GroupTheory.SpecificGroups.Cyclic 
import Mathbin.RingTheory.IntegralDomain 
import Mathbin.NumberTheory.Divisors 
import Mathbin.Data.Zmod.Basic 
import Mathbin.Tactic.Zify 
import Mathbin.FieldTheory.Separable 
import Mathbin.FieldTheory.Finite.Basic

/-!
# Roots of unity and primitive roots of unity

We define roots of unity in the context of an arbitrary commutative monoid,
as a subgroup of the group of units. We also define a predicate `is_primitive_root` on commutative
monoids, expressing that an element is a primitive root of unity.

## Main definitions

* `roots_of_unity n M`, for `n : ℕ+` is the subgroup of the units of a commutative monoid `M`
  consisting of elements `x` that satisfy `x ^ n = 1`.
* `is_primitive_root ζ k`: an element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,
  and if `l` satisfies `ζ ^ l = 1` then `k ∣ l`.
* `primitive_roots k R`: the finset of primitive `k`-th roots of unity in an integral domain `R`.

## Main results

* `roots_of_unity.is_cyclic`: the roots of unity in an integral domain form a cyclic group.
* `is_primitive_root.zmod_equiv_zpowers`: `zmod k` is equivalent to
  the subgroup generated by a primitive `k`-th root of unity.
* `is_primitive_root.zpowers_eq`: in an integral domain, the subgroup generated by
  a primitive `k`-th root of unity is equal to the `k`-th roots of unity.
* `is_primitive_root.card_primitive_roots`: if an integral domain
   has a primitive `k`-th root of unity, then it has `φ k` of them.

## Implementation details

It is desirable that `roots_of_unity` is a subgroup,
and it will mainly be applied to rings (e.g. the ring of integers in a number field) and fields.
We therefore implement it as a subgroup of the units of a commutative monoid.

We have chosen to define `roots_of_unity n` for `n : ℕ+`, instead of `n : ℕ`,
because almost all lemmas need the positivity assumption,
and in particular the type class instances for `fintype` and `is_cyclic`.

On the other hand, for primitive roots of unity, it is desirable to have a predicate
not just on units, but directly on elements of the ring/field.
For example, we want to say that `exp (2 * pi * I / n)` is a primitive `n`-th root of unity
in the complex numbers, without having to turn that number into a unit first.

This creates a little bit of friction, but lemmas like `is_primitive_root.is_unit` and
`is_primitive_root.coe_units_iff` should provide the necessary glue.

-/


open_locale Classical BigOperators

noncomputable theory

open Polynomial

open Finset

variable{M N G G₀ R S : Type _}

variable[CommMonoidₓ M][CommMonoidₓ N][CommGroupₓ G][CommGroupWithZero G₀]

section rootsOfUnity

variable{k l : ℕ+}

/-- `roots_of_unity k M` is the subgroup of elements `m : units M` that satisfy `m ^ k = 1` -/
def rootsOfUnity (k : ℕ+) (M : Type _) [CommMonoidₓ M] : Subgroup (Units M) :=
  { Carrier := { ζ | (ζ^(k : ℕ)) = 1 }, one_mem' := one_pow _,
    mul_mem' :=
      fun ζ ξ hζ hξ =>
        by 
          simp_all only [Set.mem_set_of_eq, mul_powₓ, one_mulₓ],
    inv_mem' :=
      fun ζ hζ =>
        by 
          simp_all only [Set.mem_set_of_eq, inv_pow, one_inv] }

@[simp]
theorem mem_roots_of_unity (k : ℕ+) (ζ : Units M) : ζ ∈ rootsOfUnity k M ↔ (ζ^(k : ℕ)) = 1 :=
  Iff.rfl

theorem roots_of_unity_le_of_dvd (h : k ∣ l) : rootsOfUnity k M ≤ rootsOfUnity l M :=
  by 
    obtain ⟨d, rfl⟩ := h 
    intro ζ h 
    simp_all only [mem_roots_of_unity, Pnat.mul_coe, pow_mulₓ, one_pow]

theorem map_roots_of_unity (f : Units M →* Units N) (k : ℕ+) : (rootsOfUnity k M).map f ≤ rootsOfUnity k N :=
  by 
    rintro _ ⟨ζ, h, rfl⟩
    simp_all only [←MonoidHom.map_pow, mem_roots_of_unity, SetLike.mem_coe, MonoidHom.map_one]

variable[CommRingₓ R]

@[normCast]
theorem rootsOfUnity.coe_pow (ζ : rootsOfUnity k R) (m : ℕ) : «expr↑ » (ζ^m) = (ζ^m : R) :=
  by 
    change «expr↑ » («expr↑ » (ζ^m) : Units R) = («expr↑ » (ζ : Units R)^m)
    rw [Subgroup.coe_pow, Units.coe_pow]

variable[CommRingₓ S]

/-- Restrict a ring homomorphism between integral domains to the nth roots of unity -/
def RingHom.restrictRootsOfUnity (σ : R →+* S) (n : ℕ+) : rootsOfUnity n R →* rootsOfUnity n S :=
  let h : ∀ ξ : rootsOfUnity n R, (σ ξ^(n : ℕ)) = 1 :=
    fun ξ =>
      by 
        change (σ (ξ : Units R)^(n : ℕ)) = 1
        rw [←σ.map_pow, ←Units.coe_pow, show ((ξ : Units R)^(n : ℕ)) = 1 from ξ.2, Units.coe_one, σ.map_one]
  { toFun :=
      fun ξ =>
        ⟨@unitOfInvertible _ _ _ (invertibleOfPowEqOne _ _ (h ξ) n.2),
          by 
            ext 
            rw [Units.coe_pow]
            exact h ξ⟩,
    map_one' :=
      by 
        ext 
        exact σ.map_one,
    map_mul' :=
      fun ξ₁ ξ₂ =>
        by 
          ext 
          rw [Subgroup.coe_mul, Units.coe_mul]
          exact σ.map_mul _ _ }

@[simp]
theorem RingHom.restrict_roots_of_unity_coe_apply (σ : R →+* S) (ζ : rootsOfUnity k R) :
  «expr↑ » (σ.restrict_roots_of_unity k ζ) = σ («expr↑ » ζ) :=
  rfl

/-- Restrict a ring isomorphism between integral domains to the nth roots of unity -/
def RingEquiv.restrictRootsOfUnity (σ : R ≃+* S) (n : ℕ+) : rootsOfUnity n R ≃* rootsOfUnity n S :=
  { toFun := σ.to_ring_hom.restrict_roots_of_unity n, invFun := σ.symm.to_ring_hom.restrict_roots_of_unity n,
    left_inv :=
      fun ξ =>
        by 
          ext 
          exact σ.symm_apply_apply ξ,
    right_inv :=
      fun ξ =>
        by 
          ext 
          exact σ.apply_symm_apply ξ,
    map_mul' := (σ.to_ring_hom.restrict_roots_of_unity n).map_mul }

@[simp]
theorem RingEquiv.restrict_roots_of_unity_coe_apply (σ : R ≃+* S) (ζ : rootsOfUnity k R) :
  «expr↑ » (σ.restrict_roots_of_unity k ζ) = σ («expr↑ » ζ) :=
  rfl

@[simp]
theorem RingEquiv.restrict_roots_of_unity_symm (σ : R ≃+* S) :
  (σ.restrict_roots_of_unity k).symm = σ.symm.restrict_roots_of_unity k :=
  rfl

variable[IsDomain R]

theorem mem_roots_of_unity_iff_mem_nth_roots {ζ : Units R} : ζ ∈ rootsOfUnity k R ↔ (ζ : R) ∈ nth_roots k (1 : R) :=
  by 
    simp only [mem_roots_of_unity, mem_nth_roots k.pos, Units.ext_iff, Units.coe_one, Units.coe_pow]

variable(k R)

/-- Equivalence between the `k`-th roots of unity in `R` and the `k`-th roots of `1`.

This is implemented as equivalence of subtypes,
because `roots_of_unity` is a subgroup of the group of units,
whereas `nth_roots` is a multiset. -/
def rootsOfUnityEquivNthRoots : rootsOfUnity k R ≃ { x // x ∈ nth_roots k (1 : R) } :=
  by 
    refine'
      { toFun := fun x => ⟨x, mem_roots_of_unity_iff_mem_nth_roots.mp x.2⟩,
        invFun := fun x => ⟨⟨x, x^(k - 1 : ℕ), _, _⟩, _⟩, left_inv := _, right_inv := _ }
    swap 4
    ·
      rintro ⟨x, hx⟩
      ext 
      rfl 
    swap 4
    ·
      rintro ⟨x, hx⟩
      ext 
      rfl 
    all_goals 
      rcases x with ⟨x, hx⟩
      rw [mem_nth_roots k.pos] at hx 
      simp only [Subtype.coe_mk, ←pow_succₓ, ←pow_succ'ₓ, hx, tsub_add_cancel_of_le (show 1 ≤ (k : ℕ) from k.one_le)]
    ·
      show ((_ : Units R)^(k : ℕ)) = 1
      simp only [Units.ext_iff, hx, Units.coe_mk, Units.coe_one, Subtype.coe_mk, Units.coe_pow]

variable{k R}

@[simp]
theorem roots_of_unity_equiv_nth_roots_apply (x : rootsOfUnity k R) : (rootsOfUnityEquivNthRoots R k x : R) = x :=
  rfl

@[simp]
theorem roots_of_unity_equiv_nth_roots_symm_apply (x : { x // x ∈ nth_roots k (1 : R) }) :
  ((rootsOfUnityEquivNthRoots R k).symm x : R) = x :=
  rfl

variable(k R)

instance rootsOfUnity.fintype : Fintype (rootsOfUnity k R) :=
  Fintype.ofEquiv { x // x ∈ nth_roots k (1 : R) }$ (rootsOfUnityEquivNthRoots R k).symm

instance rootsOfUnity.is_cyclic : IsCyclic (rootsOfUnity k R) :=
  is_cyclic_of_subgroup_is_domain ((Units.coeHom R).comp (rootsOfUnity k R).Subtype)
    (Units.ext.comp Subtype.val_injective)

theorem card_roots_of_unity : Fintype.card (rootsOfUnity k R) ≤ k :=
  calc Fintype.card (rootsOfUnity k R) = Fintype.card { x // x ∈ nth_roots k (1 : R) } :=
    Fintype.card_congr (rootsOfUnityEquivNthRoots R k)
    _ ≤ (nth_roots k (1 : R)).attach.card := Multiset.card_le_of_le (Multiset.erase_dup_le _)
    _ = (nth_roots k (1 : R)).card := Multiset.card_attach 
    _ ≤ k := card_nth_roots k 1
    

variable{k R}

theorem RingHom.map_root_of_unity_eq_pow_self (σ : R →+* R) (ζ : rootsOfUnity k R) : ∃ m : ℕ, σ ζ = (ζ^m) :=
  by 
    obtain ⟨m, hm⟩ := (σ.restrict_roots_of_unity k).map_cyclic 
    rw [←σ.restrict_roots_of_unity_coe_apply, hm, zpow_eq_mod_order_of,
      ←Int.to_nat_of_nonneg (m.mod_nonneg (int.coe_nat_ne_zero.mpr (pos_iff_ne_zero.mp (order_of_pos ζ)))),
      zpow_coe_nat, rootsOfUnity.coe_pow]
    exact ⟨(m % orderOf ζ).toNat, rfl⟩

end rootsOfUnity

/-- An element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,
and if `l` satisfies `ζ ^ l = 1` then `k ∣ l`. -/
structure IsPrimitiveRoot(ζ : M)(k : ℕ) : Prop where 
  pow_eq_one : (ζ^(k : ℕ)) = 1
  dvd_of_pow_eq_one : ∀ l : ℕ, (ζ^l) = 1 → k ∣ l

section primitiveRoots

variable{k : ℕ}

/-- `primitive_roots k R` is the finset of primitive `k`-th roots of unity
in the integral domain `R`. -/
def primitiveRoots (k : ℕ) (R : Type _) [CommRingₓ R] [IsDomain R] : Finset R :=
  (nth_roots k (1 : R)).toFinset.filter fun ζ => IsPrimitiveRoot ζ k

variable[CommRingₓ R][IsDomain R]

@[simp]
theorem mem_primitive_roots {ζ : R} (h0 : 0 < k) : ζ ∈ primitiveRoots k R ↔ IsPrimitiveRoot ζ k :=
  by 
    rw [primitiveRoots, mem_filter, Multiset.mem_to_finset, mem_nth_roots h0, and_iff_right_iff_imp]
    exact IsPrimitiveRoot.pow_eq_one

end primitiveRoots

namespace IsPrimitiveRoot

variable{k l : ℕ}

theorem iff_def (ζ : M) (k : ℕ) : IsPrimitiveRoot ζ k ↔ (ζ^k) = 1 ∧ ∀ l : ℕ, (ζ^l) = 1 → k ∣ l :=
  ⟨fun ⟨h1, h2⟩ => ⟨h1, h2⟩, fun ⟨h1, h2⟩ => ⟨h1, h2⟩⟩

theorem mk_of_lt (ζ : M) (hk : 0 < k) (h1 : (ζ^k) = 1) (h : ∀ l : ℕ, 0 < l → l < k → (ζ^l) ≠ 1) : IsPrimitiveRoot ζ k :=
  by 
    refine' ⟨h1, _⟩
    intro l hl 
    apply dvd_trans _ (k.gcd_dvd_right l)
    suffices  : k.gcd l = k
    ·
      rw [this]
    rw [eq_iff_le_not_lt]
    refine' ⟨Nat.le_of_dvdₓ hk (k.gcd_dvd_left l), _⟩
    intro h' 
    apply h _ (Nat.gcd_pos_of_pos_leftₓ _ hk) h' 
    exact pow_gcd_eq_one _ h1 hl

section CommMonoidₓ

variable{ζ : M}(h : IsPrimitiveRoot ζ k)

theorem pow_eq_one_iff_dvd (l : ℕ) : (ζ^l) = 1 ↔ k ∣ l :=
  ⟨h.dvd_of_pow_eq_one l,
    by 
      rintro ⟨i, rfl⟩
      simp only [pow_mulₓ, h.pow_eq_one, one_pow, Pnat.mul_coe]⟩

theorem IsUnit (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) : IsUnit ζ :=
  by 
    apply is_unit_of_mul_eq_one ζ (ζ^k - 1)
    rw [←pow_succₓ, tsub_add_cancel_of_le h0.nat_succ_le, h.pow_eq_one]

theorem pow_ne_one_of_pos_of_lt (h0 : 0 < l) (hl : l < k) : (ζ^l) ≠ 1 :=
  mt (Nat.le_of_dvdₓ h0 ∘ h.dvd_of_pow_eq_one _)$ not_le_of_lt hl

theorem pow_inj (h : IsPrimitiveRoot ζ k) ⦃i j : ℕ⦄ (hi : i < k) (hj : j < k) (H : (ζ^i) = (ζ^j)) : i = j :=
  by 
    wlog hij : i ≤ j 
    apply le_antisymmₓ hij 
    rw [←tsub_eq_zero_iff_le]
    apply Nat.eq_zero_of_dvd_of_lt _ (lt_of_le_of_ltₓ tsub_le_self hj)
    apply h.dvd_of_pow_eq_one 
    rw [←((h.is_unit (lt_of_le_of_ltₓ (Nat.zero_leₓ _) hi)).pow i).mul_left_inj, ←pow_addₓ, tsub_add_cancel_of_le hij,
      H, one_mulₓ]

theorem one : IsPrimitiveRoot (1 : M) 1 :=
  { pow_eq_one := pow_oneₓ _, dvd_of_pow_eq_one := fun l hl => one_dvd _ }

@[simp]
theorem one_right_iff : IsPrimitiveRoot ζ 1 ↔ ζ = 1 :=
  by 
    split 
    ·
      intro h 
      rw [←pow_oneₓ ζ, h.pow_eq_one]
    ·
      rintro rfl 
      exact one

@[simp]
theorem coe_units_iff {ζ : Units M} : IsPrimitiveRoot (ζ : M) k ↔ IsPrimitiveRoot ζ k :=
  by 
    simp only [iff_def, Units.ext_iff, Units.coe_pow, Units.coe_one]

theorem pow_of_coprime (h : IsPrimitiveRoot ζ k) (i : ℕ) (hi : i.coprime k) : IsPrimitiveRoot (ζ^i) k :=
  by 
    byCases' h0 : k = 0
    ·
      subst k 
      simp_all only [pow_oneₓ, Nat.coprime_zero_rightₓ]
    rcases h.is_unit (Nat.pos_of_ne_zeroₓ h0) with ⟨ζ, rfl⟩
    rw [←Units.coe_pow]
    rw [coe_units_iff] at h⊢
    refine'
      { pow_eq_one :=
          by 
            rw [←pow_mul', pow_mulₓ, h.pow_eq_one, one_pow],
        dvd_of_pow_eq_one := _ }
    intro l hl 
    apply h.dvd_of_pow_eq_one 
    rw [←pow_oneₓ ζ, ←zpow_coe_nat ζ, ←hi.gcd_eq_one, Nat.gcd_eq_gcd_ab, zpow_add, mul_powₓ, ←zpow_coe_nat, ←zpow_mul,
      mul_right_commₓ]
    simp only [zpow_mul, hl, h.pow_eq_one, one_zpow, one_pow, one_mulₓ, zpow_coe_nat]

theorem pow_of_prime (h : IsPrimitiveRoot ζ k) {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ k) :
  IsPrimitiveRoot (ζ^p) k :=
  h.pow_of_coprime p (hprime.coprime_iff_not_dvd.2 hdiv)

theorem pow_iff_coprime (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) (i : ℕ) : IsPrimitiveRoot (ζ^i) k ↔ i.coprime k :=
  by 
    refine' ⟨_, h.pow_of_coprime i⟩
    intro hi 
    obtain ⟨a, ha⟩ := i.gcd_dvd_left k 
    obtain ⟨b, hb⟩ := i.gcd_dvd_right k 
    suffices  : b = k
    ·
      rwa [this, ←one_mulₓ k, Nat.mul_left_inj h0, eq_comm] at hb 
    rw [ha] at hi 
    rw [mul_commₓ] at hb 
    apply Nat.dvd_antisymm ⟨i.gcd k, hb⟩ (hi.dvd_of_pow_eq_one b _)
    rw [←pow_mul', ←mul_assocₓ, ←hb, pow_mulₓ, h.pow_eq_one, one_pow]

end CommMonoidₓ

section CommGroupₓ

variable{ζ : G}

theorem zpow_eq_one (h : IsPrimitiveRoot ζ k) : (ζ^(k : ℤ)) = 1 :=
  by 
    rw [zpow_coe_nat]
    exact h.pow_eq_one

theorem zpow_eq_one_iff_dvd (h : IsPrimitiveRoot ζ k) (l : ℤ) : (ζ^l) = 1 ↔ (k : ℤ) ∣ l :=
  by 
    byCases' h0 : 0 ≤ l
    ·
      lift l to ℕ using h0 
      rw [zpow_coe_nat]
      normCast 
      exact h.pow_eq_one_iff_dvd l
    ·
      have  : 0 ≤ -l
      ·
        simp only [not_leₓ, neg_nonneg] at h0⊢
        exact le_of_ltₓ h0 
      lift -l to ℕ using this with l' hl' 
      rw [←dvd_neg, ←hl']
      normCast 
      rw [←h.pow_eq_one_iff_dvd, ←inv_inj, ←zpow_neg, ←hl', zpow_coe_nat, one_inv]

theorem inv (h : IsPrimitiveRoot ζ k) : IsPrimitiveRoot (ζ⁻¹) k :=
  { pow_eq_one :=
      by 
        simp only [h.pow_eq_one, one_inv, eq_self_iff_true, inv_pow],
    dvd_of_pow_eq_one :=
      by 
        intro l hl 
        apply h.dvd_of_pow_eq_one l 
        rw [←inv_inj, ←inv_pow, hl, one_inv] }

@[simp]
theorem inv_iff : IsPrimitiveRoot (ζ⁻¹) k ↔ IsPrimitiveRoot ζ k :=
  by 
    refine' ⟨_, fun h => inv h⟩
    intro h 
    rw [←inv_invₓ ζ]
    exact inv h

theorem zpow_of_gcd_eq_one (h : IsPrimitiveRoot ζ k) (i : ℤ) (hi : i.gcd k = 1) : IsPrimitiveRoot (ζ^i) k :=
  by 
    byCases' h0 : 0 ≤ i
    ·
      lift i to ℕ using h0 
      rw [zpow_coe_nat]
      exact h.pow_of_coprime i hi 
    have  : 0 ≤ -i
    ·
      simp only [not_leₓ, neg_nonneg] at h0⊢
      exact le_of_ltₓ h0 
    lift -i to ℕ using this with i' hi' 
    rw [←inv_iff, ←zpow_neg, ←hi', zpow_coe_nat]
    apply h.pow_of_coprime 
    rw [Int.gcdₓ, ←Int.nat_abs_neg, ←hi'] at hi 
    exact hi

@[simp]
theorem coe_subgroup_iff (H : Subgroup G) {ζ : H} : IsPrimitiveRoot (ζ : G) k ↔ IsPrimitiveRoot ζ k :=
  by 
    simp only [iff_def, ←Subgroup.coe_pow, ←H.coe_one, ←Subtype.ext_iff]

end CommGroupₓ

section CommGroupWithZero

variable{ζ : G₀}

theorem zpow_eq_one₀ (h : IsPrimitiveRoot ζ k) : (ζ^(k : ℤ)) = 1 :=
  by 
    rw [zpow_coe_nat]
    exact h.pow_eq_one

theorem zpow_eq_one_iff_dvd₀ (h : IsPrimitiveRoot ζ k) (l : ℤ) : (ζ^l) = 1 ↔ (k : ℤ) ∣ l :=
  by 
    byCases' h0 : 0 ≤ l
    ·
      lift l to ℕ using h0 
      rw [zpow_coe_nat]
      normCast 
      exact h.pow_eq_one_iff_dvd l
    ·
      have  : 0 ≤ -l
      ·
        simp only [not_leₓ, neg_nonneg] at h0⊢
        exact le_of_ltₓ h0 
      lift -l to ℕ using this with l' hl' 
      rw [←dvd_neg, ←hl']
      normCast 
      rw [←h.pow_eq_one_iff_dvd, ←inv_inj₀, ←zpow_neg₀, ←hl', zpow_coe_nat, inv_one]

theorem inv' (h : IsPrimitiveRoot ζ k) : IsPrimitiveRoot (ζ⁻¹) k :=
  { pow_eq_one :=
      by 
        simp only [h.pow_eq_one, inv_one, eq_self_iff_true, inv_pow₀],
    dvd_of_pow_eq_one :=
      by 
        intro l hl 
        apply h.dvd_of_pow_eq_one l 
        rw [←inv_inj₀, ←inv_pow₀, hl, inv_one] }

@[simp]
theorem inv_iff' : IsPrimitiveRoot (ζ⁻¹) k ↔ IsPrimitiveRoot ζ k :=
  by 
    refine' ⟨_, fun h => inv' h⟩
    intro h 
    rw [←inv_inv₀ ζ]
    exact inv' h

theorem zpow_of_gcd_eq_one₀ (h : IsPrimitiveRoot ζ k) (i : ℤ) (hi : i.gcd k = 1) : IsPrimitiveRoot (ζ^i) k :=
  by 
    byCases' h0 : 0 ≤ i
    ·
      lift i to ℕ using h0 
      rw [zpow_coe_nat]
      exact h.pow_of_coprime i hi 
    have  : 0 ≤ -i
    ·
      simp only [not_leₓ, neg_nonneg] at h0⊢
      exact le_of_ltₓ h0 
    lift -i to ℕ using this with i' hi' 
    rw [←inv_iff', ←zpow_neg₀, ←hi', zpow_coe_nat]
    apply h.pow_of_coprime 
    rw [Int.gcdₓ, ←Int.nat_abs_neg, ←hi'] at hi 
    exact hi

end CommGroupWithZero

section IsDomain

variable{ζ : R}

variable[CommRingₓ R][IsDomain R]

@[simp]
theorem primitive_roots_zero : primitiveRoots 0 R = ∅ :=
  by 
    rw [←Finset.val_eq_zero, ←Multiset.subset_zero, ←nth_roots_zero (1 : R), primitiveRoots]
    simp only [Finset.not_mem_empty, forall_const, forall_prop_of_false, Multiset.to_finset_zero,
      Finset.filter_true_of_mem, Finset.empty_val, not_false_iff, Multiset.zero_subset, nth_roots_zero]

@[simp]
theorem primitive_roots_one : primitiveRoots 1 R = {(1 : R)} :=
  by 
    apply Finset.eq_singleton_iff_unique_mem.2
    split 
    ·
      simp only [IsPrimitiveRoot.one_right_iff, mem_primitive_roots zero_lt_one]
    ·
      intro x hx 
      rw [mem_primitive_roots zero_lt_one, IsPrimitiveRoot.one_right_iff] at hx 
      exact hx

theorem neg_one (p : ℕ) [CharP R p] (hp : p ≠ 2) : IsPrimitiveRoot (-1 : R) 2 :=
  mk_of_lt (-1 : R)
      (by 
        decide)
      (by 
        simp only [one_pow, neg_sq])$
    by 
      intro l hl0 hl2 
      obtain rfl : l = 1
      ·
        unfreezingI 
          clear! R p 
        decide! 
      simp only [pow_oneₓ, Ne.def]
      intro h 
      suffices h2 : p ∣ 2
      ·
        have  := CharP.char_ne_one R p 
        unfreezingI 
          clear! R 
        have aux :=
          Nat.le_of_dvdₓ
            (by 
              decide)
            h2 
        revert this hp h2 
        revert p 
        decide 
      simp only [←CharP.cast_eq_zero_iff R p, Nat.cast_bit0, Nat.cast_one]
      rw [bit0, ←h, neg_add_selfₓ]

theorem eq_neg_one_of_two_right (h : IsPrimitiveRoot ζ 2) : ζ = -1 :=
  by 
    apply (eq_or_eq_neg_of_sq_eq_sq ζ 1 _).resolve_left
    ·
      rw [←pow_oneₓ ζ]
      apply h.pow_ne_one_of_pos_of_lt <;> decide
    ·
      simp only [h.pow_eq_one, one_pow]

end IsDomain

section IsDomain

variable[CommRingₓ R]

variable{ζ : Units R}(h : IsPrimitiveRoot ζ k)

protected theorem mem_roots_of_unity {n : ℕ+} (h : IsPrimitiveRoot ζ n) : ζ ∈ rootsOfUnity n R :=
  h.pow_eq_one

/-- The (additive) monoid equivalence between `zmod k`
and the powers of a primitive root of unity `ζ`. -/
def zmod_equiv_zpowers (h : IsPrimitiveRoot ζ k) : Zmod k ≃+ Additive (Subgroup.zpowers ζ) :=
  AddEquiv.ofBijective
    (AddMonoidHom.liftOfRightInverse (Int.castAddHom$ Zmod k) _ Zmod.int_cast_right_inverse
      ⟨{ toFun := fun i => Additive.ofMul (⟨_, i, rfl⟩ : Subgroup.zpowers ζ),
          map_zero' :=
            by 
              simp only [zpow_zero]
              rfl,
          map_add' :=
            by 
              intro i j 
              simp only [zpow_add]
              rfl },
        fun i hi =>
          by 
            simp only [AddMonoidHom.mem_ker, CharP.int_cast_eq_zero_iff (Zmod k) k, AddMonoidHom.coe_mk,
              Int.coe_cast_add_hom] at hi⊢
            obtain ⟨i, rfl⟩ := hi 
            simp only [zpow_mul, h.pow_eq_one, one_zpow, zpow_coe_nat]
            rfl⟩)
    (by 
      split 
      ·
        rw [AddMonoidHom.injective_iff]
        intro i hi 
        rw [Subtype.ext_iff] at hi 
        have  := (h.zpow_eq_one_iff_dvd _).mp hi 
        rw [←(CharP.int_cast_eq_zero_iff (Zmod k) k _).mpr this, eq_comm]
        exact Zmod.int_cast_right_inverse i
      ·
        rintro ⟨ξ, i, rfl⟩
        refine' ⟨Int.castAddHom _ i, _⟩
        rw [AddMonoidHom.lift_of_right_inverse_comp_apply]
        rfl)

@[simp]
theorem zmod_equiv_zpowers_apply_coe_int (i : ℤ) :
  h.zmod_equiv_zpowers i = Additive.ofMul (⟨ζ^i, i, rfl⟩ : Subgroup.zpowers ζ) :=
  AddMonoidHom.lift_of_right_inverse_comp_apply _ _ Zmod.int_cast_right_inverse _ _

@[simp]
theorem zmod_equiv_zpowers_apply_coe_nat (i : ℕ) :
  h.zmod_equiv_zpowers i = Additive.ofMul (⟨ζ^i, i, rfl⟩ : Subgroup.zpowers ζ) :=
  by 
    have  : (i : Zmod k) = (i : ℤ)
    ·
      normCast 
    simp only [this, zmod_equiv_zpowers_apply_coe_int, zpow_coe_nat]
    rfl

@[simp]
theorem zmod_equiv_zpowers_symm_apply_zpow (i : ℤ) :
  h.zmod_equiv_zpowers.symm (Additive.ofMul (⟨ζ^i, i, rfl⟩ : Subgroup.zpowers ζ)) = i :=
  by 
    rw [←h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_int]

@[simp]
theorem zmod_equiv_zpowers_symm_apply_zpow' (i : ℤ) : h.zmod_equiv_zpowers.symm ⟨ζ^i, i, rfl⟩ = i :=
  h.zmod_equiv_zpowers_symm_apply_zpow i

@[simp]
theorem zmod_equiv_zpowers_symm_apply_pow (i : ℕ) :
  h.zmod_equiv_zpowers.symm (Additive.ofMul (⟨ζ^i, i, rfl⟩ : Subgroup.zpowers ζ)) = i :=
  by 
    rw [←h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_nat]

@[simp]
theorem zmod_equiv_zpowers_symm_apply_pow' (i : ℕ) : h.zmod_equiv_zpowers.symm ⟨ζ^i, i, rfl⟩ = i :=
  h.zmod_equiv_zpowers_symm_apply_pow i

/-- If there is a `n`-th primitive root of unity in `R` and `b` divides `n`,
then there is a `b`-th primitive root of unity in `R`. -/
theorem pow {ζ : R} {n : ℕ} {a b : ℕ} (hn : 0 < n) (h : IsPrimitiveRoot ζ n) (hprod : n = a*b) :
  IsPrimitiveRoot (ζ^a) b :=
  by 
    subst n 
    simp only [iff_def, ←pow_mulₓ, h.pow_eq_one, eq_self_iff_true, true_andₓ]
    intro l hl 
    have ha0 : a ≠ 0
    ·
      rintro rfl 
      simpa only [Nat.not_lt_zeroₓ, zero_mul] using hn 
    rwa [←mul_dvd_mul_iff_left ha0]
    exact h.dvd_of_pow_eq_one _ hl

variable[IsDomain R]

theorem zpowers_eq {k : ℕ+} {ζ : Units R} (h : IsPrimitiveRoot ζ k) : Subgroup.zpowers ζ = rootsOfUnity k R :=
  by 
    apply SetLike.coe_injective 
    haveI  : Fact (0 < (k : ℕ)) := ⟨k.pos⟩
    haveI F : Fintype (Subgroup.zpowers ζ) := Fintype.ofEquiv _ h.zmod_equiv_zpowers.toEquiv 
    refine'
      @Set.eq_of_subset_of_card_le (Units R) (Subgroup.zpowers ζ) (rootsOfUnity k R) F (rootsOfUnity.fintype R k)
        (Subgroup.zpowers_subset$ show ζ ∈ rootsOfUnity k R from h.pow_eq_one) _ 
    calc Fintype.card (rootsOfUnity k R) ≤ k := card_roots_of_unity R k _ = Fintype.card (Zmod k) :=
      (Zmod.card k).symm _ = Fintype.card (Subgroup.zpowers ζ) := Fintype.card_congr h.zmod_equiv_zpowers.toEquiv

theorem eq_pow_of_mem_roots_of_unity {k : ℕ+} {ζ ξ : Units R} (h : IsPrimitiveRoot ζ k) (hξ : ξ ∈ rootsOfUnity k R) :
  ∃ (i : ℕ)(hi : i < k), (ζ^i) = ξ :=
  by 
    obtain ⟨n, rfl⟩ : ∃ n : ℤ, (ζ^n) = ξ
    ·
      rwa [←h.zpowers_eq] at hξ 
    have hk0 : (0 : ℤ) < k :=
      by 
        exactModCast k.pos 
    let i := n % k 
    have hi0 : 0 ≤ i := Int.mod_nonneg _ (ne_of_gtₓ hk0)
    lift i to ℕ using hi0 with i₀ hi₀ 
    refine' ⟨i₀, _, _⟩
    ·
      zify 
      rw [hi₀]
      exact Int.mod_lt_of_pos _ hk0
    ·
      have aux := h.zpow_eq_one 
      rw [←coe_coe] at aux 
      rw [←zpow_coe_nat, hi₀, ←Int.mod_add_div n k, zpow_add, zpow_mul, aux, one_zpow, mul_oneₓ]

theorem eq_pow_of_pow_eq_one {k : ℕ} {ζ ξ : R} (h : IsPrimitiveRoot ζ k) (hξ : (ξ^k) = 1) (h0 : 0 < k) :
  ∃ (i : _)(_ : i < k), (ζ^i) = ξ :=
  by 
    obtain ⟨ζ, rfl⟩ := h.is_unit h0 
    obtain ⟨ξ, rfl⟩ := is_unit_of_pow_eq_one ξ k hξ h0 
    obtain ⟨k, rfl⟩ : ∃ k' : ℕ+, k = k' := ⟨⟨k, h0⟩, rfl⟩
    simp only [←Units.coe_pow, ←Units.ext_iff]
    rw [coe_units_iff] at h 
    apply h.eq_pow_of_mem_roots_of_unity 
    rw [mem_roots_of_unity, Units.ext_iff, Units.coe_pow, hξ, Units.coe_one]

theorem is_primitive_root_iff' {k : ℕ+} {ζ ξ : Units R} (h : IsPrimitiveRoot ζ k) :
  IsPrimitiveRoot ξ k ↔ ∃ (i : _)(_ : i < (k : ℕ))(hi : i.coprime k), (ζ^i) = ξ :=
  by 
    split 
    ·
      intro hξ 
      obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_mem_roots_of_unity hξ.pow_eq_one 
      rw [h.pow_iff_coprime k.pos] at hξ 
      exact ⟨i, hik, hξ, rfl⟩
    ·
      rintro ⟨i, -, hi, rfl⟩
      exact h.pow_of_coprime i hi

theorem is_primitive_root_iff {k : ℕ} {ζ ξ : R} (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) :
  IsPrimitiveRoot ξ k ↔ ∃ (i : _)(_ : i < k)(hi : i.coprime k), (ζ^i) = ξ :=
  by 
    split 
    ·
      intro hξ 
      obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_pow_eq_one hξ.pow_eq_one h0 
      rw [h.pow_iff_coprime h0] at hξ 
      exact ⟨i, hik, hξ, rfl⟩
    ·
      rintro ⟨i, -, hi, rfl⟩
      exact h.pow_of_coprime i hi

theorem card_roots_of_unity' {n : ℕ+} (h : IsPrimitiveRoot ζ n) : Fintype.card (rootsOfUnity n R) = n :=
  by 
    haveI  : Fact (0 < «expr↑ » n) := ⟨n.pos⟩
    let e := h.zmod_equiv_zpowers 
    haveI F : Fintype (Subgroup.zpowers ζ) := Fintype.ofEquiv _ e.to_equiv 
    calc Fintype.card (rootsOfUnity n R) = Fintype.card (Subgroup.zpowers ζ) :=
      Fintype.card_congr$
        by 
          rw [h.zpowers_eq]_ = Fintype.card (Zmod n) :=
      Fintype.card_congr e.to_equiv.symm _ = n := Zmod.card n

theorem card_roots_of_unity {ζ : R} {n : ℕ+} (h : IsPrimitiveRoot ζ n) : Fintype.card (rootsOfUnity n R) = n :=
  by 
    obtain ⟨ζ, hζ⟩ := h.is_unit n.pos 
    rw [←hζ, IsPrimitiveRoot.coe_units_iff] at h 
    exact h.card_roots_of_unity'

/-- The cardinality of the multiset `nth_roots ↑n (1 : R)` is `n`
if there is a primitive root of unity in `R`. -/
theorem card_nth_roots {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) : (nth_roots n (1 : R)).card = n :=
  by 
    cases' Nat.eq_zero_or_posₓ n with hzero hpos
    ·
      simp only [hzero, Multiset.card_zero, nth_roots_zero]
    rw [eq_iff_le_not_lt]
    use card_nth_roots n 1
    ·
      rw [not_ltₓ]
      have hcard : Fintype.card { x // x ∈ nth_roots n (1 : R) } ≤ (nth_roots n (1 : R)).attach.card :=
        Multiset.card_le_of_le (Multiset.erase_dup_le _)
      rw [Multiset.card_attach] at hcard 
      rw [←Pnat.to_pnat'_coe hpos] at hcard h⊢
      set m := Nat.toPnat' n 
      rw [←Fintype.card_congr (rootsOfUnityEquivNthRoots R m), card_roots_of_unity h] at hcard 
      exact hcard

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:340:40: in by_contra: ././Mathport/Syntax/Translate/Tactic/Basic.lean:41:45: missing argument
/-- The multiset `nth_roots ↑n (1 : R)` has no repeated elements
if there is a primitive root of unity in `R`. -/
theorem nth_roots_nodup {ζ : R} {n : exprℕ()} (h : is_primitive_root ζ n) : (nth_roots n (1 : R)).nodup :=
begin
  cases [expr nat.eq_zero_or_pos n] ["with", ident hzero, ident hpos],
  { simp [] [] ["only"] ["[", expr hzero, ",", expr multiset.nodup_zero, ",", expr nth_roots_zero, "]"] [] [] },
  apply [expr (@multiset.erase_dup_eq_self R _ _).1],
  rw [expr eq_iff_le_not_lt] [],
  split,
  { exact [expr multiset.erase_dup_le (nth_roots n (1 : R))] },
  { by_contra [ident ha],
    replace [ident ha] [] [":=", expr multiset.card_lt_of_lt ha],
    rw [expr card_nth_roots h] ["at", ident ha],
    have [ident hrw] [":", expr «expr = »((nth_roots n (1 : R)).erase_dup.card, fintype.card {x // «expr ∈ »(x, nth_roots n (1 : R))})] [],
    { set [] [ident fs] [] [":="] [expr (⟨(nth_roots n (1 : R)).erase_dup, multiset.nodup_erase_dup _⟩ : finset R)] [],
      rw ["[", "<-", expr finset.card_mk, ",", "<-", expr fintype.card_of_subtype fs _, "]"] [],
      intro [ident x],
      simp [] [] ["only"] ["[", expr multiset.mem_erase_dup, ",", expr finset.mem_mk, "]"] [] [] },
    rw ["<-", expr pnat.to_pnat'_coe hpos] ["at", ident h, ident hrw, ident ha],
    set [] [ident m] [] [":="] [expr nat.to_pnat' n] [],
    rw ["[", expr hrw, ",", "<-", expr fintype.card_congr (roots_of_unity_equiv_nth_roots R m), ",", expr card_roots_of_unity h, "]"] ["at", ident ha],
    exact [expr nat.lt_asymm ha ha] }
end

@[simp]
theorem card_nth_roots_finset {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) : (nth_roots_finset n R).card = n :=
  by 
    rw [nth_roots_finset, ←Multiset.to_finset_eq (nth_roots_nodup h), card_mk, h.card_nth_roots]

open_locale Nat

/-- If an integral domain has a primitive `k`-th root of unity, then it has `φ k` of them. -/
theorem card_primitive_roots {ζ : R} {k : ℕ} (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) : (primitiveRoots k R).card = φ k :=
  by 
    symm 
    refine' Finset.card_congr (fun i _ => ζ^i) _ _ _
    ·
      simp only [true_andₓ, and_imp, mem_filter, mem_range, mem_univ]
      rintro i - hi 
      rw [mem_primitive_roots h0]
      exact h.pow_of_coprime i hi.symm
    ·
      simp only [true_andₓ, and_imp, mem_filter, mem_range, mem_univ]
      rintro i j hi - hj - H 
      exact h.pow_inj hi hj H
    ·
      simp only [exists_prop, true_andₓ, mem_filter, mem_range, mem_univ]
      intro ξ hξ 
      rw [mem_primitive_roots h0, h.is_primitive_root_iff h0] at hξ 
      rcases hξ with ⟨i, hin, hi, H⟩
      exact ⟨i, ⟨hin, hi.symm⟩, H⟩

/-- The sets `primitive_roots k R` are pairwise disjoint. -/
theorem Disjoint {k l : ℕ} (hk : 0 < k) (hl : 0 < l) (h : k ≠ l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=
  by 
    intro z 
    simp only [Finset.inf_eq_inter, Finset.mem_inter, mem_primitive_roots, hk, hl, iff_def]
    rintro ⟨⟨hzk, Hzk⟩, ⟨hzl, Hzl⟩⟩
    applyRules [h, Nat.dvd_antisymm, Hzk, Hzl, hzk, hzl]

/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`
if there is a primitive root of unity in `R`. -/
theorem nth_roots_one_eq_bUnion_primitive_roots' {ζ : R} {n : ℕ+} (h : IsPrimitiveRoot ζ n) :
  nth_roots_finset n R = (Nat.divisors («expr↑ » n)).bUnion fun i => primitiveRoots i R :=
  by 
    symm 
    apply Finset.eq_of_subset_of_card_le
    ·
      intro x 
      simp only [nth_roots_finset, ←Multiset.to_finset_eq (nth_roots_nodup h), exists_prop, Finset.mem_bUnion,
        Finset.mem_filter, Finset.mem_range, mem_nth_roots, Finset.mem_mk, Nat.mem_divisors, and_trueₓ, Ne.def,
        Pnat.ne_zero, Pnat.pos, not_false_iff]
      rintro ⟨a, ⟨d, hd⟩, ha⟩
      have hazero : 0 < a
      ·
        contrapose! hd with ha0 
        simp_all only [nonpos_iff_eq_zero, zero_mul]
        exact n.ne_zero 
      rw [mem_primitive_roots hazero] at ha 
      rw [hd, pow_mulₓ, ha.pow_eq_one, one_pow]
    ·
      apply le_of_eqₓ 
      rw [h.card_nth_roots_finset, Finset.card_bUnion]
      ·
        rw [←Nat.sum_totient n, Nat.filter_dvd_eq_divisors (Pnat.ne_zero n), sum_congr rfl]
        simp only [Finset.mem_filter, Finset.mem_range, Nat.mem_divisors]
        rintro k ⟨H, hk⟩
        have hdvd := H 
        rcases H with ⟨d, hd⟩
        rw [mul_commₓ] at hd 
        rw [(h.pow n.pos hd).card_primitive_roots (Pnat.pos_of_div_pos hdvd)]
      ·
        intro i hi j hj hdiff 
        simp only [Nat.mem_divisors, and_trueₓ, Ne.def, Pnat.ne_zero, not_false_iff] at hi hj 
        exact Disjoint (Pnat.pos_of_div_pos hi) (Pnat.pos_of_div_pos hj) hdiff

/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`
if there is a primitive root of unity in `R`. -/
theorem nth_roots_one_eq_bUnion_primitive_roots {ζ : R} {n : ℕ} (hpos : 0 < n) (h : IsPrimitiveRoot ζ n) :
  nth_roots_finset n R = (Nat.divisors n).bUnion fun i => primitiveRoots i R :=
  @nth_roots_one_eq_bUnion_primitive_roots' _ _ _ _ ⟨n, hpos⟩ h

end IsDomain

section minpoly

open minpoly

variable{n : ℕ}{K : Type _}[Field K]{μ : K}(h : IsPrimitiveRoot μ n)(hpos : 0 < n)

include n μ h hpos

/--`μ` is integral over `ℤ`. -/
theorem IsIntegral : IsIntegral ℤ μ :=
  by 
    use (X^n) - 1
    split 
    ·
      exact monic_X_pow_sub_C 1 (ne_of_ltₓ hpos).symm
    ·
      simp only [((IsPrimitiveRoot.iff_def μ n).mp h).left, eval₂_one, eval₂_X_pow, eval₂_sub, sub_self]

variable[CharZero K]

/--The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/
theorem minpoly_dvd_X_pow_sub_one : minpoly ℤ μ ∣ (X^n) - 1 :=
  by 
    apply
      minpoly.gcd_domain_dvd ℚ (IsIntegral h hpos)
        (Polynomial.Monic.is_primitive (monic_X_pow_sub_C 1 (ne_of_ltₓ hpos).symm))
    simp only [((IsPrimitiveRoot.iff_def μ n).mp h).left, aeval_X_pow, RingHom.eq_int_cast, Int.cast_one, aeval_one,
      AlgHom.map_sub, sub_self]

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:340:40: in by_contra: ././Mathport/Syntax/Translate/Tactic/Basic.lean:41:45: missing argument
/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/
theorem separable_minpoly_mod
{p : exprℕ()}
[fact p.prime]
(hdiv : «expr¬ »(«expr ∣ »(p, n))) : separable (map (int.cast_ring_hom (zmod p)) (minpoly exprℤ() μ)) :=
begin
  have [ident hdvd] [":", expr «expr ∣ »(map (int.cast_ring_hom (zmod p)) (minpoly exprℤ() μ), «expr - »(«expr ^ »(X, n), 1))] [],
  { simpa [] [] [] ["[", expr map_pow, ",", expr map_X, ",", expr map_one, ",", expr map_sub, "]"] [] ["using", expr ring_hom.map_dvd (map_ring_hom (int.cast_ring_hom (zmod p))) (minpoly_dvd_X_pow_sub_one h hpos)] },
  refine [expr separable.of_dvd (separable_X_pow_sub_C 1 _ one_ne_zero) hdvd],
  by_contra [ident hzero],
  exact [expr hdiv ((zmod.nat_coe_zmod_eq_zero_iff_dvd n p).1 hzero)]
end

/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/
theorem squarefree_minpoly_mod {p : ℕ} [Fact p.prime] (hdiv : ¬p ∣ n) :
  Squarefree (map (Int.castRingHom (Zmod p)) (minpoly ℤ μ)) :=
  (separable_minpoly_mod h hpos hdiv).Squarefree

theorem minpoly_dvd_expand {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ n) :
  minpoly ℤ μ ∣ expand ℤ p (minpoly ℤ (μ^p)) :=
  by 
    apply minpoly.gcd_domain_dvd ℚ (h.is_integral hpos)
    ·
      apply monic.is_primitive 
      rw [Polynomial.Monic, leading_coeff, nat_degree_expand, mul_commₓ, coeff_expand_mul' (Nat.Prime.pos hprime),
        ←leading_coeff, ←Polynomial.Monic]
      exact minpoly.monic (IsIntegral (pow_of_prime h hprime hdiv) hpos)
    ·
      rw [aeval_def, coe_expand, ←comp, eval₂_eq_eval_map, map_comp, map_pow, map_X, eval_comp, eval_pow, eval_X,
        ←eval₂_eq_eval_map, ←aeval_def]
      exact minpoly.aeval _ _

theorem minpoly_dvd_pow_mod {p : ℕ} [hprime : Fact p.prime] (hdiv : ¬p ∣ n) :
  map (Int.castRingHom (Zmod p)) (minpoly ℤ μ) ∣ (map (Int.castRingHom (Zmod p)) (minpoly ℤ (μ^p))^p) :=
  by 
    set Q := minpoly ℤ (μ^p)
    have hfrob : (map (Int.castRingHom (Zmod p)) Q^p) = map (Int.castRingHom (Zmod p)) (expand ℤ p Q)
    ·
      rw [←Zmod.expand_card, map_expand hprime.1.Pos]
    rw [hfrob]
    apply RingHom.map_dvd (map_ring_hom (Int.castRingHom (Zmod p)))
    exact minpoly_dvd_expand h hpos hprime.1 hdiv

theorem minpoly_dvd_mod_p {p : ℕ} [hprime : Fact p.prime] (hdiv : ¬p ∣ n) :
  map (Int.castRingHom (Zmod p)) (minpoly ℤ μ) ∣ map (Int.castRingHom (Zmod p)) (minpoly ℤ (μ^p)) :=
  (UniqueFactorizationMonoid.dvd_pow_iff_dvd_of_squarefree (squarefree_minpoly_mod h hpos hdiv) hprime.1.ne_zero).1
    (minpoly_dvd_pow_mod h hpos hdiv)

-- error in RingTheory.RootsOfUnity: ././Mathport/Syntax/Translate/Basic.lean:340:40: in by_contra: ././Mathport/Syntax/Translate/Tactic/Basic.lean:41:45: missing argument
/-- If `p` is a prime that does not divide `n`,
then the minimal polynomials of a primitive `n`-th root of unity `μ`
and of `μ ^ p` are the same. -/
theorem minpoly_eq_pow
{p : exprℕ()}
[hprime : fact p.prime]
(hdiv : «expr¬ »(«expr ∣ »(p, n))) : «expr = »(minpoly exprℤ() μ, minpoly exprℤ() «expr ^ »(μ, p)) :=
begin
  by_contra [ident hdiff],
  set [] [ident P] [] [":="] [expr minpoly exprℤ() μ] [],
  set [] [ident Q] [] [":="] [expr minpoly exprℤ() «expr ^ »(μ, p)] [],
  have [ident Pmonic] [":", expr P.monic] [":=", expr minpoly.monic (h.is_integral hpos)],
  have [ident Qmonic] [":", expr Q.monic] [":=", expr minpoly.monic ((h.pow_of_prime hprime.1 hdiv).is_integral hpos)],
  have [ident Pirr] [":", expr irreducible P] [":=", expr minpoly.irreducible (h.is_integral hpos)],
  have [ident Qirr] [":", expr irreducible Q] [":=", expr minpoly.irreducible ((h.pow_of_prime hprime.1 hdiv).is_integral hpos)],
  have [ident PQprim] [":", expr is_primitive «expr * »(P, Q)] [":=", expr Pmonic.is_primitive.mul Qmonic.is_primitive],
  have [ident prod] [":", expr «expr ∣ »(«expr * »(P, Q), «expr - »(«expr ^ »(X, n), 1))] [],
  { rw ["[", expr is_primitive.int.dvd_iff_map_cast_dvd_map_cast «expr * »(P, Q) «expr - »(«expr ^ »(X, n), 1) PQprim (monic_X_pow_sub_C (1 : exprℤ()) (ne_of_gt hpos)).is_primitive, ",", expr map_mul, "]"] [],
    refine [expr is_coprime.mul_dvd _ _ _],
    { have [ident aux] [] [":=", expr is_primitive.int.irreducible_iff_irreducible_map_cast Pmonic.is_primitive],
      refine [expr (dvd_or_coprime _ _ (aux.1 Pirr)).resolve_left _],
      rw [expr map_dvd_map (int.cast_ring_hom exprℚ()) int.cast_injective Pmonic] [],
      intro [ident hdiv],
      refine [expr hdiff (eq_of_monic_of_associated Pmonic Qmonic _)],
      exact [expr associated_of_dvd_dvd hdiv (Pirr.dvd_symm Qirr hdiv)] },
    { apply [expr (map_dvd_map (int.cast_ring_hom exprℚ()) int.cast_injective Pmonic).2],
      exact [expr minpoly_dvd_X_pow_sub_one h hpos] },
    { apply [expr (map_dvd_map (int.cast_ring_hom exprℚ()) int.cast_injective Qmonic).2],
      exact [expr minpoly_dvd_X_pow_sub_one (pow_of_prime h hprime.1 hdiv) hpos] } },
  replace [ident prod] [] [":=", expr ring_hom.map_dvd (map_ring_hom (int.cast_ring_hom (zmod p))) prod],
  rw ["[", expr coe_map_ring_hom, ",", expr map_mul, ",", expr map_sub, ",", expr map_one, ",", expr map_pow, ",", expr map_X, "]"] ["at", ident prod],
  obtain ["⟨", ident R, ",", ident hR, "⟩", ":=", expr minpoly_dvd_mod_p h hpos hdiv],
  rw ["[", expr hR, ",", "<-", expr mul_assoc, ",", "<-", expr map_mul, ",", "<-", expr sq, ",", expr map_pow, "]"] ["at", ident prod],
  have [ident habs] [":", expr «expr ∣ »(«expr ^ »(map (int.cast_ring_hom (zmod p)) P, 2), «expr * »(«expr ^ »(map (int.cast_ring_hom (zmod p)) P, 2), R))] [],
  { use [expr R] },
  replace [ident habs] [] [":=", expr lt_of_lt_of_le (enat.coe_lt_coe.2 one_lt_two) (multiplicity.le_multiplicity_of_pow_dvd (dvd_trans habs prod))],
  have [ident hfree] [":", expr squarefree («expr - »(«expr ^ »(X, n), 1) : polynomial (zmod p))] [],
  { refine [expr squarefree_X_pow_sub_C 1 _ one_ne_zero],
    by_contra [ident hzero],
    exact [expr hdiv ((zmod.nat_coe_zmod_eq_zero_iff_dvd n p).1 hzero)] },
  cases [expr (multiplicity.squarefree_iff_multiplicity_le_one «expr - »(«expr ^ »(X, n), 1)).1 hfree (map (int.cast_ring_hom (zmod p)) P)] ["with", ident hle, ident hunit],
  { rw [expr nat.cast_one] ["at", ident habs],
    exact [expr hle.not_lt habs] },
  { replace [ident hunit] [] [":=", expr degree_eq_zero_of_is_unit hunit],
    rw [expr degree_map_eq_of_leading_coeff_ne_zero (int.cast_ring_hom (zmod p)) _] ["at", ident hunit],
    { exact [expr (minpoly.degree_pos (is_integral h hpos)).ne' hunit] },
    simp [] [] ["only"] ["[", expr Pmonic, ",", expr ring_hom.eq_int_cast, ",", expr monic.leading_coeff, ",", expr int.cast_one, ",", expr ne.def, ",", expr not_false_iff, ",", expr one_ne_zero, "]"] [] [] }
end

/-- If `m : ℕ` is coprime with `n`,
then the minimal polynomials of a primitive `n`-th root of unity `μ`
and of `μ ^ m` are the same. -/
theorem minpoly_eq_pow_coprime {m : ℕ} (hcop : Nat.Coprime m n) : minpoly ℤ μ = minpoly ℤ (μ^m) :=
  by 
    revert n hcop 
    refine' UniqueFactorizationMonoid.induction_on_prime m _ _ _
    ·
      intro n hn h hpos 
      congr 
      simpa [(Nat.coprime_zero_leftₓ n).mp hn] using h
    ·
      intro u hunit n hcop h hpos 
      congr 
      simp [nat.is_unit_iff.mp hunit]
    ·
      intro a p ha hprime hind n hcop h hpos 
      rw [hind (Nat.Coprime.coprime_mul_left hcop) h hpos]
      clear hind 
      replace hprime := Nat.prime_iff.2 hprime 
      have hdiv := (Nat.Prime.coprime_iff_not_dvd hprime).1 (Nat.Coprime.coprime_mul_right hcop)
      haveI  := Fact.mk hprime 
      rw [minpoly_eq_pow (h.pow_of_coprime a (Nat.Coprime.coprime_mul_left hcop)) hpos hdiv]
      congr 1
      ringExp

/-- If `m : ℕ` is coprime with `n`,
then the minimal polynomial of a primitive `n`-th root of unity `μ`
has `μ ^ m` as root. -/
theorem pow_is_root_minpoly {m : ℕ} (hcop : Nat.Coprime m n) : is_root (map (Int.castRingHom K) (minpoly ℤ μ)) (μ^m) :=
  by 
    simpa [minpoly_eq_pow_coprime h hpos hcop, eval_map, aeval_def (μ^m) _] using minpoly.aeval ℤ (μ^m)

/-- `primitive_roots n K` is a subset of the roots of the minimal polynomial of a primitive
`n`-th root of unity `μ`. -/
theorem is_roots_of_minpoly : primitiveRoots n K ⊆ (map (Int.castRingHom K) (minpoly ℤ μ)).roots.toFinset :=
  by 
    intro x hx 
    obtain ⟨m, hle, hcop, rfl⟩ := (is_primitive_root_iff h hpos).1 ((mem_primitive_roots hpos).1 hx)
    simpa [Multiset.mem_to_finset, mem_roots (map_monic_ne_zero$ minpoly.monic$ IsIntegral h hpos)] using
      pow_is_root_minpoly h hpos hcop

/-- The degree of the minimal polynomial of `μ` is at least `totient n`. -/
theorem totient_le_degree_minpoly : Nat.totient n ≤ (minpoly ℤ μ).natDegree :=
  let P : Polynomial ℤ := minpoly ℤ μ 
  let P_K : Polynomial K := map (Int.castRingHom K) P 
  calc n.totient = (primitiveRoots n K).card := (h.card_primitive_roots hpos).symm 
    _ ≤ P_K.roots.to_finset.card := Finset.card_le_of_subset (is_roots_of_minpoly h hpos)
    _ ≤ P_K.roots.card := Multiset.to_finset_card_le _ 
    _ ≤ P_K.nat_degree := card_roots'$ map_monic_ne_zero (minpoly.monic$ IsIntegral h hpos)
    _ ≤ P.nat_degree := nat_degree_map_le _ _
    

end minpoly

end IsPrimitiveRoot

