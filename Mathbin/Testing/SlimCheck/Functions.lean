import Mathbin.Data.List.Sigma 
import Mathbin.Testing.SlimCheck.Sampleable 
import Mathbin.Testing.SlimCheck.Testable 
import Mathbin.Tactic.PrettyCases

/-!
## `slim_check`: generators for functions

This file defines `sampleable` instances for `α → β` functions and
`ℤ → ℤ` injective functions.

Functions are generated by creating a list of pairs and one more value
using the list as a lookup table and resorting to the additional value
when a value is not found in the table.

Injective functions are generated by creating a list of numbers and
a permutation of that list. The permutation insures that every input
is mapped to a unique output. When an input is not found in the list
the input itself is used as an output.

Injective functions `f : α → α` could be generated easily instead of
`ℤ → ℤ` by generating a `list α`, removing duplicates and creating a
permutations. One has to be careful when generating the domain to make
if vast enough that, when generating arguments to apply `f` to,
they argument should be likely to lie in the domain of `f`. This is
the reason that injective functions `f : ℤ → ℤ` are generated by
fixing the domain to the range `[-2*size .. -2*size]`, with `size`
the size parameter of the `gen` monad.

Much of the machinery provided in this file is applicable to generate
injective functions of type `α → α` and new instances should be easy
to define.

Other classes of functions such as monotone functions can generated using
similar techniques. For monotone functions, generating two lists, sorting them
and matching them should suffice, with appropriate default values.
Some care must be taken for shrinking such functions to make sure
their defining property is invariant through shrinking. Injective
functions are an example of how complicated it can get.
-/


universe u v w

variable{α : Type u}{β : Type v}{γ : Sort w}

namespace SlimCheck

/-- Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`with_default f y` encodes `x ↦ f x` when `x ∈ f` and `x ↦ y`
otherwise.

We use `Σ` to encode mappings instead of `×` because we
rely on the association list API defined in `data.list.sigma`.
 -/
inductive total_function (α : Type u) (β : Type v) : Type max u v
  | with_default : List (Σ_ : α, β) → β → total_function

instance total_function.inhabited [Inhabited β] : Inhabited (total_function α β) :=
  ⟨total_function.with_default ∅ (default _)⟩

namespace TotalFunction

/-- Apply a total function to an argument. -/
def apply [DecidableEq α] : total_function α β → α → β
| total_function.with_default m y, x => (m.lookup x).getOrElse y

/--
Implementation of `has_repr (total_function α β)`.

Creates a string for a given `finmap` and output, `x₀ ↦ y₀, .. xₙ ↦ yₙ`
for each of the entries. The brackets are provided by the calling function.
-/
def repr_aux [HasRepr α] [HasRepr β] (m : List (Σ_ : α, β)) : Stringₓ :=
  Stringₓ.join$ List.qsort (fun x y => x < y) (m.map$ fun x => s!"{(reprₓ$ Sigma.fst x)} ↦ {reprₓ$ Sigma.snd x}, ")

/--
Produce a string for a given `total_function`.
The output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, _ ↦ y]`.
-/
protected def reprₓ [HasRepr α] [HasRepr β] : total_function α β → Stringₓ
| total_function.with_default m y => s!"[{(repr_aux m)}_ ↦ {HasRepr.repr y}]"

instance  (α : Type u) (β : Type v) [HasRepr α] [HasRepr β] : HasRepr (total_function α β) :=
  ⟨total_function.repr⟩

/-- Create a `finmap` from a list of pairs. -/
def list.to_finmap' (xs : List (α × β)) : List (Σ_ : α, β) :=
  xs.map Prod.toSigma

section 

variable[sampleable α][sampleable β]

/-- Redefine `sizeof` to follow the structure of `sampleable` instances. -/
def total.sizeof : total_function α β → ℕ
| ⟨m, x⟩ => (1+@sizeof _ sampleable.wf m)+sizeof x

instance (priority := 2000) : SizeOf (total_function α β) :=
  ⟨total.sizeof⟩

variable[DecidableEq α]

/-- Shrink a total function by shrinking the lists that represent it. -/
protected def shrink : shrink_fn (total_function α β)
| ⟨m, x⟩ =>
  (sampleable.shrink (m, x)).map$
    fun ⟨⟨m', x'⟩, h⟩ =>
      ⟨⟨List.eraseDupkeys m', x'⟩,
        lt_of_le_of_ltₓ
          (by 
            unfoldWf <;> refine' @List.sizeof_erase_dupkeys _ _ _ (@sampleable.wf _ _) _)
          h⟩

variable[HasRepr α][HasRepr β]

instance pi.sampleable_ext : sampleable_ext (α → β) :=
  { ProxyRepr := total_function α β, interp := total_function.apply,
    sample :=
      do 
        let xs ← (sampleable.sample (List (α × β)) : gen (List (α × β)))
        let ⟨x⟩ ← (Uliftable.up$ sample β : gen (Ulift.{max u v} β))
        pure$ total_function.with_default (list.to_finmap' xs) x,
    shrink := total_function.shrink }

end 

section SampleableExt

open SampleableExt

instance (priority := 2000)pi_pred.sampleable_ext [sampleable_ext (α → Bool)] : sampleable_ext.{u + 1} (α → Prop) :=
  { ProxyRepr := proxy_repr (α → Bool), interp := fun m x => interp (α → Bool) m x, sample := sample (α → Bool),
    shrink := shrink }

instance (priority := 2000)pi_uncurry.sampleable_ext [sampleable_ext (α × β → γ)] :
  sampleable_ext.{imax (u + 1) (v + 1) w} (α → β → γ) :=
  { ProxyRepr := proxy_repr (α × β → γ), interp := fun m x y => interp (α × β → γ) m (x, y),
    sample := sample (α × β → γ), shrink := shrink }

end SampleableExt

end TotalFunction

/--
Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`map_to_self f` encodes `x ↦ f x` when `x ∈ f` and `x ↦ x`,
i.e. `x` to itself, otherwise.

We use `Σ` to encode mappings instead of `×` because we
rely on the association list API defined in `data.list.sigma`.
-/
inductive injective_function (α : Type u) : Type u
  | map_to_self (xs : List (Σ_ : α, α)) :
  xs.map Sigma.fst ~ xs.map Sigma.snd → List.Nodup (xs.map Sigma.snd) → injective_function

instance  : Inhabited (injective_function α) :=
  ⟨⟨[], List.Perm.nil, List.nodup_nil⟩⟩

namespace InjectiveFunction

/-- Apply a total function to an argument. -/
def apply [DecidableEq α] : injective_function α → α → α
| injective_function.map_to_self m _ _, x => (m.lookup x).getOrElse x

/--
Produce a string for a given `total_function`.
The output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, x ↦ x]`.
Unlike for `total_function`, the default value is not a constant
but the identity function.
-/
protected def reprₓ [HasRepr α] : injective_function α → Stringₓ
| injective_function.map_to_self m _ _ => s! "[{total_function.repr_aux m}x ↦ x]"

instance  (α : Type u) [HasRepr α] : HasRepr (injective_function α) :=
  ⟨injective_function.repr⟩

/-- Interpret a list of pairs as a total function, defaulting to
the identity function when no entries are found for a given function -/
def list.apply_id [DecidableEq α] (xs : List (α × α)) (x : α) : α :=
  ((xs.map Prod.toSigma).lookup x).getOrElse x

@[simp]
theorem list.apply_id_cons [DecidableEq α] (xs : List (α × α)) (x y z : α) :
  list.apply_id ((y, z) :: xs) x = if y = x then z else list.apply_id xs x :=
  by 
    simp only [list.apply_id, List.lookupₓ, eq_rec_constant, Prod.toSigma, List.map] <;> splitIfs <;> rfl

open Function _Root_.List

open _root_.prod(toSigma)

open _Root_.Nat

-- error in Testing.SlimCheck.Functions: ././Mathport/Syntax/Translate/Basic.lean:176:17: failed to parenthesize: no declaration of attribute [parenthesizer] found for 'Lean.Meta.solveByElim'
theorem list.apply_id_zip_eq
[decidable_eq α]
{xs ys : list α}
(h₀ : list.nodup xs)
(h₁ : «expr = »(xs.length, ys.length))
(x y : α)
(i : exprℕ())
(h₂ : «expr = »(xs.nth i, some x)) : «expr ↔ »(«expr = »(list.apply_id.{u} (xs.zip ys) x, y), «expr = »(ys.nth i, some y)) :=
begin
  induction [expr xs] [] [] ["generalizing", ident ys, ident i],
  case [ident list.nil, ":", ident ys, ident i, ident h₁, ident h₂] { cases [expr h₂] [] },
  case [ident list.cons, ":", ident x', ident xs, ident xs_ih, ident ys, ident i, ident h₁, ident h₂] { cases [expr i] [],
    { injection [expr h₂] ["with", ident h₀, ident h₁],
      subst [expr h₀],
      cases [expr ys] [],
      { cases [expr h₁] [] },
      { simp [] [] ["only"] ["[", expr list.apply_id, ",", expr to_sigma, ",", expr option.get_or_else_some, ",", expr nth, ",", expr lookup_cons_eq, ",", expr zip_cons_cons, ",", expr list.map, "]"] [] [] } },
    { cases [expr ys] [],
      { cases [expr h₁] [] },
      { cases [expr h₀] ["with", "_", "_", ident h₀, ident h₁],
        simp [] [] ["only"] ["[", expr nth, ",", expr zip_cons_cons, ",", expr list.apply_id_cons, "]"] [] ["at", ident h₂, "⊢"],
        rw [expr if_neg] [],
        { apply [expr xs_ih]; solve_by_elim [] [] ["[", expr succ.inj, "]"] [] },
        { apply [expr h₀],
          apply [expr nth_mem h₂] } } } }
end

theorem apply_id_mem_iff [DecidableEq α] {xs ys : List α} (h₀ : List.Nodup xs) (h₁ : xs ~ ys) (x : α) :
  list.apply_id.{u} (xs.zip ys) x ∈ ys ↔ x ∈ xs :=
  by 
    simp only [list.apply_id]
    cases h₃ : lookup x (map Prod.toSigma (xs.zip ys))
    ·
      dsimp [Option.getOrElse]
      rw [h₁.mem_iff]
    ·
      have h₂ : ys.nodup := h₁.nodup_iff.1 h₀ 
      replace h₁ : xs.length = ys.length := h₁.length_eq 
      dsimp 
      induction xs generalizing ys 
      case list.nil ys h₃ h₂ h₁ => 
        contradiction 
      case list.cons x' xs xs_ih ys h₃ h₂ h₁ => 
        cases' ys with y ys
        ·
          cases h₃ 
        dsimp [lookup]  at h₃ 
        splitIfs  at h₃
        ·
          subst x' 
          subst val 
          simp only [mem_cons_iff, true_orₓ, eq_self_iff_true]
        ·
          cases' h₀ with _ _ h₀ h₅ 
          cases' h₂ with _ _ h₂ h₄ 
          have h₆ := Nat.succ.injₓ h₁ 
          specialize xs_ih h₅ ys h₃ h₄ h₆ 
          simp only [Ne.symm h, xs_ih, mem_cons_iff, false_orₓ]
          suffices  : val ∈ ys 
          tauto! 
          erw [←Option.mem_def, mem_lookup_iff] at h₃ 
          simp only [to_sigma, mem_map, heq_iff_eq, Prod.exists] at h₃ 
          rcases h₃ with ⟨a, b, h₃, h₄, h₅⟩
          subst a 
          subst b 
          apply (mem_zip h₃).2
          simp only [nodupkeys, keys, comp, Prod.fst_to_sigma, map_map]
          rwa [map_fst_zip _ _ (le_of_eqₓ h₆)]

theorem list.apply_id_eq_self [DecidableEq α] {xs ys : List α} (x : α) : x ∉ xs → list.apply_id.{u} (xs.zip ys) x = x :=
  by 
    intro h 
    dsimp [list.apply_id]
    rw [lookup_eq_none.2]
    rfl 
    simp only [keys, not_exists, to_sigma, exists_and_distrib_right, exists_eq_right, mem_map, comp_app, map_map,
      Prod.exists]
    intro y hy 
    exact h (mem_zip hy).1

theorem apply_id_injective [DecidableEq α] {xs ys : List α} (h₀ : List.Nodup xs) (h₁ : xs ~ ys) :
  injective.{u + 1, u + 1} (list.apply_id (xs.zip ys)) :=
  by 
    intro x y h 
    byCases' hx : x ∈ xs <;> byCases' hy : y ∈ xs
    ·
      rw [mem_iff_nth] at hx hy 
      cases' hx with i hx 
      cases' hy with j hy 
      suffices  : some x = some y
      ·
        injection this 
      have h₂ := h₁.length_eq 
      rw [list.apply_id_zip_eq h₀ h₂ _ _ _ hx] at h 
      rw [←hx, ←hy]
      congr 
      apply nth_injective _ (h₁.nodup_iff.1 h₀)
      ·
        symm 
        rw [h]
        rw [←list.apply_id_zip_eq] <;> assumption
      ·
        rw [←h₁.length_eq]
        rw [nth_eq_some] at hx 
        cases' hx with hx hx' 
        exact hx
    ·
      rw [←apply_id_mem_iff h₀ h₁] at hx hy 
      rw [h] at hx 
      contradiction
    ·
      rw [←apply_id_mem_iff h₀ h₁] at hx hy 
      rw [h] at hx 
      contradiction
    ·
      rwa [list.apply_id_eq_self, list.apply_id_eq_self] at h <;> assumption

open total_function(list.to_finmap')

open Sampleable

/--
Remove a slice of length `m` at index `n` in a list and a permutation, maintaining the property
that it is a permutation.
-/
def perm.slice [DecidableEq α] (n m : ℕ) : (Σ'xs ys : List α, xs ~ ys ∧ ys.nodup) → Σ'xs ys : List α, xs ~ ys ∧ ys.nodup
| ⟨xs, ys, h, h'⟩ =>
  let xs' := List.slice n m xs 
  have h₀ : xs' ~ ys.inter xs' := perm.slice_inter _ _ h h'
  ⟨xs', ys.inter xs', h₀, nodup_inter_of_nodup _ h'⟩

/--
A lazy list, in decreasing order, of sizes that should be
sliced off a list of length `n`
-/
def slice_sizes : ℕ → LazyList ℕ+
| n =>
  if h : 0 < n then
    have  : n / 2 < n :=
      div_lt_self h
        (by 
          decide)
    LazyList.cons ⟨_, h⟩ (slice_sizes$ n / 2)
  else LazyList.nil

/--
Shrink a permutation of a list, slicing a segment in the middle.

The sizes of the slice being removed start at `n` (with `n` the length
of the list) and then `n / 2`, then `n / 4`, etc down to 1. The slices
will be taken at index `0`, `n / k`, `2n / k`, `3n / k`, etc.
-/
protected def shrink_perm {α : Type} [DecidableEq α] [SizeOf α] : shrink_fn (Σ'xs ys : List α, xs ~ ys ∧ ys.nodup)
| xs =>
  do 
    let k := xs.1.length 
    let n ← slice_sizes k 
    let i ← LazyList.ofList$ List.finRange$ k / n 
    have  : («expr↑ » i*«expr↑ » n) < xs.1.length :=
        Nat.lt_of_div_lt_div
          (lt_of_le_of_ltₓ
            (by 
              simp only [Nat.mul_div_cancelₓ, gt_iff_lt, Finₓ.val_eq_coe, Pnat.pos])
            i.2)
      pure
        ⟨perm.slice (i*n) n xs,
          by 
            rcases xs with ⟨a, b, c, d⟩ <;>
              dsimp [sizeof_lt] <;>
                unfoldWf <;> simp only [perm.slice] <;> unfoldWf <;> apply List.sizeof_slice_lt _ _ n.2 _ this⟩

instance  [SizeOf α] : SizeOf (injective_function α) :=
  ⟨fun ⟨xs, _, _⟩ => sizeof (xs.map Sigma.fst)⟩

/--
Shrink an injective function slicing a segment in the middle of the domain and removing
the corresponding elements in the codomain, hence maintaining the property that
one is a permutation of the other.
-/
protected def shrink {α : Type} [SizeOf α] [DecidableEq α] : shrink_fn (injective_function α)
| ⟨xs, h₀, h₁⟩ =>
  do 
    let ⟨⟨xs', ys', h₀, h₁⟩, h₂⟩ ← injective_function.shrink_perm ⟨_, _, h₀, h₁⟩
    have h₃ : xs'.length ≤ ys'.length := le_of_eqₓ (perm.length_eq h₀)
      have h₄ : ys'.length ≤ xs'.length := le_of_eqₓ (perm.length_eq h₀.symm)
      pure
        ⟨⟨(List.zipₓ xs' ys').map Prod.toSigma,
            by 
              simp only [comp, map_fst_zip, map_snd_zip, Prod.fst_to_sigma, Prod.snd_to_sigma, map_map],
            by 
              simp only [comp, map_snd_zip, Prod.snd_to_sigma, map_map]⟩,
          by 
            revert h₂ <;>
              dsimp [sizeof_lt] <;>
                unfoldWf <;>
                  simp only [has_sizeof._match_1, map_map, comp, map_fst_zip, Prod.fst_to_sigma] <;>
                    unfoldWf <;> intro h₂ <;> convert h₂⟩

/-- Create an injective function from one list and a permutation of that list. -/
protected def mk (xs ys : List α) (h : xs ~ ys) (h' : ys.nodup) : injective_function α :=
  have h₀ : xs.length ≤ ys.length := le_of_eqₓ h.length_eq 
  have h₁ : ys.length ≤ xs.length := le_of_eqₓ h.length_eq.symm 
  injective_function.map_to_self (list.to_finmap' (xs.zip ys))
    (by 
      simp only [list.to_finmap', comp, map_fst_zip, map_snd_zip, Prod.fst_to_sigma, Prod.snd_to_sigma, map_map])
    (by 
      simp only [list.to_finmap', comp, map_snd_zip, Prod.snd_to_sigma, map_map])

protected theorem injective [DecidableEq α] (f : injective_function α) : injective (apply f) :=
  by 
    cases' f with xs hperm hnodup 
    generalize h₀ : map Sigma.fst xs = xs₀ 
    generalize h₁ : xs.map (@id ((Σ_ : α, α) → α)$ @Sigma.snd α fun _ : α => α) = xs₁ 
    dsimp [id]  at h₁ 
    have hxs : xs = total_function.list.to_finmap' (xs₀.zip xs₁)
    ·
      rw [←h₀, ←h₁, list.to_finmap']
      clear h₀ h₁ xs₀ xs₁ hperm hnodup 
      induction xs 
      case list.nil => 
        simp only [zip_nil_right, map_nil]
      case list.cons xs_hd xs_tl xs_ih => 
        simp only [true_andₓ, to_sigma, eq_self_iff_true, Sigma.eta, zip_cons_cons, List.map]
        exact xs_ih 
    revert hperm hnodup 
    rw [hxs]
    intros 
    apply apply_id_injective
    ·
      rwa [←h₀, hxs, hperm.nodup_iff]
    ·
      rwa [←hxs, h₀, h₁] at hperm

instance pi_injective.sampleable_ext : sampleable_ext { f : ℤ → ℤ // Function.Injective f } :=
  { ProxyRepr := injective_function ℤ, interp := fun f => ⟨apply f, f.injective⟩,
    sample :=
      gen.sized$
        fun sz =>
          do 
            let xs' := Int.range (-(2*sz)+2) ((2*sz)+2)
            let ys ← gen.permutation_of xs' 
            have Hinj : injective fun r : ℕ => (-((2*sz)+2 : ℤ))+«expr↑ » r :=
                fun x y h => Int.coe_nat_inj (add_right_injective _ h)
              let r : injective_function ℤ :=
                injective_function.mk.{0} xs' ys.1 ys.2 (ys.2.nodup_iff.1$ nodup_map Hinj (nodup_range _))
              pure r,
    shrink := @injective_function.shrink ℤ _ _ }

end InjectiveFunction

open Function

instance injective.testable (f : α → β)
  [I : testable (named_binder "x"$ ∀ x : α, named_binder "y"$ ∀ y : α, named_binder "H"$ f x = f y → x = y)] :
  testable (injective f) :=
  I

instance monotone.testable [Preorderₓ α] [Preorderₓ β] (f : α → β)
  [I : testable (named_binder "x"$ ∀ x : α, named_binder "y"$ ∀ y : α, named_binder "H"$ x ≤ y → f x ≤ f y)] :
  testable (Monotone f) :=
  I

instance antitone.testable [Preorderₓ α] [Preorderₓ β] (f : α → β)
  [I : testable (named_binder "x"$ ∀ x : α, named_binder "y"$ ∀ y : α, named_binder "H"$ x ≤ y → f y ≤ f x)] :
  testable (Antitone f) :=
  I

end SlimCheck

