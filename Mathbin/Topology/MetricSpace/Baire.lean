import Mathbin.Analysis.SpecificLimits 
import Mathbin.Order.Filter.CountableInter 
import Mathbin.Topology.GDelta

/-!
# Baire theorem

In a complete metric space, a countable intersection of dense open subsets is dense.

The good concept underlying the theorem is that of a GŒ¥ set, i.e., a countable intersection
of open sets. Then Baire theorem can also be formulated as the fact that a countable
intersection of dense GŒ¥ sets is a dense GŒ¥ set. We prove Baire theorem, giving several different
formulations that can be handy. We also prove the important consequence that, if the space is
covered by a countable union of closed sets, then the union of their interiors is dense.

The names of the theorems do not contain the string "Baire", but are instead built from the form of
the statement. "Baire" is however in the docstring of all the theorems, to facilitate grep searches.

We also define the filter `residual Œ±` generated by dense `GŒ¥` sets and prove that this filter
has the countable intersection property.
-/


noncomputable theory

open_locale Classical TopologicalSpace Filter Ennreal

open Filter Encodable Set

variable{Œ± : Type _}{Œ≤ : Type _}{Œ≥ : Type _}{Œπ : Type _}

section BaireTheorem

open Emetric Ennreal

variable[EmetricSpace Œ±][CompleteSpace Œ±]

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here when
the source space is ‚Ñï (and subsumed below by `dense_Inter_of_open` working with any
encodable source space). -/
theorem dense_Inter_of_open_nat {f : ‚Ñï ‚Üí Set Œ±} (ho : ‚àÄ n, IsOpen (f n)) (hd : ‚àÄ n, Dense (f n)) : Dense (‚ãÇn, f n) :=
  by 
    let B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := fun n => 1 / 2 ^ n 
    have Bpos : ‚àÄ n, 0 < B n
    ¬∑
      intro n 
      simp only [B, one_div, one_mul‚Çì, Ennreal.inv_pos]
      exact pow_ne_top two_ne_top 
    have  : ‚àÄ n x Œ¥, Œ¥ ‚â† 0 ‚Üí ‚àÉ y r, 0 < r ‚àß r ‚â§ B (n+1) ‚àß closed_ball y r ‚äÜ closed_ball x Œ¥ ‚à© f n
    ¬∑
      intro n x Œ¥ Œ¥pos 
      have  : x ‚àà Closure (f n) := hd n x 
      rcases Emetric.mem_closure_iff.1 this (Œ¥ / 2) (Ennreal.half_pos Œ¥pos) with ‚ü®y, ys, xy‚ü©
      rw [edist_comm] at xy 
      obtain ‚ü®r, rpos, hr‚ü© : ‚àÉ (r : _)(_ : r > 0), closed_ball y r ‚äÜ f n :=
        nhds_basis_closed_eball.mem_iff.1 (is_open_iff_mem_nhds.1 (ho n) y ys)
      refine' ‚ü®y, min (min (Œ¥ / 2) r) (B (n+1)), _, _, fun z hz => ‚ü®_, _‚ü©‚ü©
      show 0 < min (min (Œ¥ / 2) r) (B (n+1))
      exact lt_min‚Çì (lt_min‚Çì (Ennreal.half_pos Œ¥pos) rpos) (Bpos (n+1))
      show min (min (Œ¥ / 2) r) (B (n+1)) ‚â§ B (n+1)
      exact min_le_right‚Çì _ _ 
      show z ‚àà closed_ball x Œ¥ 
      exact
        calc edist z x ‚â§ edist z y+edist y x := edist_triangle _ _ _ 
          _ ‚â§ min (min (Œ¥ / 2) r) (B (n+1))+Œ¥ / 2 := add_le_add hz (le_of_lt‚Çì xy)
          _ ‚â§ (Œ¥ / 2)+Œ¥ / 2 := add_le_add (le_trans‚Çì (min_le_left‚Çì _ _) (min_le_left‚Çì _ _)) (le_refl‚Çì _)
          _ = Œ¥ := Ennreal.add_halves Œ¥ 
          
      show z ‚àà f n 
      exact
        hr
          (calc edist z y ‚â§ min (min (Œ¥ / 2) r) (B (n+1)) := hz 
            _ ‚â§ r := le_trans‚Çì (min_le_left‚Çì _ _) (min_le_right‚Çì _ _)
            )
    choose! center radius Hpos HB Hball using this 
    refine' fun x => (mem_closure_iff_nhds_basis nhds_basis_closed_eball).2 fun Œµ Œµpos => _ 
    let F : ‚Ñï ‚Üí Œ± √ó ‚Ñù‚â•0‚àû :=
      fun n => Nat.recOn n (Prod.mk x (min Œµ (B 0))) fun n p => Prod.mk (center n p.1 p.2) (radius n p.1 p.2)
    let c : ‚Ñï ‚Üí Œ± := fun n => (F n).1
    let r : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := fun n => (F n).2
    have rpos : ‚àÄ n, 0 < r n
    ¬∑
      intro n 
      induction' n with n hn 
      exact lt_min‚Çì Œµpos (Bpos 0)
      exact Hpos n (c n) (r n) hn.ne' 
    have r0 : ‚àÄ n, r n ‚â† 0 := fun n => (rpos n).ne' 
    have rB : ‚àÄ n, r n ‚â§ B n
    ¬∑
      intro n 
      induction' n with n hn 
      exact min_le_right‚Çì _ _ 
      exact HB n (c n) (r n) (r0 n)
    have incl : ‚àÄ n, closed_ball (c (n+1)) (r (n+1)) ‚äÜ closed_ball (c n) (r n) ‚à© f n :=
      fun n => Hball n (c n) (r n) (r0 n)
    have cdist : ‚àÄ n, edist (c n) (c (n+1)) ‚â§ B n
    ¬∑
      intro n 
      rw [edist_comm]
      have A : c (n+1) ‚àà closed_ball (c (n+1)) (r (n+1)) := mem_closed_ball_self 
      have I :=
        calc closed_ball (c (n+1)) (r (n+1)) ‚äÜ closed_ball (c n) (r n) := subset.trans (incl n) (inter_subset_left _ _)
          _ ‚äÜ closed_ball (c n) (B n) := closed_ball_subset_closed_ball (rB n)
          
      exact I A 
    have  : CauchySeq c := cauchy_seq_of_edist_le_geometric_two _ one_ne_top cdist 
    rcases cauchy_seq_tendsto_of_complete this with ‚ü®y, ylim‚ü©
    use y 
    simp only [exists_prop, Set.mem_Inter]
    have I : ‚àÄ n, ‚àÄ m _ : m ‚â• n, closed_ball (c m) (r m) ‚äÜ closed_ball (c n) (r n)
    ¬∑
      intro n 
      refine' Nat.le_induction _ fun m hnm h => _
      ¬∑
        exact subset.refl _
      ¬∑
        exact subset.trans (incl m) (subset.trans (inter_subset_left _ _) h)
    have yball : ‚àÄ n, y ‚àà closed_ball (c n) (r n)
    ¬∑
      intro n 
      refine' is_closed_ball.mem_of_tendsto ylim _ 
      refine' (Filter.eventually_ge_at_top n).mono fun m hm => _ 
      exact I n m hm mem_closed_ball_self 
    split 
    show ‚àÄ n, y ‚àà f n
    ¬∑
      intro n 
      have  : closed_ball (c (n+1)) (r (n+1)) ‚äÜ f n := subset.trans (incl n) (inter_subset_right _ _)
      exact this (yball (n+1))
    show edist y x ‚â§ Œµ 
    exact le_trans‚Çì (yball 0) (min_le_left‚Çì _ _)

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ‚ãÇ‚ÇÄ. -/
theorem dense_sInter_of_open {S : Set (Set Œ±)} (ho : ‚àÄ s _ : s ‚àà S, IsOpen s) (hS : countable S)
  (hd : ‚àÄ s _ : s ‚àà S, Dense s) : Dense (‚ãÇ‚ÇÄS) :=
  by 
    cases' S.eq_empty_or_nonempty with h h
    ¬∑
      simp [h]
    ¬∑
      rcases hS.exists_surjective h with ‚ü®f, hf‚ü©
      have F : ‚àÄ n, f n ‚àà S :=
        fun n =>
          by 
            rw [hf] <;> exact mem_range_self _ 
      rw [hf, sInter_range]
      exact dense_Inter_of_open_nat (fun n => ho _ (F n)) fun n => hd _ (F n)

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_open {S : Set Œ≤} {f : Œ≤ ‚Üí Set Œ±} (ho : ‚àÄ s _ : s ‚àà S, IsOpen (f s)) (hS : countable S)
  (hd : ‚àÄ s _ : s ‚àà S, Dense (f s)) : Dense (‚ãÇ(s : _)(_ : s ‚àà S), f s) :=
  by 
    rw [‚ÜêsInter_image]
    apply dense_sInter_of_open
    ¬∑
      rwa [ball_image_iff]
    ¬∑
      exact hS.image _
    ¬∑
      rwa [ball_image_iff]

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_open [Encodable Œ≤] {f : Œ≤ ‚Üí Set Œ±} (ho : ‚àÄ s, IsOpen (f s)) (hd : ‚àÄ s, Dense (f s)) :
  Dense (‚ãÇs, f s) :=
  by 
    rw [‚ÜêsInter_range]
    apply dense_sInter_of_open
    ¬∑
      rwa [forall_range_iff]
    ¬∑
      exact countable_range _
    ¬∑
      rwa [forall_range_iff]

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with ‚ãÇ‚ÇÄ. -/
theorem dense_sInter_of_GŒ¥ {S : Set (Set Œ±)} (ho : ‚àÄ s _ : s ‚àà S, IsGŒ¥ s) (hS : countable S)
  (hd : ‚àÄ s _ : s ‚àà S, Dense s) : Dense (‚ãÇ‚ÇÄS) :=
  by 
    choose T hT using ho 
    have  : ‚ãÇ‚ÇÄS = ‚ãÇ‚ÇÄ‚ãÉ(s : _)(_ : s ‚àà S), T s ‚Äπ_‚Ä∫ := (sInter_bUnion fun s hs => (hT s hs).2.2).symm 
    rw [this]
    refine' dense_sInter_of_open _ (hS.bUnion fun s hs => (hT s hs).2.1) _ <;>
      simp only [Set.mem_Union, exists_prop] <;> rintro t ‚ü®s, hs, tTs‚ü©
    show IsOpen t
    ¬∑
      exact (hT s hs).1 t tTs 
    show Dense t
    ¬∑
      intro x 
      have  := hd s hs x 
      rw [(hT s hs).2.2] at this 
      exact closure_mono (sInter_subset_of_mem tTs) this

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_GŒ¥ [Encodable Œ≤] {f : Œ≤ ‚Üí Set Œ±} (ho : ‚àÄ s, IsGŒ¥ (f s)) (hd : ‚àÄ s, Dense (f s)) :
  Dense (‚ãÇs, f s) :=
  by 
    rw [‚ÜêsInter_range]
    exact dense_sInter_of_GŒ¥ (forall_range_iff.2 ‚Äπ_‚Ä∫) (countable_range _) (forall_range_iff.2 ‚Äπ_‚Ä∫)

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_GŒ¥ {S : Set Œ≤} {f : ‚àÄ x _ : x ‚àà S, Set Œ±} (ho : ‚àÄ s _ : s ‚àà S, IsGŒ¥ (f s ‚Äπ_‚Ä∫))
  (hS : countable S) (hd : ‚àÄ s _ : s ‚àà S, Dense (f s ‚Äπ_‚Ä∫)) : Dense (‚ãÇ(s : _)(_ : s ‚àà S), f s ‚Äπ_‚Ä∫) :=
  by 
    rw [bInter_eq_Inter]
    haveI  := hS.to_encodable 
    exact dense_Inter_of_GŒ¥ (fun s => ho s s.2) fun s => hd s s.2

/-- Baire theorem: the intersection of two dense GŒ¥ sets is dense. -/
theorem Dense.inter_of_GŒ¥ {s t : Set Œ±} (hs : IsGŒ¥ s) (ht : IsGŒ¥ t) (hsc : Dense s) (htc : Dense t) : Dense (s ‚à© t) :=
  by 
    rw [inter_eq_Inter]
    apply dense_Inter_of_GŒ¥ <;> simp [Bool.forall_bool]

/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `GŒ¥` set. -/
theorem eventually_residual {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂†x in residual Œ±, p x) ‚Üî ‚àÉ t : Set Œ±, IsGŒ¥ t ‚àß Dense t ‚àß ‚àÄ x _ : x ‚àà t, p x :=
  calc (‚àÄ·∂†x in residual Œ±, p x) ‚Üî ‚àÄ·∂†x in ‚®Ö(t : Set Œ±)(ht : IsGŒ¥ t ‚àß Dense t), ùìü t, p x :=
    by 
      simp only [residual, infi_and]
    _ ‚Üî ‚àÉ (t : Set Œ±)(ht : IsGŒ¥ t ‚àß Dense t), ‚àÄ·∂†x in ùìü t, p x :=
    mem_binfi_of_directed
      (fun t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ =>
        ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, ‚ü®h‚ÇÅ.1.inter h‚ÇÇ.1, Dense.inter_of_GŒ¥ h‚ÇÅ.1 h‚ÇÇ.1 h‚ÇÅ.2 h‚ÇÇ.2‚ü©,
          by 
            simp ‚ü©)
      ‚ü®univ, is_GŒ¥_univ, dense_univ‚ü©
    _ ‚Üî _ :=
    by 
      simp [and_assoc]
    

/-- A set is residual (comeagre) if and only if it includes a dense `GŒ¥` set. -/
theorem mem_residual {s : Set Œ±} : s ‚àà residual Œ± ‚Üî ‚àÉ (t : _)(_ : t ‚äÜ s), IsGŒ¥ t ‚àß Dense t :=
  (@eventually_residual Œ± _ _ fun x => x ‚àà s).trans$
    exists_congr$
      fun t =>
        by 
          rw [exists_prop, and_comm (t ‚äÜ s), subset_def, and_assoc]

theorem dense_of_mem_residual {s : Set Œ±} (hs : s ‚àà residual Œ±) : Dense s :=
  let ‚ü®t, hts, _, hd‚ü© := mem_residual.1 hs 
  hd.mono hts

instance  : CountableInterFilter (residual Œ±) :=
  ‚ü®by 
      intro S hSc hS 
      simp only [mem_residual] at *
      choose T hTs hT using hS 
      refine' ‚ü®‚ãÇ(s : _)(_ : s ‚àà S), T s ‚Äπ_‚Ä∫, _, _, _‚ü©
      ¬∑
        rw [sInter_eq_bInter]
        exact Inter_subset_Inter fun s => Inter_subset_Inter$ hTs s
      ¬∑
        exact is_GŒ¥_bInter hSc fun s hs => (hT s hs).1
      ¬∑
        exact dense_bInter_of_GŒ¥ (fun s hs => (hT s hs).1) hSc fun s hs => (hT s hs).2‚ü©

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is a countable set in any type. -/
theorem dense_bUnion_interior_of_closed {S : Set Œ≤} {f : Œ≤ ‚Üí Set Œ±} (hc : ‚àÄ s _ : s ‚àà S, IsClosed (f s))
  (hS : countable S) (hU : (‚ãÉ(s : _)(_ : s ‚àà S), f s) = univ) : Dense (‚ãÉ(s : _)(_ : s ‚àà S), Interior (f s)) :=
  by 
    let g := fun s => ¬´expr ·∂ú¬ª (Frontier (f s))
    have  : Dense (‚ãÇ(s : _)(_ : s ‚àà S), g s)
    ¬∑
      refine' dense_bInter_of_open (fun s hs => _) hS fun s hs => _ 
      show IsOpen (g s)
      exact is_open_compl_iff.2 is_closed_frontier 
      show Dense (g s)
      ¬∑
        intro x 
        simp [interior_frontier (hc s hs)]
    refine' this.mono _ 
    show (‚ãÇ(s : _)(_ : s ‚àà S), g s) ‚äÜ ‚ãÉ(s : _)(_ : s ‚àà S), Interior (f s)
    intro x hx 
    have  : x ‚àà ‚ãÉ(s : _)(_ : s ‚àà S), f s
    ¬∑
      have  := mem_univ x 
      rwa [‚ÜêhU] at this 
    rcases mem_bUnion_iff.1 this with ‚ü®s, hs, xs‚ü©
    have  : x ‚àà g s := mem_bInter_iff.1 hx s hs 
    have  : x ‚àà Interior (f s)
    ¬∑
      have  : x ‚àà f s \ Frontier (f s) := mem_inter xs this 
      simpa [Frontier, xs, (hc s hs).closure_eq] using this 
    exact mem_bUnion_iff.2 ‚ü®s, ‚ü®hs, this‚ü©‚ü©

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with `‚ãÉ‚ÇÄ`. -/
theorem dense_sUnion_interior_of_closed {S : Set (Set Œ±)} (hc : ‚àÄ s _ : s ‚àà S, IsClosed s) (hS : countable S)
  (hU : ‚ãÉ‚ÇÄS = univ) : Dense (‚ãÉ(s : _)(_ : s ‚àà S), Interior s) :=
  by 
    rw [sUnion_eq_bUnion] at hU <;> exact dense_bUnion_interior_of_closed hc hS hU

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is an encodable type. -/
theorem dense_Union_interior_of_closed [Encodable Œ≤] {f : Œ≤ ‚Üí Set Œ±} (hc : ‚àÄ s, IsClosed (f s))
  (hU : (‚ãÉs, f s) = univ) : Dense (‚ãÉs, Interior (f s)) :=
  by 
    rw [‚ÜêbUnion_univ]
    apply dense_bUnion_interior_of_closed
    ¬∑
      simp [hc]
    ¬∑
      apply countable_encodable
    ¬∑
      rwa [‚ÜêbUnion_univ] at hU

-- error in Topology.MetricSpace.Baire: ././Mathport/Syntax/Translate/Basic.lean:340:40: in by_contradiction: ././Mathport/Syntax/Translate/Tactic/Basic.lean:41:45: missing argument
/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets
covers the space, then one of the sets has nonempty interior. -/
theorem nonempty_interior_of_Union_of_closed
[nonempty Œ±]
[encodable Œ≤]
{f : Œ≤ ‚Üí set Œ±}
(hc : ‚àÄ s, is_closed (f s))
(hU : ¬´expr = ¬ª(¬´expr‚ãÉ , ¬ª((s), f s), univ)) : ¬´expr‚àÉ , ¬ª((s), ¬´expr $ ¬ª(interior, f s).nonempty) :=
begin
  by_contradiction [ident h],
  simp [] [] ["only"] ["[", expr not_exists, ",", expr not_nonempty_iff_eq_empty, "]"] [] ["at", ident h],
  have [] [] [":=", expr calc
     ¬´expr = ¬ª(¬´expr‚àÖ¬ª(), closure ¬´expr‚ãÉ , ¬ª((s), interior (f s))) : by simp [] [] [] ["[", expr h, "]"] [] []
     ¬´expr = ¬ª(..., univ) : (dense_Union_interior_of_closed hc hU).closure_eq],
  exact [expr univ_nonempty.ne_empty this.symm]
end

end BaireTheorem

